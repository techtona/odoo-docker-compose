
/***************************************************************
*  Filepath: /web/static/src/views/graph/graph_arch_parser.js  *
*  Lines: 101                                                  *
***************************************************************/
odoo.define('@web/views/graph/graph_arch_parser', ['@web/core/utils/strings', '@web/core/utils/xml', '@web/search/utils/misc'], function (require) {
'use strict';
let __exports = {};
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");
const { GROUPABLE_TYPES } = require("@web/search/utils/misc");

const MODES = ["bar", "line", "pie"];
const ORDERS = ["ASC", "DESC", "asc", "desc", null];

const GraphArchParser = __exports.GraphArchParser = class GraphArchParser {
    parse(arch, fields = {}) {
        const archInfo = { fields, fieldAttrs: {}, groupBy: [], measures: [] };
        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "graph": {
                    if (node.hasAttribute("disable_linking")) {
                        archInfo.disableLinking = exprToBoolean(
                            node.getAttribute("disable_linking")
                        );
                    }
                    if (node.hasAttribute("stacked")) {
                        archInfo.stacked = exprToBoolean(node.getAttribute("stacked"));
                    }
                    if (node.hasAttribute("cumulated")) {
                        archInfo.cumulated = exprToBoolean(node.getAttribute("cumulated"));
                    }
                    if (node.hasAttribute("cumulated_start")) {
                        archInfo.cumulatedStart = exprToBoolean(
                            node.getAttribute("cumulated_start")
                        );
                    }
                    const mode = node.getAttribute("type");
                    if (mode && MODES.includes(mode)) {
                        archInfo.mode = mode;
                    }
                    const order = node.getAttribute("order");
                    if (order && ORDERS.includes(order)) {
                        archInfo.order = order.toUpperCase();
                    }
                    const title = node.getAttribute("string");
                    if (title) {
                        archInfo.title = title;
                    }
                    break;
                }
                case "field": {
                    const fieldName = node.getAttribute("name"); // exists (rng validation)
                    if (fieldName === "id") {
                        break;
                    }
                    const string = node.getAttribute("string");
                    if (string) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].string = string;
                    }
                    const widget = node.getAttribute("widget");
                    if (widget) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].widget = widget;
                    }
                    if (
                        node.getAttribute("invisible") === "True" ||
                        node.getAttribute("invisible") === "1"
                    ) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].isInvisible = true;
                        break;
                    }
                    const isMeasure = node.getAttribute("type") === "measure";
                    if (isMeasure) {
                        archInfo.measures.push(fieldName);
                        // the last field with type="measure" (if any) will be used as measure else __count
                        archInfo.measure = fieldName;
                    } else {
                        const { type } = archInfo.fields[fieldName]; // exists (rng validation)
                        if (GROUPABLE_TYPES.includes(type)) {
                            let groupBy = fieldName;
                            const interval = node.getAttribute("interval");
                            if (interval) {
                                groupBy += `:${interval}`;
                            }
                            archInfo.groupBy.push(groupBy);
                        }
                    }
                    break;
                }
            }
        });
        return archInfo;
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web/static/src/views/graph/graph_controller.js  *
*  Lines: 65                                                  *
**************************************************************/
odoo.define('@web/views/graph/graph_controller', ['@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, useRef } = require("@odoo/owl");

const GraphController = __exports.GraphController = class GraphController extends Component {
    static template = "web.GraphView";
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);

        useSetupAction({
            rootRef: useRef("root"),
            getLocalState: () => {
                return { metaData: this.model.metaData };
            },
            getContext: () => this.getContext(),
        });
        this.searchBarToggler = useSearchBarToggler();
    }

    /**
     * @returns {Object}
     */
    getContext() {
        // expand context object? change keys?
        const { measure, groupBy, mode } = this.model.metaData;
        const context = {
            graph_measure: measure,
            graph_mode: mode,
            graph_groupbys: groupBy.map((gb) => gb.spec),
        };
        if (mode !== "pie") {
            context.graph_order = this.model.metaData.order;
            context.graph_stacked = this.model.metaData.stacked;
            if (mode === "line") {
                context.graph_cumulated = this.model.metaData.cumulated;
            }
        }
        return context;
    }

    loadAll() {
        return this.model.forceLoadAll();
    }
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web/static/src/views/graph/graph_model.js  *
*  Lines: 671                                            *
*********************************************************/
odoo.define('@web/views/graph/graph_model', ['@web/core/l10n/translation', '@web/core/utils/arrays', '@web/core/utils/concurrency', '@web/search/utils/dates', '@web/search/utils/group_by', '@web/search/utils/misc', '@web/model/model', '@web/views/utils', '@web/core/domain'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { sortBy, groupBy } = require("@web/core/utils/arrays");
const { KeepLast, Race } = require("@web/core/utils/concurrency");
const { rankInterval } = require("@web/search/utils/dates");
const { getGroupBy } = require("@web/search/utils/group_by");
const { GROUPABLE_TYPES } = require("@web/search/utils/misc");
const { addPropertyFieldDefs, Model } = require("@web/model/model");
const { computeReportMeasures, processMeasure } = require("@web/views/utils");
const { Domain } = require("@web/core/domain");

const SEP = __exports.SEP = " / ";
const DATA_LIMIT = 80;

const SEQUENTIAL_TYPES = __exports.SEQUENTIAL_TYPES = ["date", "datetime"];

/**
 * @typedef {import("@web/search/search_model").SearchParams} SearchParams
 */

class DateClasses {
    // We view the param "array" as a matrix of values and undefined.
    // An equivalence class is formed of defined values of a column.
    // So nothing has to do with dates but we only use Dateclasses to manage
    // identification of dates.
    /**
     * @param {(any[])[]} array
     */
    constructor(array) {
        this.__referenceIndex = null;
        this.__array = array;
        for (let i = 0; i < this.__array.length; i++) {
            const arr = this.__array[i];
            if (arr.length && this.__referenceIndex === null) {
                this.__referenceIndex = i;
            }
        }
    }

    /**
     * @param {number} index
     * @param {any} o
     * @returns {string}
     */
    classLabel(index, o) {
        return `${this.__array[index].indexOf(o)}`;
    }

    /**
     * @param {string} classLabel
     * @returns {any[]}
     */
    classMembers(classLabel) {
        const classNumber = Number(classLabel);
        const classMembers = new Set();
        for (const arr of this.__array) {
            if (arr[classNumber] !== undefined) {
                classMembers.add(arr[classNumber]);
            }
        }
        return [...classMembers];
    }

    /**
     * @param {string} classLabel
     * @param {number} [index]
     * @returns {any}
     */
    representative(classLabel, index) {
        const classNumber = Number(classLabel);
        const i = index === undefined ? this.__referenceIndex : index;
        if (i === null) {
            return null;
        }
        return this.__array[i][classNumber];
    }

    /**
     * @param {number} index
     * @returns {number}
     */
    arrayLength(index) {
        return this.__array[index].length;
    }
}

const GraphModel = __exports.GraphModel = class GraphModel extends Model {
    /**
     * @override
     */
    setup(params) {
        // concurrency management
        this.keepLast = new KeepLast();
        this.race = new Race();
        const _fetchDataPoints = this._fetchDataPoints.bind(this);
        this._fetchDataPoints = (...args) => {
            return this.race.add(_fetchDataPoints(...args));
        };

        this.initialGroupBy = null;

        this.metaData = params;
        this.data = null;
        this.searchParams = null;
        // This dataset will be added as a line plot on top of stacked bar chart.
        this.lineOverlayDataset = null;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        this.searchParams = searchParams;
        if (!this.initialGroupBy) {
            this.initialGroupBy = searchParams.context.graph_groupbys || this.metaData.groupBy; // = arch groupBy --> change that
        }
        const metaData = this._buildMetaData();
        await addPropertyFieldDefs(
            this.orm,
            metaData.resModel,
            searchParams.context,
            metaData.fields,
            metaData.groupBy.map((gb) => gb.fieldName)
        );
        await this._fetchDataPoints(metaData);
    }

    async forceLoadAll() {
        const metaData = this._buildMetaData();
        await this._fetchDataPoints(metaData, true);
        this.notify();
    }

    /**
     * @override
     */
    hasData() {
        return this.dataPoints.length > 0;
    }

    /**
     * Only supposed to be called to change one or several parameters among
     * "measure", "mode", "order", "stacked" and "cumulated".
     * @param {Object} params
     */
    async updateMetaData(params) {
        if ("measure" in params) {
            const metaData = this._buildMetaData(params);
            await this._fetchDataPoints(metaData);
            this.useSampleModel = false;
        } else {
            await this.race.getCurrentProm();
            this.metaData = Object.assign({}, this.metaData, params);
            this._prepareData();
        }
        this.notify();
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    /**
     * @protected
     * @param {Object} [params={}]
     * @returns {Object}
     */
    _buildMetaData(params) {
        const { comparison, domain, context, groupBy } = this.searchParams;

        const metaData = Object.assign({}, this.metaData, { context });
        if (comparison) {
            metaData.domains = comparison.domains;
            metaData.comparisonField = comparison.fieldName;
        } else {
            metaData.domains = [{ arrayRepr: domain, description: null }];
        }
        metaData.measure = context.graph_measure || metaData.measure;
        metaData.mode = context.graph_mode || metaData.mode;
        metaData.groupBy = groupBy.length ? groupBy : this.initialGroupBy;
        if (metaData.mode !== "pie") {
            metaData.order = "graph_order" in context ? context.graph_order : metaData.order;
            if (comparison) {
                metaData.stacked = false;
            } else if ("graph_stacked" in context) {
                metaData.stacked = context.graph_stacked;
            }
            if (metaData.mode === "line") {
                metaData.cumulated =
                    "graph_cumulated" in context ? context.graph_cumulated : metaData.cumulated;
            }
        }

        this._normalize(metaData);

        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [
            ...(metaData.viewMeasures || []),
            metaData.measure,
        ]);

        return Object.assign(metaData, params);
    }

    /**
     * Fetch the data points determined by the metaData. This function has
     * several side effects. It can alter this.metaData and set this.dataPoints.
     * @protected
     * @param {Object} metaData
     * @param {boolean} [forceUseAllDataPoints=false]
     */
    async _fetchDataPoints(metaData, forceUseAllDataPoints = false) {
        this.dataPoints = await this.keepLast.add(this._loadDataPoints(metaData));
        this.metaData = metaData;
        this._prepareData(forceUseAllDataPoints);
    }

    /**
     * Separates dataPoints coming from the read_group(s) into different
     * datasets. This function returns the parameters data and labels used
     * to produce the charts.
     * @protected
     * @param {Object[]} dataPoints
     * @param {boolean} forceUseAllDataPoints
     * @returns {Object}
     */
    _getData(dataPoints, forceUseAllDataPoints) {
        const { comparisonField, groupBy, mode } = this.metaData;

        let identify = false;
        if (comparisonField && groupBy.length && groupBy[0].fieldName === comparisonField) {
            identify = true;
        }
        const dateClasses = identify ? this._getDateClasses(dataPoints) : null;

        const dataPtMapping = new WeakMap();
        const datasetsTmp = {};
        let exceeds = false;

        // dataPoints --> labels
        let labels = [];
        const labelMap = {};
        for (const dataPt of dataPoints) {
            const datasetLabel = this._getDatasetLabel(dataPt);
            if (!(datasetLabel in datasetsTmp)) {
                if (!forceUseAllDataPoints && Object.keys(datasetsTmp).length >= DATA_LIMIT) {
                    exceeds = true;
                    continue;
                }
                datasetsTmp[datasetLabel] = {
                    label: datasetLabel,
                    originIndex: dataPt.originIndex,
                }; // add the entry but don't initialize it entirely
            }
            dataPtMapping.set(dataPt, datasetsTmp[datasetLabel]);

            const x = dataPt.labels.slice(0, mode === "pie" ? undefined : 1);
            const trueLabel = x.length ? x.join(SEP) : _t("Total");
            if (dateClasses) {
                x[0] = dateClasses.classLabel(dataPt.originIndex, x[0]);
            }
            const key = JSON.stringify(x);
            if (labelMap[key] === undefined) {
                labelMap[key] = labels.length;
                if (dateClasses) {
                    if (mode === "pie") {
                        x[0] = dateClasses.classMembers(x[0]).join(", ");
                    } else {
                        x[0] = dateClasses.representative(x[0]);
                    }
                }
                const label = x.length ? x.join(SEP) : _t("Total");
                labels.push(label);
            }
            dataPt.labelIndex = labelMap[key];
            dataPt.trueLabel = trueLabel;
        }

        // dataPoints + labels --> datasetsTmp --> datasets
        for (const dataPt of dataPoints) {
            if (!dataPtMapping.has(dataPt)) {
                continue;
            }

            const {
                domain,
                labelIndex,
                originIndex,
                trueLabel,
                value,
                identifier,
                cumulatedStart,
            } = dataPt;
            const dataset = dataPtMapping.get(dataPt);
            if (!dataset.data) {
                let dataLength = labels.length;
                if (mode !== "pie" && dateClasses) {
                    dataLength = dateClasses.arrayLength(originIndex);
                }
                Object.assign(dataset, {
                    data: new Array(dataLength).fill(0),
                    cumulatedStart,
                    trueLabels: labels.slice(0, dataLength), // should be good // check this in case identify = true
                    domains: new Array(dataLength).fill([]),
                    identifiers: new Set(),
                });
            }
            dataset.data[labelIndex] = value;
            dataset.domains[labelIndex] = domain;
            dataset.trueLabels[labelIndex] = trueLabel;
            dataset.identifiers.add(identifier);
        }
        // sort by origin
        let datasets = sortBy(Object.values(datasetsTmp), "originIndex");

        if (mode === "pie") {
            // We kinda have a matrix. We remove the zero columns and rows. This is a global operation.
            // That's why it cannot be done before.
            datasets = datasets.filter((dataset) => dataset.data.some((v) => Boolean(v)));
            const labelsToKeepIndexes = {};
            labels.forEach((_, index) => {
                if (datasets.some((dataset) => Boolean(dataset.data[index]))) {
                    labelsToKeepIndexes[index] = true;
                }
            });
            labels = labels.filter((_, index) => labelsToKeepIndexes[index]);
            for (const dataset of datasets) {
                dataset.data = dataset.data.filter((_, index) => labelsToKeepIndexes[index]);
                dataset.domains = dataset.domains.filter((_, index) => labelsToKeepIndexes[index]);
                dataset.trueLabels = dataset.trueLabels.filter(
                    (_, index) => labelsToKeepIndexes[index]
                );
            }
        }

        return {
            datasets,
            labels,
            exceeds,
        };
    }

    _getLabel(description) {
        if (!description) {
            return _t("Sum");
        } else {
            return _t("Sum (%s)", description);
        }
    }

    _getLineOverlayDataset() {
        const { domains, stacked } = this.metaData;
        const data = this.data;
        let lineOverlayDataset = null;
        if (stacked) {
            const stacks = groupBy(data.datasets, (dataset) => dataset.originIndex);
            if (Object.keys(stacks).length == 1) {
                const [[originIndex, datasets]] = Object.entries(stacks);
                if (datasets.length > 1) {
                    const data = [];
                    for (const dataset of datasets) {
                        for (let i = 0; i < dataset.data.length; i++) {
                            data[i] = (data[i] || 0) + dataset.data[i];
                        }
                    }
                    lineOverlayDataset = {
                        label: this._getLabel(domains[originIndex].description),
                        data,
                        trueLabels: datasets[0].trueLabels,
                    };
                }
            }
        }
        return lineOverlayDataset;
    }

    /**
     * Determines the dataset to which the data point belongs.
     * @protected
     * @param {Object} dataPoint
     * @returns {string}
     */
    _getDatasetLabel(dataPoint) {
        const { measure, measures, domains, mode } = this.metaData;
        const { labels, originIndex } = dataPoint;
        if (mode === "pie") {
            return domains[originIndex].description || "";
        }
        // ([origin] + second to last groupBys) or measure
        let datasetLabel = labels.slice(1).join(SEP);
        if (domains.length > 1) {
            datasetLabel =
                domains[originIndex].description + (datasetLabel ? SEP + datasetLabel : "");
        }
        datasetLabel = datasetLabel || measures[measure].string;
        return datasetLabel;
    }

    /**
     * @protected
     * @param {Object[]} dataPoints
     * @returns {DateClasses}
     */
    _getDateClasses(dataPoints) {
        const { domains } = this.metaData;
        const dateSets = domains.map(() => new Set());
        for (const { labels, originIndex } of dataPoints) {
            const date = labels[0];
            dateSets[originIndex].add(date);
        }
        const arrays = dateSets.map((dateSet) => [...dateSet]);
        return new DateClasses(arrays);
    }

    /**
     * @protected
     * @returns {string}
     */
    _getDefaultFilterLabel(field) {
        return _t("None");
    }

    /**
     * Eventually filters and sort data points.
     * @protected
     * @returns {Object[]}
     */
    _getProcessedDataPoints() {
        const { domains, groupBy, mode, order } = this.metaData;
        let processedDataPoints = [];
        if (mode === "line") {
            processedDataPoints = this.dataPoints.filter(
                (dataPoint) => dataPoint.labels[0] !== this._getDefaultFilterLabel(groupBy[0])
            );
        } else if (mode === "pie") {
            processedDataPoints = this.dataPoints.filter(
                (dataPoint) => dataPoint.value > 0 && dataPoint.count !== 0
            );
        } else {
            processedDataPoints = this.dataPoints.filter((dataPoint) => dataPoint.count !== 0);
        }

        if (order !== null && mode !== "pie" && domains.length === 1 && groupBy.length > 0) {
            // group data by their x-axis value, and then sort datapoints
            // based on the sum of values by group in ascending/descending order
            const groupedDataPoints = {};
            for (const dataPt of processedDataPoints) {
                const key = dataPt.labels[0]; // = x-axis value under the current assumptions
                if (!groupedDataPoints[key]) {
                    groupedDataPoints[key] = [];
                }
                groupedDataPoints[key].push(dataPt);
            }
            const groups = Object.values(groupedDataPoints);
            const groupTotal = (group) => group.reduce((sum, dataPt) => sum + dataPt.value, 0);
            processedDataPoints = sortBy(groups, groupTotal, order.toLowerCase()).flat();
        }

        return processedDataPoints;
    }

    /**
     * Fetch and process graph data.  It is basically a(some) read_group(s)
     * with correct fields for each domain.  We have to do some light processing
     * to separate date groups in the field list, because they can be defined
     * with an aggregation function, such as my_date:week.
     * @protected
     * @param {Object} metaData
     * @returns {Object[]}
     */
    async _loadDataPoints(metaData) {
        const { measure, domains, fields, groupBy, resModel, cumulatedStart } = metaData;
        const fieldName = groupBy[0]?.fieldName;
        const sequential_field =
            cumulatedStart && SEQUENTIAL_TYPES.includes(fields[fieldName]?.type) ? fieldName : null;
        const sequential_spec = sequential_field && groupBy[0].spec;
        const measures = ["__count"];
        if (measure !== "__count") {
            let { aggregator, type } = fields[measure];
            if (type === "many2one") {
                aggregator = "count_distinct";
            }
            if (aggregator === undefined) {
                throw new Error(
                    `No aggregate function has been provided for the measure '${measure}'`
                );
            }
            measures.push(`${measure}:${aggregator}`);
        }

        const numbering = {}; // used to avoid ambiguity with many2one with values with same labels:
        // for instance [1, "ABC"] [3, "ABC"] should be distinguished.

        const proms = domains.map(async (domain, originIndex) => {
            const data = await this.orm.webReadGroup(
                resModel,
                domain.arrayRepr,
                measures,
                groupBy.map((gb) => gb.spec),
                {
                    lazy: false, // what is this thing???
                    context: { fill_temporal: true, ...this.searchParams.context },
                }
            );
            let start = false;
            if (
                cumulatedStart &&
                sequential_field &&
                data.groups.length &&
                domain.arrayRepr.some((leaf) => leaf.length === 3 && leaf[0] == sequential_field)
            ) {
                const first_date = data.groups[0].__range[sequential_spec].from;
                const new_domain = Domain.combine(
                    [
                        new Domain([[sequential_field, "<", first_date]]),
                        Domain.removeDomainLeaves(domain.arrayRepr, [sequential_field]),
                    ],
                    "AND"
                ).toList();
                start = await this.orm.webReadGroup(
                    resModel,
                    new_domain,
                    measures,
                    groupBy.filter((gb) => gb.fieldName != sequential_field).map((gb) => gb.spec),
                    {
                        lazy: false, // what is this thing???
                        context: { ...this.searchParams.context },
                    }
                );
            }
            const dataPoints = [];
            const cumulatedStartValue = {};
            if (start) {
                for (const group of start.groups) {
                    const rawValues = [];
                    for (const gb of groupBy.filter((gb) => gb.fieldName != sequential_field)) {
                        rawValues.push({ [gb.spec]: group[gb.spec] });
                    }
                    cumulatedStartValue[JSON.stringify(rawValues)] = group[measure];
                }
            }
            for (const group of data.groups) {
                const { __domain, __count } = group;
                const labels = [];
                const rawValues = [];
                for (const gb of groupBy) {
                    let label;
                    const val = group[gb.spec];
                    rawValues.push({ [gb.spec]: val });
                    const fieldName = gb.fieldName;
                    const { type } = fields[fieldName];
                    if (type === "boolean") {
                        label = `${val}`; // toUpperCase?
                    } else if (val === false) {
                        label = this._getDefaultFilterLabel(gb);
                    } else if (["many2many", "many2one"].includes(type)) {
                        const [id, name] = val;
                        const key = JSON.stringify([fieldName, name]);
                        if (!numbering[key]) {
                            numbering[key] = {};
                        }
                        const numbers = numbering[key];
                        if (!numbers[id]) {
                            numbers[id] = Object.keys(numbers).length + 1;
                        }
                        const num = numbers[id];
                        label = num === 1 ? name : `${name} (${num})`;
                    } else if (type === "selection") {
                        const selected = fields[fieldName].selection.find((s) => s[0] === val);
                        label = selected[1];
                    } else {
                        label = val;
                    }
                    labels.push(label);
                }

                let value = group[measure];
                if (value instanceof Array) {
                    // case where measure is a many2one and is used as groupBy
                    value = 1;
                }
                if (!Number.isInteger(value)) {
                    metaData.allIntegers = false;
                }
                const group_id = JSON.stringify(rawValues.slice(1));
                dataPoints.push({
                    count: __count,
                    domain: __domain,
                    value,
                    labels,
                    originIndex,
                    identifier: JSON.stringify(rawValues),
                    cumulatedStart: cumulatedStartValue[group_id] || 0,
                });
            }
            return dataPoints;
        });
        const promResults = await Promise.all(proms);
        return promResults.flat();
    }

    /**
     * Process metaData.groupBy in order to keep only the finest interval option for
     * elements based on date/datetime field (e.g. 'date:year'). This means that
     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.
     * For instance,
     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].
     * @protected
     * @param {Object} metaData
     */
    _normalize(metaData) {
        const { fields } = metaData;
        const groupBy = [];
        for (const gb of metaData.groupBy) {
            let ngb = gb;
            if (typeof gb === "string") {
                ngb = getGroupBy(gb, fields);
            }
            groupBy.push(ngb);
        }

        const processedGroupBy = [];
        for (const gb of groupBy) {
            const { fieldName, interval } = gb;
            if (!fieldName.includes(".")) {
                const { groupable, type } = fields[fieldName];
                if (
                    // cf. _description_groupable in odoo/fields.py
                    !groupable ||
                    ["id", "__count"].includes(fieldName) ||
                    !GROUPABLE_TYPES.includes(type)
                ) {
                    continue;
                }
            }
            const index = processedGroupBy.findIndex((gb) => gb.fieldName === fieldName);
            if (index === -1) {
                processedGroupBy.push(gb);
            } else if (interval) {
                const registeredInterval = processedGroupBy[index].interval;
                if (rankInterval(registeredInterval) < rankInterval(interval)) {
                    processedGroupBy.splice(index, 1, gb);
                }
            }
        }
        metaData.groupBy = processedGroupBy;

        metaData.measure = processMeasure(metaData.measure);
    }

    /**
     * @protected
     * @param {boolean} [forceUseAllDataPoints=false]
     */
    _prepareData(forceUseAllDataPoints = false) {
        const processedDataPoints = this._getProcessedDataPoints();
        this.data = this._getData(processedDataPoints, forceUseAllDataPoints);
        this.lineOverlayDataset = null;
        if (this.metaData.mode === "bar") {
            this.lineOverlayDataset = this._getLineOverlayDataset();
        }
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web/static/src/views/graph/graph_renderer.js  *
*  Lines: 932                                               *
************************************************************/
odoo.define('@web/views/graph/graph_renderer', ['@web/core/l10n/translation', '@web/core/colors/colors', '@web/core/registry', '@web/views/fields/formatters', '@web/views/graph/graph_model', '@web/core/utils/arrays', '@web/core/assets', '@web/core/utils/render', '@web/core/utils/hooks', '@odoo/owl', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/browser/cookie', '@web/views/view_components/report_view_measures'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const {
    getBorderWhite,
    DEFAULT_BG,
    getColor,
    getCustomColor,
    lightenColor,
    darkenColor,
} = require("@web/core/colors/colors");
const { registry } = require("@web/core/registry");
const { formatFloat } = require("@web/views/fields/formatters");
const { SEP } = require("@web/views/graph/graph_model");
const { sortBy } = require("@web/core/utils/arrays");
const { loadBundle } = require("@web/core/assets");
const { renderToString } = require("@web/core/utils/render");
const { useService } = require("@web/core/utils/hooks");

const { Component, onWillUnmount, useEffect, useRef, onWillStart } = require("@odoo/owl");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { cookie } = require("@web/core/browser/cookie");
const { ReportViewMeasures } = require("@web/views/view_components/report_view_measures");

const NO_DATA = _t("No data");
const formatters = registry.category("formatters");

const colorScheme = cookie.get("color_scheme");
const GRAPH_LEGEND_COLOR = getCustomColor(colorScheme, "#111827", "#ffffff");
const GRAPH_GRID_COLOR = getCustomColor(colorScheme, "rgba(0,0,0,.1)", "rgba(255,255,255,.15");
const GRAPH_LABEL_COLOR = getCustomColor(colorScheme, "#111827", "#E4E4E4");
const NO_DATA_COLOR = getCustomColor(colorScheme, DEFAULT_BG, "#3C3E4B");

/**
 * Custom Plugin for Line chart:
 * Draw the scale grid on top of the chart to
 * see this last one correctly.
 */
const gridOnTop = {
    id: "gridOnTop",
    afterDraw: (chart) => {
        const elements = chart.getDatasetMeta(0).data || [];
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const yAxis = chart.scales.y;
        const xAxis = chart.scales.x;

        ctx.lineWidth = 1;
        ctx.strokeStyle = GRAPH_GRID_COLOR;

        // Draw Y axis scale
        yAxis.ticks.forEach((value, index) => {
            const y = yAxis.getPixelForTick(index);
            ctx.beginPath();
            // Draw the line scale
            ctx.moveTo(chartArea.left, y);
            ctx.lineTo(chartArea.right, y);
            // Draw the tick mark
            ctx.moveTo(chartArea.left - 8, y);
            ctx.lineTo(chartArea.left, y);
            ctx.setLineDash([]);
            ctx.stroke();
        });

        // Draw X axis tick marks
        xAxis.ticks.forEach((value, tickIndex) => {
            const x = xAxis.getPixelForTick(tickIndex);
            ctx.beginPath();
            ctx.moveTo(x, chartArea.bottom);
            ctx.lineTo(x, chartArea.bottom + 8);
            ctx.stroke();
        });

        // Draw the X axis dashed line
        elements.forEach((point, eltIndex) => {
            xAxis.ticks.forEach((value, tickIndex) => {
                if (point.active && eltIndex === tickIndex) {
                    const x = xAxis.getPixelForTick(tickIndex);
                    ctx.beginPath();
                    ctx.moveTo(x, chartArea.top);
                    ctx.lineTo(x, chartArea.bottom);
                    ctx.strokeStyle = GRAPH_GRID_COLOR;
                    ctx.stroke();
                }
            });
        });
    },
};

/**
 * @param {Object} chartArea
 * @returns {string}
 */
function getMaxWidth(chartArea) {
    const { left, right } = chartArea;
    return Math.floor((right - left) / 1.618) + "px";
}

/**
 * Used to avoid too long legend items.
 * @param {string} label
 * @returns {string} shortened version of the input label
 */
function shortenLabel(label) {
    // string returned could be wrong if a groupby value contain a " / "!
    const groups = label.toString().split(SEP);
    let shortLabel = groups.slice(0, 3).join(SEP);
    if (shortLabel.length > 30) {
        shortLabel = `${shortLabel.slice(0, 30)}...`;
    } else if (groups.length > 3) {
        shortLabel = `${shortLabel}${SEP}...`;
    }
    return shortLabel;
}

const GraphRenderer = __exports.GraphRenderer = class GraphRenderer extends Component {
    static template = "web.GraphRenderer";
    static components = { Dropdown, DropdownItem, ReportViewMeasures };
    static props = ["class?", "model", "buttonTemplate"];

    setup() {
        this.model = this.props.model;

        this.rootRef = useRef("root");
        this.canvasRef = useRef("canvas");
        this.containerRef = useRef("container");
        this.actionService = useService("action");

        this.chart = null;
        this.tooltip = null;
        this.legendTooltip = null;

        onWillStart(async () => {
            await loadBundle("web.chartjs_lib");
        });

        useEffect(() => this.renderChart());
        onWillUnmount(this.onWillUnmount);
    }

    onWillUnmount() {
        if (this.chart) {
            this.chart.destroy();
        }
    }

    /**
     * This function aims to remove a suitable number of lines from the
     * tooltip in order to make it reasonably visible. A message indicating
     * the number of lines is added if necessary.
     * @param {HTMLElement} tooltip
     * @param {number} maxTooltipHeight this the max height in pixels of the tooltip
     */
    adjustTooltipHeight(tooltip, maxTooltipHeight) {
        const sizeOneLine = tooltip.querySelector("tbody tr").clientHeight;
        const tbodySize = tooltip.querySelector("tbody").clientHeight;
        const toKeep = Math.max(
            0,
            Math.floor((maxTooltipHeight - (tooltip.clientHeight - tbodySize)) / sizeOneLine) - 1
        );
        const lines = tooltip.querySelectorAll("tbody tr");
        const toRemove = lines.length - toKeep;
        if (toRemove > 0) {
            for (let index = toKeep; index < lines.length; ++index) {
                lines[index].remove();
            }
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            tr.classList.add("o_show_more", "text-center", "fw-bold");
            td.setAttribute("colspan", "2");
            td.innerText = _t("...");
            tr.appendChild(td);
            tooltip.querySelector("tbody").appendChild(tr);
        }
    }

    /**
     * Creates a custom HTML tooltip.
     * @param {Object} data
     * @param {Object} metaData
     * @param {Object} context see chartjs documentation
     */
    customTooltip(data, metaData, context) {
        const tooltipModel = context.tooltip;
        const { measure, measures, disableLinking, mode } = metaData;
        this.containerRef.el.style.cursor = "";
        this.removeTooltips();
        if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {
            return;
        }
        if (!disableLinking && mode !== "line") {
            this.containerRef.el.style.cursor = "pointer";
        }
        const chartAreaTop = this.chart.chartArea.top;
        const viewContentTop = this.containerRef.el.getBoundingClientRect().top;
        const innerHTML = renderToString("web.GraphRenderer.CustomTooltip", {
            maxWidth: getMaxWidth(this.chart.chartArea),
            measure: measures[measure].string,
            mode: this.model.metaData.mode,
            tooltipItems: this.getTooltipItems(data, metaData, tooltipModel),
        });
        const template = Object.assign(document.createElement("template"), { innerHTML });
        const tooltip = template.content.firstChild;
        this.containerRef.el.prepend(tooltip);

        let top;
        const tooltipHeight = tooltip.clientHeight;
        const minTopAllowed = Math.floor(chartAreaTop);
        const maxTopAllowed = Math.floor(window.innerHeight - (viewContentTop + tooltipHeight)) - 2;
        const y = Math.floor(tooltipModel.y);
        if (minTopAllowed <= maxTopAllowed) {
            // Here we know that the full tooltip can fit in the screen.
            // We put it in the position where Chart.js would put it
            // if two conditions are respected:
            //  1: the tooltip is not cut (because we know it is possible to not cut it)
            //  2: the tooltip does not hide the legend.
            // If it is not possible to use the Chart.js proposition (y)
            // we use the best approximated value.
            if (y <= maxTopAllowed) {
                if (y >= minTopAllowed) {
                    top = y;
                } else {
                    top = minTopAllowed;
                }
            } else {
                top = maxTopAllowed;
            }
        } else {
            // Here we know that we cannot satisfy condition 1 above,
            // so we position the tooltip at the minimal position and
            // cut it the minimum possible.
            top = minTopAllowed;
            const maxTooltipHeight = window.innerHeight - (viewContentTop + chartAreaTop) - 2;
            this.adjustTooltipHeight(tooltip, maxTooltipHeight);
        }
        this.fixTooltipLeftPosition(tooltip, tooltipModel.x);
        tooltip.style.top = Math.floor(top) + "px";

        this.tooltip = tooltip;
    }

    /**
     * Sets best left position of a tooltip approaching the proposal x.
     * @param {HTMLElement} tooltip
     * @param {number} x
     */
    fixTooltipLeftPosition(tooltip, x) {
        let left;
        const tooltipWidth = tooltip.clientWidth;
        const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);
        const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);
        x = Math.floor(x);
        if (x < minLeftAllowed) {
            left = minLeftAllowed;
        } else if (x > maxLeftAllowed) {
            left = maxLeftAllowed;
        } else {
            left = x;
        }
        tooltip.style.left = `${left}px`;
    }

    /**
     * Used to format correctly the values in tooltip and y.
     * @param {number} value
     * @param {boolean} [allIntegers=true]
     * @returns {string}
     */
    formatValue(value, allIntegers = true, formatType = "") {
        const largeNumber = Math.abs(value) >= 1000;
        if (formatType) {
            return formatters.get(formatType)(value);
        }
        if (allIntegers && !largeNumber) {
            return String(value);
        }
        if (largeNumber) {
            return formatFloat(value, { humanReadable: true, decimals: 2, minDigits: 1 });
        }
        return formatFloat(value);
    }

    /**
     * Returns the bar chart data
     * @returns {Object}
     */
    getBarChartData() {
        // style data
        const { domains, stacked } = this.model.metaData;
        const { data, lineOverlayDataset } = this.model;
        for (let index = 0; index < data.datasets.length; ++index) {
            const dataset = data.datasets[index];
            const itemColor = getColor(index, colorScheme, data.datasets.length);
            // used when stacked
            if (stacked) {
                dataset.stack = domains[dataset.originIndex].description || "";
            }
            // set dataset color
            dataset.backgroundColor = itemColor;
            dataset.borderRadius = 4;
        }
        if (lineOverlayDataset) {
            // Mutate the lineOverlayDataset to include the config on how it will be displayed.
            Object.assign(lineOverlayDataset, {
                type: "line",
                order: -1,
                tension: 0,
                fill: false,
                pointHitRadius: 20,
                pointRadius: 5,
                pointHoverRadius: 10,
                backgroundColor: getCustomColor(colorScheme, "#343a40", "#e9ecef"),
                borderColor: getCustomColor(colorScheme, "rgba(0,0,0,.3)", "rgba(255,255,255,.5)"),
                borderWidth: 2,
                lineWidth: 3,
            });
            // We're not mutating the original datasets (`this.model.data.datasets`)
            // because some part of the code depends on it.
            return {
                ...data,
                datasets: [...data.datasets, lineOverlayDataset],
            };
        }

        return data;
    }

    /**
     * Returns the chart config.
     * @returns {Object}
     */
    getChartConfig() {
        const { mode } = this.model.metaData;
        let data;
        switch (mode) {
            case "bar":
                data = this.getBarChartData();
                break;
            case "line":
                data = this.getLineChartData();
                break;
            case "pie":
                data = this.getPieChartData();
        }
        const options = this.prepareOptions();
        const config = { data, options, type: mode };
        if (mode === "line") {
            config.plugins = [gridOnTop];
        }
        return config;
    }

    /**
     * Returns the animation options.
     * 1. This adds progressive animation for Bar & Line charts.
     * 2. Reduce animation duration for Pie chart.
     * @returns {Object}
     */
    getAnimationOptions() {
        let delayed;
        const { mode } = this.model.metaData;
        const labelsCount = this.model.data.labels.length;
        const gap = 350;
        const animationOptions = {};
        if (mode === "pie") {
            animationOptions.offset = { duration: 200 };
        } else {
            animationOptions.duration = 600;
            animationOptions.onComplete = () => {
                delayed = true;
            };
            animationOptions.delay = (context) => {
                let delay = 0;
                if ((mode === "bar" || mode === "line") && !delayed) {
                    delay = context.dataIndex * (gap / labelsCount);
                }
                return delay;
            };
        }
        return animationOptions;
    }

    /**
     * Returns an object used to style chart elements independently from
     * the datasets.
     * @returns {Object}
     */
    getElementOptions() {
        const { mode, stacked } = this.model.metaData;
        const elementOptions = {};
        if (mode === "bar") {
            elementOptions.bar = { borderWidth: 1 };
        } else if (mode === "line") {
            elementOptions.line = { fill: stacked, tension: 0 };
        }
        return elementOptions;
    }

    /**
     * @returns {Object}
     */
    getLegendOptions() {
        const { mode } = this.model.metaData;
        const legendOptions = {
            onHover: this.onLegendHover.bind(this),
            onLeave: this.onLegendLeave.bind(this),
        };
        if (mode === "line") {
            legendOptions.onClick = this.onLegendClick.bind(this);
        }
        if (mode === "pie") {
            legendOptions.labels = {
                generateLabels: (chart) => {
                    return chart.data.labels.map((label, index) => {
                        const hidden = !chart.getDataVisibility(index);
                        const fullText = label;
                        const text = shortenLabel(fullText);
                        const fillStyle =
                            label === NO_DATA
                                ? NO_DATA_COLOR
                                : getColor(index, colorScheme, chart.data.labels.length);
                        return {
                            text,
                            fullText,
                            fillStyle,
                            hidden,
                            index,
                            fontColor: GRAPH_LEGEND_COLOR,
                            lineWidth: 0,
                        };
                    });
                },
            };
        } else {
            legendOptions.position = "top";
            legendOptions.align = "end";
            const referenceColor = mode === "bar" ? "backgroundColor" : "borderColor";
            legendOptions.labels = {
                generateLabels: (chart) => {
                    const { data } = chart;
                    const labels = data.datasets.map((dataset, index) => {
                        return {
                            text: shortenLabel(dataset.label),
                            fullText: dataset.label,
                            fillStyle: dataset[referenceColor],
                            hidden: !chart.isDatasetVisible(index),
                            lineCap: dataset.borderCapStyle,
                            lineDash: dataset.borderDash,
                            lineDashOffset: dataset.borderDashOffset,
                            lineJoin: dataset.borderJoinStyle,
                            lineWidth: dataset.borderWidth,
                            strokeStyle: dataset[referenceColor],
                            pointStyle: dataset.pointStyle,
                            datasetIndex: index,
                            fontColor: GRAPH_LEGEND_COLOR,
                        };
                    });
                    return labels;
                },
            };
        }
        return legendOptions;
    }

    /**
     * Returns line chart data.
     * @returns {Object}
     */
    getLineChartData() {
        const { cumulated } = this.model.metaData;
        const data = this.model.data;
        for (let index = 0; index < data.datasets.length; ++index) {
            const dataset = data.datasets[index];
            const itemColor = getColor(index, colorScheme, data.datasets.length);
            dataset.backgroundColor = getCustomColor(
                colorScheme,
                lightenColor(itemColor, 0.5),
                darkenColor(itemColor, 0.5)
            );
            dataset.cubicInterpolationMode = "monotone";
            dataset.borderColor = itemColor;
            dataset.borderWidth = 2;
            dataset.hoverBackgroundColor = dataset.borderColor;
            dataset.pointRadius = 3;
            dataset.pointHoverRadius = 6;
            if (cumulated) {
                let accumulator = dataset.cumulatedStart;
                dataset.data = dataset.data.map((value) => {
                    accumulator += value;
                    return accumulator;
                });
            }
            if (data.labels.length === 1) {
                // shift of the real value to right. This is done to
                // center the points in the chart. See data.labels below in
                // Chart parameters
                dataset.data.unshift(undefined);
                dataset.trueLabels.unshift(undefined);
                dataset.domains.unshift(undefined);
            }
            dataset.pointBackgroundColor = dataset.borderColor;
        }
        // center the points in the chart (without that code they are put
        // on the left and the graph seems empty)
        data.labels = data.labels.length > 1 ? data.labels : ["", ...data.labels, ""];
        return data;
    }

    /**
     * Returns pie chart data.
     * @returns {Object}
     */
    getPieChartData() {
        const { domains } = this.model.metaData;
        const data = this.model.data;
        // style/complete data
        // give same color to same groups from different origins
        const colors = data.labels.map((_, index) =>
            getColor(index, colorScheme, data.labels.length)
        );
        const borderColor = getBorderWhite(colorScheme);
        for (const dataset of data.datasets) {
            dataset.backgroundColor = colors;
            dataset.hoverBackgroundColor = colors;
            dataset.borderColor = borderColor;
            dataset.hoverOffset = 60;
        }
        // make sure there is a zone associated with every origin
        const representedOriginIndexes = new Set(
            data.datasets.map((dataset) => dataset.originIndex)
        );
        let addNoDataToLegend = false;
        const fakeData = new Array(data.labels.length + 1);
        fakeData[data.labels.length] = 1;
        const fakeTrueLabels = new Array(data.labels.length + 1);
        fakeTrueLabels[data.labels.length] = NO_DATA;
        for (let index = 0; index < domains.length; ++index) {
            if (!representedOriginIndexes.has(index)) {
                data.datasets.push({
                    label: domains[index].description,
                    data: fakeData,
                    trueLabels: fakeTrueLabels,
                    backgroundColor: [...colors, NO_DATA_COLOR],
                    borderColor,
                });
                addNoDataToLegend = true;
            }
        }
        if (addNoDataToLegend) {
            data.labels.push(NO_DATA);
        }

        return data;
    }

    /**
     * Returns the options used to generate the chart axes.
     * @returns {Object}
     */
    getScaleOptions() {
        const { labels } = this.model.data;
        const { fieldAttrs, measure, measures, mode, stacked } = this.model.metaData;
        if (mode === "pie") {
            return {};
        }
        const xAxe = {
            type: "category",
            ticks: {
                callback: (val, index) => {
                    const value = labels[index];
                    return shortenLabel(value);
                },
                color: GRAPH_LABEL_COLOR,
            },
            grid: {
                color: "transparent",
            },
            border: {
                display: false,
            },
        };
        const yAxe = {
            beginAtZero: true,
            type: "linear",
            title: {
                text: measures[measure].string,
                color:
                    cookie.get("color_scheme") === "dark"
                        ? getColor(15, cookie.get("color_scheme"))
                        : null,
            },
            ticks: {
                callback: (value) => this.formatValue(value, false, fieldAttrs[measure]?.widget),
                color: GRAPH_LABEL_COLOR,
            },
            stacked: mode === "line" && stacked ? stacked : undefined,
            grid: {
                display: mode === "line" ? false : true,
                color: GRAPH_GRID_COLOR,
            },
            border: {
                display: false,
            },
            suggestedMax: 0,
            suggestedMin: 0,
        };
        return { x: xAxe, y: yAxe };
    }

    /**
     * This function extracts the information from the data points in
     * tooltipModel.dataPoints (corresponding to datapoints over a given
     * label determined by the mouse position) that will be displayed in a
     * custom tooltip.
     * @param {Object} data
     * @param {Object} metaData
     * @param {Object} tooltipModel see chartjs documentation
     * @returns {Object[]}
     */
    getTooltipItems(data, metaData, tooltipModel) {
        const { allIntegers, domains, mode, groupBy, measure } = metaData;
        const sortedDataPoints = sortBy(tooltipModel.dataPoints, "raw", "desc");
        const items = [];
        for (const item of sortedDataPoints) {
            const index = item.dataIndex;
            // If `datasetIndex` is not found in the `datasets`, then it refers to the `lineOverlayDataset`.
            const dataset = data.datasets[item.datasetIndex] || this.model.lineOverlayDataset;
            let label = dataset.trueLabels[index];
            let value = dataset.data[index];
            const measureWidget = metaData.fieldAttrs[measure]?.widget;
            value = this.formatValue(value, allIntegers, measureWidget);
            let boxColor;
            let percentage;
            if (mode === "pie") {
                if (label === NO_DATA) {
                    value = this.formatValue(0, allIntegers, measureWidget);
                }
                if (domains.length > 1) {
                    label = `${dataset.label} / ${label}`;
                }
                boxColor = dataset.backgroundColor[index];
                const totalData = dataset.data.reduce((a, b) => a + b, 0);
                percentage = totalData && ((dataset.data[index] * 100) / totalData).toFixed(2);
            } else {
                if (groupBy.length > 1 || domains.length > 1) {
                    label = `${label} / ${dataset.label}`;
                }
                boxColor = mode === "bar" ? dataset.backgroundColor : dataset.borderColor;
            }
            items.push({ label, value, boxColor, percentage });
        }
        return items;
    }

    /**
     * Returns the options used to generate chart tooltips.
     * @returns {Object}
     */
    getTooltipOptions() {
        const { data, metaData } = this.model;
        const { mode } = metaData;
        const tooltipOptions = {
            enabled: false,
            external: this.customTooltip.bind(this, data, metaData),
        };
        if (mode === "line") {
            tooltipOptions.mode = "index";
            tooltipOptions.intersect = false;
            tooltipOptions.position = "average";
        }
        if (mode === "bar") {
            tooltipOptions.xAlign = "center";
            tooltipOptions.yAlign = "bottom";
        }
        if (mode === "pie") {
            tooltipOptions.xAlign = "center";
            tooltipOptions.yAlign = "center";
        }
        return tooltipOptions;
    }

    /**
     * If a group has been clicked on, display a view of its records.
     * @param {MouseEvent} ev
     */
    onGraphClicked(ev) {
        const [activeElement] = this.chart.getElementsAtEventForMode(
            ev,
            "nearest",
            { intersect: true },
            false
        );
        if (!activeElement) {
            return;
        }
        const { datasetIndex, index } = activeElement;
        const { domains } = this.chart.data.datasets[datasetIndex];
        if (domains) {
            this.onGraphClickedFinal(domains[index]);
        }
    }

    /**
     * Overrides the default legend 'onClick' behaviour. This is done to
     * remove all existing tooltips right before updating the chart.
     * @param {Event} ev
     * @param {Object} legendItem
     */
    onLegendClick(ev, legendItem) {
        this.removeTooltips();
        // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138
        const index = legendItem.datasetIndex;
        const meta = this.chart.getDatasetMeta(index);
        meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;
        this.chart.update();
    }

    /**
     * If the text of a legend item has been shortened and the user mouse
     * hovers that item (actually the event type is mousemove), a tooltip
     * with the item full text is displayed.
     * @param {Event} ev
     * @param {Object} legendItem
     */
    onLegendHover(ev, legendItem) {
        ev = ev.native;
        this.canvasRef.el.style.cursor = "pointer";
        /**
         * The string legendItem.text is an initial segment of legendItem.fullText.
         * If the two coincide, no need to generate a tooltip. If a tooltip
         * for the legend already exists, it is already good and does not
         * need to be recreated.
         */
        const { fullText, text } = legendItem;
        if (this.legendTooltip || text === fullText) {
            return;
        }
        const viewContentTop = this.canvasRef.el.getBoundingClientRect().top;
        const legendTooltip = Object.assign(document.createElement("div"), {
            className: "o_tooltip_legend popover p-3 pe-none position-absolute",
            innerText: fullText,
        });
        legendTooltip.style.top = `${ev.clientY - viewContentTop}px`;
        legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);
        this.containerRef.el.appendChild(legendTooltip);
        this.fixTooltipLeftPosition(legendTooltip, ev.clientX);
        this.legendTooltip = legendTooltip;
    }

    /**
     * If there's a legend tooltip and the user mouse out of the
     * corresponding legend item, the tooltip is removed.
     */
    onLegendLeave() {
        this.canvasRef.el.style.cursor = "";
        this.removeLegendTooltip();
    }

    /**
     * Prepares options for the chart according to the current mode
     * (= chart type). This function returns the parameter options used to
     * instantiate the chart.
     */
    prepareOptions() {
        const { disableLinking, mode } = this.model.metaData;
        const options = {
            maintainAspectRatio: false,
            scales: this.getScaleOptions(),
            plugins: {
                legend: this.getLegendOptions(),
                tooltip: this.getTooltipOptions(),
            },
            elements: this.getElementOptions(),
            onResize: () => {
                this.resizeChart(options);
            },
            animation: this.getAnimationOptions(),
        };
        if (!disableLinking && mode !== "line") {
            options.onClick = this.onGraphClicked.bind(this);
        }
        if (mode === "line") {
            options.interaction = {
                mode: "index",
                intersect: false,
            };
        }
        if (mode === "pie") {
            options.radius = "90%";
        }
        return options;
    }

    /**
     * Adapt Pie chart layout on mobile
     * @param {Object} context
     */
    resizeChart(context) {
        const { mode } = this.model.metaData;
        if (mode === "pie") {
            if (this.env.isSmall) {
                context.plugins.legend.position = "bottom";
                context.plugins.legend.align = "center";
            } else {
                context.plugins.legend.position = "right";
                context.plugins.legend.align = "start";
            }
        }
    }

    /**
     * Removes the legend tooltip (if any).
     */
    removeLegendTooltip() {
        if (this.legendTooltip) {
            this.legendTooltip.remove();
            this.legendTooltip = null;
        }
    }

    /**
     * Removes all existing tooltips (if any).
     */
    removeTooltips() {
        if (this.tooltip) {
            this.tooltip.remove();
            this.tooltip = null;
        }
        this.removeLegendTooltip();
    }

    /**
     * Instantiates a Chart (Chart.js lib) to render the graph according to
     * the current config.
     */
    renderChart() {
        if (this.chart) {
            this.chart.destroy();
        }
        if (this.canvasRef.el) {
            const config = this.getChartConfig();
            this.chart = new Chart(this.canvasRef.el, config);
        }
    }

    /**
     * Execute the action to open the view on the current model.
     *
     * @param {Array} domain
     * @param {Array} views
     * @param {Object} context
     */
    openView(domain, views, context) {
        this.actionService.doAction(
            {
                context,
                domain,
                name: this.model.metaData.title,
                res_model: this.model.metaData.resModel,
                target: "current",
                type: "ir.actions.act_window",
                views,
            },
            {
                viewType: "list",
            }
        );
    }
    /**
     * @param {string} domain the domain of the clicked area
     */
    onGraphClickedFinal(domain) {
        const { context } = this.model.metaData;

        Object.keys(context).forEach((x) => {
            if (x === "group_by" || x.startsWith("search_default_")) {
                delete context[x];
            }
        });

        const views = {};
        for (const [viewId, viewType] of this.env.config.views || []) {
            views[viewType] = viewId;
        }
        function getView(viewType) {
            return [views[viewType] || false, viewType];
        }
        const actionViews = [getView("list"), getView("form")];
        this.openView(domain, actionViews, context);
    }

    /**
     * @param {Object} param0
     * @param {string} param0.measure
     */
    onMeasureSelected({ measure }) {
        this.model.updateMetaData({ measure });
    }

    /**
     * @param {"bar"|"line"|"pie"} mode
     */
    onModeSelected(mode) {
        if (this.model.metaData.mode != mode) {
            this.model.updateMetaData({ mode });
        }
    }

    /**
     * @param {"ASC"|"DESC"} order
     */
    toggleOrder(order) {
        const { order: currentOrder } = this.model.metaData;
        const nextOrder = currentOrder === order ? null : order;
        this.model.updateMetaData({ order: nextOrder });
    }

    toggleStacked() {
        const { stacked } = this.model.metaData;
        this.model.updateMetaData({ stacked: !stacked });
    }

    toggleCumulated() {
        const { cumulated } = this.model.metaData;
        this.model.updateMetaData({ cumulated: !cumulated });
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web/static/src/views/graph/graph_search_model.js  *
*  Lines: 25                                                    *
****************************************************************/
odoo.define('@web/views/graph/graph_search_model', ['@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
const { SearchModel } = require("@web/search/search_model");

const GraphSearchModel = __exports.GraphSearchModel = class GraphSearchModel extends SearchModel {
    _getIrFilterDescription() {
        this.preparingIrFilterDescription = true;
        const result = super._getIrFilterDescription(...arguments);
        this.preparingIrFilterDescription = false;
        return result;
    }

    _getSearchItemGroupBys(activeItem) {
        const { searchItemId } = activeItem;
        const { context, type } = this.searchItems[searchItemId];
        if (!this.preparingIrFilterDescription && type === "favorite" && context.graph_groupbys) {
            return context.graph_groupbys;
        }
        return super._getSearchItemGroupBys(...arguments);
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web/static/src/views/graph/graph_view.js  *
*  Lines: 62                                            *
********************************************************/
odoo.define('@web/views/graph/graph_view', ['@web/core/l10n/translation', '@web/core/registry', '@web/views/graph/graph_arch_parser', '@web/views/graph/graph_model', '@web/views/graph/graph_controller', '@web/views/graph/graph_renderer', '@web/views/graph/graph_search_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { GraphArchParser } = require("@web/views/graph/graph_arch_parser");
const { GraphModel } = require("@web/views/graph/graph_model");
const { GraphController } = require("@web/views/graph/graph_controller");
const { GraphRenderer } = require("@web/views/graph/graph_renderer");
const { GraphSearchModel } = require("@web/views/graph/graph_search_model");

const viewRegistry = registry.category("views");

const graphView = __exports.graphView = {
    type: "graph",
    Controller: GraphController,
    Renderer: GraphRenderer,
    Model: GraphModel,
    ArchParser: GraphArchParser,
    SearchModel: GraphSearchModel,
    searchMenuTypes: ["filter", "groupBy", "comparison", "favorite"],
    buttonTemplate: "web.GraphView.Buttons",

    props: (genericProps, view) => {
        let modelParams;
        if (genericProps.state) {
            modelParams = genericProps.state.metaData;
        } else {
            const { arch, fields, resModel } = genericProps;
            const parser = new view.ArchParser();
            const archInfo = parser.parse(arch, fields);
            modelParams = {
                disableLinking: Boolean(archInfo.disableLinking),
                fieldAttrs: archInfo.fieldAttrs,
                fields: fields,
                groupBy: archInfo.groupBy,
                measure: archInfo.measure || "__count",
                viewMeasures: archInfo.measures,
                mode: archInfo.mode || "bar",
                order: archInfo.order || null,
                resModel: resModel,
                stacked: "stacked" in archInfo ? archInfo.stacked : true,
                cumulated: archInfo.cumulated || false,
                cumulatedStart: archInfo.cumulatedStart || false,
                title: archInfo.title || _t("Untitled"),
            };
        }

        return {
            ...genericProps,
            modelParams,
            Model: view.Model,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

viewRegistry.add("graph", graphView);

return __exports;
});
;

/***************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_arch_parser.js  *
*  Lines: 79                                                   *
***************************************************************/
odoo.define('@web/views/pivot/pivot_arch_parser', ['@web/core/utils/strings', '@web/core/utils/xml'], function (require) {
'use strict';
let __exports = {};
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");

const PivotArchParser = __exports.PivotArchParser = class PivotArchParser {
    parse(arch) {
        const archInfo = {
            activeMeasures: [], // store the defined active measures
            colGroupBys: [], // store the defined group_by used on cols
            defaultOrder: null,
            fieldAttrs: {},
            rowGroupBys: [], // store the defined group_by used on rows
            widgets: {}, // wigdets defined in the arch
        };

        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "pivot": {
                    if (node.hasAttribute("disable_linking")) {
                        archInfo.disableLinking = exprToBoolean(
                            node.getAttribute("disable_linking")
                        );
                    }
                    if (node.hasAttribute("default_order")) {
                        archInfo.defaultOrder = node.getAttribute("default_order");
                    }
                    if (node.hasAttribute("string")) {
                        archInfo.title = node.getAttribute("string");
                    }
                    if (node.hasAttribute("display_quantity")) {
                        archInfo.displayQuantity = exprToBoolean(
                            node.getAttribute("display_quantity")
                        );
                    }
                    break;
                }
                case "field": {
                    let fieldName = node.getAttribute("name"); // exists (rng validation)

                    archInfo.fieldAttrs[fieldName] = {};
                    if (node.hasAttribute("string")) {
                        archInfo.fieldAttrs[fieldName].string = node.getAttribute("string");
                    }
                    if (
                        node.getAttribute("invisible") === "True" ||
                        node.getAttribute("invisible") === "1"
                    ) {
                        archInfo.fieldAttrs[fieldName].isInvisible = true;
                        break;
                    }

                    if (node.hasAttribute("interval")) {
                        fieldName += ":" + node.getAttribute("interval");
                    }
                    if (node.hasAttribute("widget")) {
                        archInfo.widgets[fieldName] = node.getAttribute("widget");
                    }
                    if (node.getAttribute("type") === "measure" || node.hasAttribute("operator")) {
                        archInfo.activeMeasures.push(fieldName);
                    }
                    if (node.getAttribute("type") === "col") {
                        archInfo.colGroupBys.push(fieldName);
                    }
                    if (node.getAttribute("type") === "row") {
                        archInfo.rowGroupBys.push(fieldName);
                    }
                    break;
                }
            }
        });

        return archInfo;
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_controller.js  *
*  Lines: 51                                                  *
**************************************************************/
odoo.define('@web/views/pivot/pivot_controller', ['@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, useRef } = require("@odoo/owl");

const PivotController = __exports.PivotController = class PivotController extends Component {
    static template = "web.PivotView";
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);

        useSetupAction({
            rootRef: useRef("root"),
            getLocalState: () => {
                const { data, metaData } = this.model;
                return { data, metaData };
            },
            getContext: () => this.getContext(),
        });
        this.searchBarToggler = useSearchBarToggler();
    }
    /**
     * @returns {Object}
     */
    getContext() {
        return {
            pivot_measures: this.model.metaData.activeMeasures,
            pivot_column_groupby: this.model.metaData.fullColGroupBys,
            pivot_row_groupby: this.model.metaData.fullRowGroupBys,
        };
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_header.js  *
*  Lines: 157                                             *
**********************************************************/
odoo.define('@web/views/pivot/pivot_header', ['@odoo/owl', '@web/core/dropdown/checkbox_item', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_hooks', '@web/core/l10n/localization', '@web/core/utils/arrays', '@web/core/utils/hooks', '@web/search/custom_group_by_item/custom_group_by_item', '@web/search/properties_group_by_item/properties_group_by_item', '@web/search/utils/dates', '@web/search/utils/misc'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { CheckboxItem } = require("@web/core/dropdown/checkbox_item");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { useDropdownState } = require("@web/core/dropdown/dropdown_hooks");
const { localization } = require("@web/core/l10n/localization");
const { sortBy } = require("@web/core/utils/arrays");
const { useBus } = require("@web/core/utils/hooks");
const { CustomGroupByItem } = require("@web/search/custom_group_by_item/custom_group_by_item");
const { PropertiesGroupByItem } = require("@web/search/properties_group_by_item/properties_group_by_item");
const { getIntervalOptions } = require("@web/search/utils/dates");
const { FACET_ICONS, GROUPABLE_TYPES } = require("@web/search/utils/misc");

const PivotHeader = __exports.PivotHeader = class PivotHeader extends Component {
    static template = "web.PivotHeader";
    static components = {
        CustomGroupByItem,
        Dropdown,
        CheckboxItem,
        PropertiesGroupByItem,
    };
    static defaultProps = {
        isInHead: false,
        isXAxis: false,
        showCaretDown: false,
    };
    static props = {
        cell: Object,
        isInHead: { type: Boolean, optional: true },
        isXAxis: { type: Boolean, optional: true },
        customGroupBys: Object,
        onAddCustomGroupBy: Function,
        onItemSelected: Function,
        onClick: Function,
        slots: { optional: true },
    };

    setup() {
        this.icon = FACET_ICONS.groupBy;
        const fields = [];
        for (const [fieldName, field] of Object.entries(this.env.searchModel.searchViewFields)) {
            if (this.validateField(fieldName, field)) {
                fields.push(Object.assign({ name: fieldName }, field));
            }
        }
        this.fields = sortBy(fields, "string");
        this.l10n = localization;
        this.dropdownState = useDropdownState();

        useBus(this.env.searchModel, "update", this.render);
    }

    /**
     * @returns {boolean}
     */
    get hideCustomGroupBy() {
        return this.env.searchModel.hideCustomGroupBy || false;
    }

    /**
     * @returns {Object[]}
     */
    get items() {
        let items = this.env.searchModel.getSearchItems(
            (searchItem) =>
                ["groupBy", "dateGroupBy"].includes(searchItem.type) && !searchItem.custom
        );
        if (items.length === 0) {
            items = this.fields;
        }

        // Add custom groupbys
        let groupNumber = 1 + Math.max(0, ...items.map(({ groupNumber: n }) => n));
        for (const [fieldName, customGroupBy] of this.props.customGroupBys.entries()) {
            items.push({ ...customGroupBy, name: fieldName, groupNumber: groupNumber++ });
        }

        return items.map((item) => ({
            ...item,
            id: item.id || item.name,
            fieldName: item.fieldName || item.name,
            description: item.description || item.string,
            isActive: false,
            options:
                item.options || ["date", "datetime"].includes(item.type)
                    ? getIntervalOptions()
                    : undefined,
        }));
    }

    get cell() {
        return this.props.cell;
    }

    /**
     * Retrieve the padding of a left header.
     * @returns {Number} Padding
     */
    get padding() {
        return 5 + this.cell.indent * 30;
    }

    /**
     * @param {string} fieldName
     * @param {Object} field
     * @returns {boolean}
     */
    validateField(fieldName, field) {
        const { groupable, type } = field;
        return (
            groupable &&
            fieldName !== "id" &&
            GROUPABLE_TYPES.includes(type)
        );
    }

    /**
     * @override
     * @param {Object} param0
     * @param {number} param0.itemId
     * @param {number} [param0.optionId]
     */
    onGroupBySelected({ itemId, optionId }) {
        // Here, we purposely do not call super.onGroupBySelected as we don't want
        // to change the group-by on the model, only inside the pivot
        const item = this.items.find(({ id }) => id === itemId);
        this.props.onItemSelected({
            itemId,
            optionId,
            fieldName: item.fieldName,
            interval: optionId,
            groupId: this.cell.groupId,
        });
    }

    /**
     * @param {string} fieldName
     */
    onAddCustomGroup(fieldName) {
        this.props.onAddCustomGroupBy(fieldName);
    }

    /**
     * @param {Event} event
     */
    onClick(event) {
        if (this.cell.isLeaf && !this.cell.isFolded) {
            this.dropdownState.open();
        }
        this.props.onClick();
    }
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_model.js  *
*  Lines: 1724                                           *
*********************************************************/
odoo.define('@web/views/pivot/pivot_model', ['@web/core/l10n/translation', '@web/core/domain', '@web/core/utils/arrays', '@web/core/utils/concurrency', '@web/search/utils/dates', '@web/model/model', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { Domain } = require("@web/core/domain");
const { cartesian, sections, sortBy, symmetricalDifference } = require("@web/core/utils/arrays");
const { KeepLast, Race } = require("@web/core/utils/concurrency");
const { DEFAULT_INTERVAL } = require("@web/search/utils/dates");
const { addPropertyFieldDefs, Model } = require("@web/model/model");
const { computeReportMeasures, processMeasure } = require("@web/views/utils");

/**
 * @param {number} value
 * @param {number} comparisonValue
 * @returns {number}
 */
function computeVariation(value, comparisonValue) {
    if (isNaN(value) || isNaN(comparisonValue)) {
        return NaN;
    }
    if (comparisonValue === 0) {
        if (value === 0) {
            return 0;
        } else if (value > 0) {
            return 1;
        } else {
            return -1;
        }
    }
    return (value - comparisonValue) / Math.abs(comparisonValue);
}

/**
 * Pivot Model
 *
 * The pivot model keeps an in-memory representation of the pivot table that is
 * displayed on the screen.  The exact layout of this representation is not so
 * simple, because a pivot table is at its core a 2-dimensional object, but
 * with a 'list' component: some rows/cols can be expanded so we zoom into the
 * structure.
 *
 * However, we need to be able to manipulate the data in a somewhat efficient
 * way, and to transform it into a list of lines to be displayed by the renderer.
 *
 * Basicaly the pivot table presents aggregated values for various groups of records
 * in one domain. If a comparison is asked for, two domains are considered.
 *
 * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):
 * ___________________________________________________________________________________________________________________________________________
 * |                    |   Total                                                                                                             |
 * |                    |_____________________________________________________________________________________________________________________|
 * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   Sales total                         |  Sales total                         |  Sales total                         |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |
 * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |
 * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |
 * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |
 * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 *
 *
 * META DATA:
 *
 * In the above pivot table, the records have been grouped using the fields
 *
 *      continent_id, city_id
 *
 * for rows and
 *
 *      sale_team_id
 *
 * for columns.
 *
 * The measure is the field 'sales_total'.
 *
 * Two domains are considered: 'May 2020' and 'June 2020'.
 *
 * In the model,
 *
 *      - rowGroupBys is the list [continent_id, city_id]
 *      - colGroupBys is the list [sale_team_id]
 *      - measures is the list [sales_total]
 *      - domains is the list [d1, d2] with d1 and d2 domain expressions
 *          for say sale_date in May 2020 and June 2020, for instance
 *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]
 *      - origins is the list ['May 2020', 'June 2020']
 *
 * DATA:
 *
 * Recall that a group is constituted by records (in a given domain)
 * that have the same (raw) values for a list of fields.
 * Thus the group itself is identified by this list and the domain.
 * In comparison mode, the same group (forgetting the domain part or 'originIndex')
 * can be eventually found in the two domains.
 * This defines the way in which the groups are identified or not.
 *
 * In the above table, (forgetting the domain) the following groups are found:
 *
 *      the 'row groups'
 *      - Total
 *      - Europe
 *      - America
 *      - Europe, Brussels
 *      - Europe, Paris
 *      - America, Washington
 *
 *      the 'col groups'
 *
 *      - Total
 *      - Sale Team 1
 *      - Sale Team 2
 *
 *      and all non trivial combinations of row groups and col groups
 *
 *      - Europe, Sale Team 1
 *      - Europe, Brussels, Sale Team 2
 *      - America, Washington, Sale Team 1
 *      - ...
 *
 * The list of fields is created from the concatenation of two lists of fields, the first in
 *
 * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys
 * (called rowGroupBys) used to create row groups
 *
 * In the example: [], [continent_id], [continent_id, city_id].
 *
 * and the second in
 * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys
 * (called colGroupBys) used to create col groups.
 *
 * In the example: [], [sale_team_id].
 *
 * Thus there are (n+1)*(m+1) lists of fields possible.
 *
 * In the example: 6 lists possible, namely [],
 *                                          [continent_id], [sale_team_id],
 *                                          [continent_id, sale_team_id], [continent_id, city_id],
 *                                          [continent_id, city_id, sale_team_id]
 *
 * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]
 *
 * For each list of fields possible and each domain considered, one read_group is done
 * and gives results of the form (an exception for list [])
 *
 * g = {
 *  f1: v1, ..., fi: vi,
 *  g1: w1, ..., gj: wj,
 *  m1: x1, ..., mk: xk,
 *  __count: c,
 *  __domain: d
 * }
 *
 * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and
 * m1,...,mk are the fields selected as measures.
 *
 * For example, g = {
 *      continent_id: [1, 'Europe']
 *      sale_team_id: [1, 'Sale Team 1']
 *      sales_count: 25,
 *      __count: 4
 *      __domain: [
 *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],
 *                  ['continent_id', '=', 1],
 *                  ['sale_team_id', '=', 1]
 *                ]
 * }
 *
 * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain
 * or the corresponding 'originIndex'.
 *
 * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]
 * (not forgetting the list [v1,...vi] comes from left).
 * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].
 *
 * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]
 * and [[], [w1,...,wj]].
 *
 * Here is a description of the data structure manipulated by the pivot model.
 *
 * Five objects contain all the data from the read_groups
 *
 *      - rowGroupTree: contains information on row headers
 *             the nodes correspond to the groups of the form [[v1,...,vi], []]
 *             The root is [[], []].
 *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],
 *             this means that a direct child is obtained by grouping records using the single field fi+1
 *
 *             The structure at each level is of the form
 *
 *             {
 *                  root: {
 *                      values: [v1,...,vl],
 *                      labels: [la1,...,lal]
 *                  },
 *                  directSubTrees: {
 *                      v => {
 *                              root: {
 *                                  values: [v1,...,vl,v]
 *                                  labels: [label1,...,labell,label]
 *                              },
 *                              directSubTrees: {...}
 *                          },
 *                      v' => {...},
 *                      ...
 *                  }
 *             }
 *
 *             (directSubTrees is a Map instance)
 *
 *             In the example, the rowGroupTree is:
 *
 *             {
 *                  root: {
 *                      values: [],
 *                      labels: []
 *                  },
 *                  directSubTrees: {
 *                      1 => {
 *                              root: {
 *                                  values: [1],
 *                                  labels: ['Europe'],
 *                              },
 *                              directSubTrees: {
 *                                  1 => {
 *                                          root: {
 *                                              values: [1, 1],
 *                                              labels: ['Europe', 'Brussels'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                                  2 => {
 *                                          root: {
 *                                              values: [1, 2],
 *                                              labels: ['Europe', 'Paris'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                          },
 *                      2 => {
 *                              root: {
 *                                  values: [2],
 *                                  labels: ['America'],
 *                              },
 *                              directSubTrees: {
 *                                  3 => {
 *                                          root: {
 *                                              values: [2, 3],
 *                                              labels: ['America', 'Washington'],
 *                                          }
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                      },
 *                  },
 *             }
 *
 *      - colGroupTree: contains information on col headers
 *              The same as above with right instead of left
 *
 *      - measurements: contains information on measure values for all the groups
 *
 *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])
 *              and values are arrays of length equal to number of origins containing objects of the form
 *                  {m1: x1,...,mk: xk}
 *              The structure looks like
 *
 *              {
 *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]
 *                  ....
 *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],
 *                  ....
 *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],
 *              }
 *              Thus the structure contains all information for all groups and all origins on measure values.
 *
 *
 *              this.measurments["[[], []]"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the
 *              first domain (origin).
 *
 *              In the example:
 *                  {
 *                      "[[], []]": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)
 *                      ...
 *                      "[[1, 2], [2]]": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)
 *                      ...
 *                  }
 *
 *      - counts: contains information on the number of records in each groups
 *              The structure is similar to the above but the arrays contains numbers (counts)
 *      - groupDomains:
 *              The structure is similar to the above but the arrays contains domains
 *
 *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.
 *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the getTable function.
 */

/**
 * @typedef Meta
 * @property {string[]} activeMeasures
 * @property {string[]} colGroupBys
 * @property {boolean} disableLinking
 * @property {Object} fields
 * @property {Object} measures
 * @property {string} resModel
 * @property {string[]} rowGroupBys
 * @property {string} title
 * @property {boolean} useSampleModel
 * @property {Object} widgets
 * @property {Map} customGroupBys
 * @property {string[]} expandedRowGroupBys
 * @property {string[]} expandedColGroupBys
 * @property {Object} sortedColumn
 * @property {Array[]} domains
 * @property {string[]} origins
 */

/**
 * @typedef Data
 * @property {Object} colGroupTree
 * @property {Object} rowGroupTree
 * @property {Object} groupDomains
 * @property {Object} measurements
 * @property {Object} counts
 * @property {Object} numbering
 */

/**
 * @typedef {import("@web/search/search_model").SearchParams} SearchParams
 */

/**
 * @typedef Config
 * @property {MetaData} metaData
 * @property {Data} data
 */

const PivotModel = __exports.PivotModel = class PivotModel extends Model {
    /**
     * @override
     * @param {Object} params.metaData
     * @param {string[]} params.metaData.activeMeasures
     * @param {string[]} params.metaData.colGroupBys
     * @param {Object} params.metaData.fields
     * @param {Object[]} params.metaData.measures
     * @param {string} params.metaData.resModel
     * @param {string[]} params.metaData.rowGroupBys
     * @param {string|null} params.metaData.defaultOrder
     * @param {boolean} params.metaData.disableLinking
     * @param {boolean} params.metaData.useSampleModel
     * @param {Map} [params.metaData.customGroupBys={}]
     * @param {string[]} [params.metaData.expandedColGroupBys=[]]
     * @param {string[]} [params.metaData.expandedRowGroupBys=[]]
     * @param {Object|null} [params.metaData.sortedColumn=null]
     * @param {Object} [params.data] previously exported data
     */
    setup(params) {
        // concurrency management
        this.keepLast = new KeepLast();
        this.race = new Race();
        const _loadData = this._loadData.bind(this);
        this._loadData = (...args) => {
            return this.race.add(_loadData(...args));
        };

        let sortedColumn = params.metaData.sortedColumn || null;
        if (!sortedColumn && params.metaData.defaultOrder) {
            const defaultOrder = params.metaData.defaultOrder.split(" ");
            sortedColumn = {
                groupId: [[], []],
                measure: defaultOrder[0],
                order: defaultOrder[1] ? defaultOrder[1] : "asc",
            };
        }

        this.searchParams = {
            context: {},
            domain: [],
            domains: [],
            groupBy: [],
        };
        this.data = params.data || {
            colGroupTree: null,
            rowGroupTree: null,
            groupDomains: {},
            measurements: {},
            counts: {},
            numbering: {},
        };
        const metaData = Object.assign({}, params.metaData, {
            customGroupBys: params.metaData.customGroupBys || new Map(),
            expandedRowGroupBys: params.metaData.expandedRowGroupBys || [],
            expandedColGroupBys: params.metaData.expandedColGroupBys || [],
            sortedColumn,
        });
        this.metaData = this._buildMetaData(metaData);

        this.reload = false; // used to discriminate between the first load and subsequent reloads
        this.nextActiveMeasures = null; // allows to toggle several measures consecutively
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.
     *
     * @param {Object} params
     * @param {Array[]} params.groupId
     * @param {string} params.fieldName
     * @param {'row'|'col'} params.type
     * @param {boolean} [params.custom=false]
     * @param {string} [params.interval]
     */
    async addGroupBy(params) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const { groupId, fieldName, type, custom } = params;
        let { interval } = params;
        const metaData = this._buildMetaData();
        if (custom && !metaData.customGroupBys.has(fieldName)) {
            const field = metaData.fields[fieldName];
            if (!interval && ["date", "datetime"].includes(field.type)) {
                interval = DEFAULT_INTERVAL;
            }
            metaData.customGroupBys.set(fieldName, {
                ...field,
                id: fieldName,
            });
        }

        let groupBy = fieldName;
        if (interval) {
            groupBy = `${groupBy}:${interval}`;
        }
        if (type === "row") {
            metaData.expandedRowGroupBys.push(groupBy);
        } else {
            metaData.expandedColGroupBys.push(groupBy);
        }
        const config = { metaData, data: this.data };
        await this._expandGroup(groupId, type, config);
        this.metaData = metaData;
        this.notify();
    }
    /**
     * Close the group with id given by groupId. A type must be specified
     * in case groupId is [[], []] (the id of the group 'Total') because this
     * group is present in both colGroupTree and rowGroupTree.
     *
     * @param {Array[]} groupId
     * @param {'row'|'col'} type
     */
    closeGroup(groupId, type) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloading the table
        }

        let groupBys;
        let expandedGroupBys;
        let keyPart;
        let group;
        let tree;
        if (type === "row") {
            groupBys = this.metaData.rowGroupBys;
            expandedGroupBys = this.metaData.expandedRowGroupBys;
            tree = this.data.rowGroupTree;
            group = this._findGroup(this.data.rowGroupTree, groupId[0]);
            keyPart = 0;
        } else {
            groupBys = this.metaData.colGroupBys;
            expandedGroupBys = this.metaData.expandedColGroupBys;
            tree = this.data.colGroupTree;
            group = this._findGroup(this.data.colGroupTree, groupId[1]);
            keyPart = 1;
        }

        const groupIdPart = groupId[keyPart];
        const range = groupIdPart.map((_, index) => index);
        function keep(key) {
            const idPart = JSON.parse(key)[keyPart];
            return (
                range.some((index) => groupIdPart[index] !== idPart[index]) ||
                idPart.length === groupIdPart.length
            );
        }
        function omitKeys(object) {
            const newObject = {};
            for (const key in object) {
                if (keep(key)) {
                    newObject[key] = object[key];
                }
            }
            return newObject;
        }
        this.data.measurements = omitKeys(this.data.measurements);
        this.data.counts = omitKeys(this.data.counts);
        this.data.groupDomains = omitKeys(this.data.groupDomains);

        group.directSubTrees.clear();
        delete group.sortedKeys;
        var newGroupBysLength = this._getTreeHeight(tree) - 1;
        if (newGroupBysLength <= groupBys.length) {
            expandedGroupBys.splice(0);
            groupBys.splice(newGroupBysLength);
        } else {
            expandedGroupBys.splice(newGroupBysLength - groupBys.length);
        }
        this.notify();
    }
    /**
     * Reload the view with the current rowGroupBys and colGroupBys
     * This is the easiest way to expand all the groups that are not expanded
     */
    async expandAll() {
        const config = { metaData: this.metaData, data: this.data };
        await this._loadData(config, false);
        this.notify();
    }
    /**
     * Expand a group by using groupBy to split it and trigger a re-rendering.
     *
     * @param {Object} group
     * @param {'row'|'col'} type
     */
    async expandGroup(groupId, type) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const config = { metaData: this.metaData, data: this.data };
        await this._expandGroup(groupId, type, config);
        this.notify();
    }
    /**
     * Export model data in a form suitable for an easy encoding of the pivot
     * table in excell.
     *
     * @returns {Object}
     */
    exportData() {
        const measureCount = this.metaData.activeMeasures.length;
        const originCount = this.metaData.origins.length;

        const table = this.getTable();

        // process headers
        const headers = table.headers;
        let colGroupHeaderRows;
        let measureRow = [];
        let originRow = [];

        function processHeader(header) {
            const inTotalColumn = header.groupId[1].length === 0;
            return {
                title: header.title,
                width: header.width,
                height: header.height,
                is_bold: !!header.measure && inTotalColumn,
            };
        }

        if (originCount > 1) {
            colGroupHeaderRows = headers.slice(0, headers.length - 2);
            measureRow = headers[headers.length - 2].map(processHeader);
            originRow = headers[headers.length - 1].map(processHeader);
        } else {
            colGroupHeaderRows = headers.slice(0, headers.length - 1);
            measureRow = headers[headers.length - 1].map(processHeader);
        }

        // remove the empty headers on left side
        colGroupHeaderRows[0].splice(0, 1);

        colGroupHeaderRows = colGroupHeaderRows.map((headerRow) => {
            return headerRow.map(processHeader);
        });

        // process rows
        const tableRows = table.rows.map((row) => {
            return {
                title: row.title,
                indent: row.indent,
                values: row.subGroupMeasurements.map((measurement) => {
                    let value = measurement.value;
                    if (value === undefined) {
                        value = "";
                    } else if (measurement.originIndexes.length > 1) {
                        // in that case the value is a variation and a
                        // number between 0 and 1
                        value = value * 100;
                    }
                    return {
                        is_bold: measurement.isBold,
                        value: value,
                    };
                }),
            };
        });

        return {
            model: this.metaData.resModel,
            title: this.metaData.title,
            col_group_headers: colGroupHeaderRows,
            measure_headers: measureRow,
            origin_headers: originRow,
            rows: tableRows,
            measure_count: measureCount,
            origin_count: originCount,
        };
    }
    /**
     * Swap the pivot columns and the rows. The flip operation is synchronous.
     * However, we must wait for a potential pending reload to complete before
     * flipping the axes. This method is thus async.
     */
    async flip() {
        await this.race.getCurrentProm();

        // swap the data: the main column and the main row
        let temp = this.data.rowGroupTree;
        this.data.rowGroupTree = this.data.colGroupTree;
        this.data.colGroupTree = temp;

        // we need to update the record metaData: (expanded) row and col groupBys
        temp = this.metaData.rowGroupBys;
        this.metaData.rowGroupBys = this.metaData.colGroupBys;
        this.metaData.colGroupBys = temp;
        temp = this.metaData.expandedColGroupBys;
        this.metaData.expandedColGroupBys = this.metaData.expandedRowGroupBys;
        this.metaData.expandedRowGroupBys = temp;

        function twistKey(key) {
            return JSON.stringify(JSON.parse(key).reverse());
        }

        function twist(object) {
            const newObject = {};
            Object.keys(object).forEach((key) => {
                const value = object[key];
                newObject[twistKey(key)] = value;
            });
            return newObject;
        }

        this.data.measurements = twist(this.data.measurements);
        this.data.counts = twist(this.data.counts);
        this.data.groupDomains = twist(this.data.groupDomains);

        this.notify();
    }
    /**
     * Returns a domain representation of a group
     *
     * @param {Object} group
     * @param {Array} group.colValues
     * @param {Array} group.rowValues
     * @param {number} group.originIndex
     * @returns {Array[]}
     */
    getGroupDomain(group) {
        const config = { metaData: this.metaData, data: this.data };
        return this._getGroupDomain(group, config);
    }
    /**
     * Returns a description of the pivot table.
     *
     * @returns {Object}
     */
    getTable() {
        const headers = this._getTableHeaders();
        return {
            headers: headers,
            rows: this._getTableRows(this.data.rowGroupTree, headers[headers.length - 1]),
        };
    }
    /**
     * Returns the total number of columns of the pivot table.
     *
     * @returns {integer}
     */
    getTableWidth() {
        var leafCounts = this._getLeafCounts(this.data.colGroupTree);
        return leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] + 2;
    }
    /**
     * @returns {boolean} true iff there's no data in the table
     */
    hasData() {
        return this._hasData(this.data);
    }
    /**
     * @override
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        this.searchParams = searchParams;
        const processedMeasures = processMeasure(searchParams.context.pivot_measures);
        const activeMeasures = processedMeasures || this.metaData.activeMeasures;
        const metaData = this._buildMetaData({ activeMeasures });
        if (!this.reload) {
            metaData.rowGroupBys =
                searchParams.context.pivot_row_groupby ||
                (searchParams.groupBy.length ? searchParams.groupBy : metaData.rowGroupBys);
            this.reload = true;
        } else {
            metaData.rowGroupBys = searchParams.groupBy.length
                ? searchParams.groupBy
                : searchParams.context.pivot_row_groupby || metaData.rowGroupBys;
        }
        metaData.colGroupBys =
            searchParams.context.pivot_column_groupby || this.metaData.colGroupBys;

        if (JSON.stringify(metaData.rowGroupBys) !== JSON.stringify(this.metaData.rowGroupBys)) {
            metaData.expandedRowGroupBys = [];
        }
        if (JSON.stringify(metaData.colGroupBys) !== JSON.stringify(this.metaData.colGroupBys)) {
            metaData.expandedColGroupBys = [];
        }

        const allActivesMeasures = new Set(this.metaData.activeMeasures);
        if (processedMeasures) {
            processedMeasures.forEach((e) => allActivesMeasures.add(e));
        }

        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [
            ...allActivesMeasures,
        ]);
        const config = { metaData, data: this.data };
        await addPropertyFieldDefs(
            this.orm,
            metaData.resModel,
            searchParams.context,
            metaData.fields,
            new Set([...metaData.rowGroupBys, ...metaData.colGroupBys])
        );
        return this._loadData(config);
    }
    /**
     * Sort the rows, depending on the values of a given column.  This is an
     * in-memory sort.
     *
     * @param {Object} sortedColumn
     * @param {number[]} sortedColumn.groupId
     */
    sortRows(sortedColumn) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const config = { metaData: this.metaData, data: this.data };
        this._sortRows(sortedColumn, config);

        this.notify();
    }
    /**
     * Toggle the active state for a given measure, then reload the data
     * if this turns out to be necessary.
     *
     * @param {string} fieldName
     * @returns {Promise}
     */
    async toggleMeasure(fieldName) {
        const metaData = this._buildMetaData();
        this.nextActiveMeasures = this.nextActiveMeasures || metaData.activeMeasures;
        metaData.activeMeasures = this.nextActiveMeasures;
        const index = metaData.activeMeasures.indexOf(fieldName);
        if (index !== -1) {
            // in this case, we already have all data in memory, no need to
            // actually reload a lesser amount of information (but still, we need
            // to wait in case there is a pending load)
            metaData.activeMeasures.splice(index, 1);
            await Promise.resolve(this.race.getCurrentProm());
            this.metaData = metaData;
        } else {
            metaData.activeMeasures.push(fieldName);
            const config = { metaData, data: this.data };
            await this._loadData(config);
            this.useSampleModel = false;
        }
        this.nextActiveMeasures = null;
        this.notify();
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    /**
     * Add labels/values in the provided groupTree. A new leaf is created in
     * the groupTree with a root object corresponding to the group with given
     * labels/values.
     *
     * @protected
     * @param {Object} groupTree, either this.data.rowGroupTree or this.data.colGroupTree
     * @param {string[]} labels
     * @param {Array} values
     */
    _addGroup(groupTree, labels, values) {
        let tree = groupTree;
        // we assume here that the group with value value.slice(value.length - 2) has already been added.
        values.slice(0, values.length - 1).forEach(function (value) {
            tree = tree.directSubTrees.get(value);
        });
        const value = values[values.length - 1];
        if (tree.directSubTrees.has(value)) {
            return;
        }
        tree.directSubTrees.set(value, {
            root: {
                labels: labels,
                values: values,
            },
            directSubTrees: new Map(),
        });
    }
    /**
     * Return a copy of this.metaData, extended with optional params. This is useful
     * for async methods that need to modify this.metaData, but it can't be done in
     * place directly for the model to be concurrency proof (so they work on a
     * copy and commit it at the end).
     *
     * @protected
     * @param {Object} params
     * @returns {Object}
     */
    _buildMetaData(params) {
        const metaData = Object.assign({}, this.metaData, params);
        metaData.activeMeasures = [...metaData.activeMeasures];
        metaData.colGroupBys = [...metaData.colGroupBys];
        metaData.rowGroupBys = [...metaData.rowGroupBys];
        metaData.expandedColGroupBys = [...metaData.expandedColGroupBys];
        metaData.expandedRowGroupBys = [...metaData.expandedRowGroupBys];
        metaData.customGroupBys = new Map([...metaData.customGroupBys]);
        // shallow copy sortedColumn because we never modify groupId in place
        metaData.sortedColumn = metaData.sortedColumn ? { ...metaData.sortedColumn } : null;
        if (this.searchParams.comparison) {
            const domains = this.searchParams.comparison.domains.slice().reverse();
            metaData.domains = domains.map((d) => d.arrayRepr);
            metaData.origins = domains.map((d) => d.description);
        } else {
            metaData.domains = [this.searchParams.domain];
            metaData.origins = [""];
        }
        Object.defineProperty(metaData, "fullColGroupBys", {
            get() {
                return metaData.colGroupBys.concat(metaData.expandedColGroupBys);
            },
        });
        Object.defineProperty(metaData, "fullRowGroupBys", {
            get() {
                return metaData.rowGroupBys.concat(metaData.expandedRowGroupBys);
            },
        });
        return metaData;
    }
    /**
     * Expand a group by using groupBy to split it.
     *
     * @protected
     * @param {Object} group
     * @param {'row'|'col'} type
     * @param {Config} config
     */
    async _expandGroup(groupId, type, config) {
        const { metaData } = config;
        const group = {
            rowValues: groupId[0],
            colValues: groupId[1],
            type: type,
        };
        const groupValues = type === "row" ? groupId[0] : groupId[1];
        const groupBys = type === "row" ? metaData.fullRowGroupBys : metaData.fullColGroupBys;
        if (groupValues.length >= groupBys.length) {
            throw new Error("Cannot expand group");
        }
        const groupBy = groupBys[groupValues.length];
        let leftDivisors;
        let rightDivisors;
        if (group.type === "row") {
            leftDivisors = [[groupBy]];
            rightDivisors = sections(metaData.fullColGroupBys);
        } else {
            leftDivisors = sections(metaData.fullRowGroupBys);
            rightDivisors = [[groupBy]];
        }
        const divisors = cartesian(leftDivisors, rightDivisors);
        delete group.type;
        await this._subdivideGroup(group, divisors, config);
    }
    /**
     * Find a group with given values in the provided groupTree, either
     * this.rowGrouptree or this.data.colGroupTree.
     *
     * @protected
     * @param {Object} groupTree
     * @param {Array} values
     * @returns {Object}
     */
    _findGroup(groupTree, values) {
        let tree = groupTree;
        values.slice(0, values.length).forEach((value) => {
            tree = tree.directSubTrees.get(value);
        });
        return tree;
    }
    /**
     * In case originIndex is an array of length 1, thus a single origin
     * index, returns the given measure for a group determined by the id
     * groupId and the origin index.
     * If originIndexes is an array of length 2, we compute the variation
     * of the measure values for the groups determined by groupId and the
     * different origin indexes.
     *
     * @protected
     * @param {Array[]} groupId
     * @param {string} measure
     * @param {number[]} originIndexes
     * @param {Config} config
     * @returns {number}
     */
    _getCellValue(groupId, measure, originIndexes, config) {
        var key = JSON.stringify(groupId);
        if (!config.data.measurements[key]) {
            return;
        }
        var values = originIndexes.map((originIndex) => {
            return config.data.measurements[key][originIndex][measure];
        });
        if (originIndexes.length > 1) {
            return computeVariation(values[1], values[0]);
        } else {
            return values[0];
        }
    }
    /**
     * @protected
     * @param {string[]} rowGroupBy
     * @param {string[]} colGroupBy
     * @returns {string[]}
     */
    _getGroupBySpecs(rowGroupBy, colGroupBy) {
        const set = rowGroupBy.concat(colGroupBy).reduce((acc, gb) => {
            acc.add(this._normalize(gb));
            return acc;
        }, new Set());
        return [...set];
    }
    /**
     * Returns a domain representation of a group
     *
     * @protected
     * @param {Object} group
     * @param {Array} group.colValues
     * @param {Array} group.rowValues
     * @param {number} group.originIndex
     * @param {Config} config
     * @returns {Array[]}
     */
    _getGroupDomain(group, config) {
        const { data } = config;
        var key = JSON.stringify([group.rowValues, group.colValues]);
        return data.groupDomains[key][group.originIndex];
    }
    /**
     * Returns the group sanitized labels.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} groupBys
     * @param {Config} config
     * @returns {string[]}
     */
    _getGroupLabels(group, groupBys, config) {
        return groupBys.map((gb) => {
            const groupBy = this._normalize(gb);
            return this._sanitizeLabel(group[groupBy], groupBy, config);
        });
    }
    /**
     * Returns a promise that returns the annotated read_group results
     * corresponding to a partition of the given group obtained using the given
     * rowGroupBy and colGroupBy.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} rowGroupBy
     * @param {string[]} colGroupBy
     * @param {Object} params
     */
    async _getGroupSubdivision(group, rowGroupBy, colGroupBy, params) {
        const groupBy = this._getGroupBySpecs(rowGroupBy, colGroupBy);
        const subGroups = await this._getSubGroups(groupBy, params);
        return {
            group,
            subGroups,
            rowGroupBy: rowGroupBy,
            colGroupBy: colGroupBy,
        };
    }

    /**
     * Returns the group sanitized values.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} groupBys
     * @returns {Array}
     */
    _getGroupValues(group, groupBys) {
        return groupBys.map((gb) => {
            const groupBy = this._normalize(gb);
            return this._sanitizeValue(group[groupBy]);
        });
    }
    /**
     * Returns the leaf counts of each group inside the given tree.
     *
     * @protected
     * @param {Object} tree
     * @returns {Object} keys are group ids
     */
    _getLeafCounts(tree) {
        const leafCounts = {};
        let leafCount;
        if (!tree.directSubTrees.size) {
            leafCount = 1;
        } else {
            leafCount = [...tree.directSubTrees.values()].reduce((acc, subTree) => {
                const subLeafCounts = this._getLeafCounts(subTree);
                Object.assign(leafCounts, subLeafCounts);
                return acc + leafCounts[JSON.stringify(subTree.root.values)];
            }, 0);
        }

        leafCounts[JSON.stringify(tree.root.values)] = leafCount;
        return leafCounts;
    }
    /**
     * Returns the group sanitized measure values for the measures in
     * this.metaData.activeMeasures (that migth contain '__count', not really a fieldName).
     *
     * @protected
     * @param {Object} group
     * @param {Config} config
     * @returns {Array}
     */
    _getMeasurements(group, config) {
        const { metaData } = config;
        return metaData.activeMeasures.reduce((measurements, measureName) => {
            var measurement = group[measureName];
            if (measurement instanceof Array) {
                // case field is many2one and used as measure and groupBy simultaneously
                measurement = 1;
            }
            if (
                metaData.measures[measureName].type === "boolean" &&
                measurement instanceof Boolean
            ) {
                measurement = measurement ? 1 : 0;
            }
            if (metaData.origins.length > 1 && !measurement) {
                measurement = 0;
            }
            measurements[measureName] = measurement;
            return measurements;
        }, {});
    }
    /**
     * Returns a description of the measures row of the pivot table
     *
     * @protected
     * @param {Object[]} columns for which measure cells must be generated
     * @returns {Object[]}
     */
    _getMeasuresRow(columns) {
        const sortedColumn = this.metaData.sortedColumn || {};
        const measureRow = [];

        columns.forEach((column) => {
            this.metaData.activeMeasures.forEach((measureName) => {
                const measureCell = {
                    groupId: column.groupId,
                    height: 1,
                    measure: measureName,
                    title: this.metaData.measures[measureName].string,
                    width: 2 * this.metaData.origins.length - 1,
                };
                if (
                    sortedColumn.measure === measureName &&
                    JSON.stringify(sortedColumn.groupId) === JSON.stringify(column.groupId) // FIXME
                ) {
                    measureCell.order = sortedColumn.order;
                }
                measureRow.push(measureCell);
            });
        });

        return measureRow;
    }
    /**
     * Returns the list of measure specs associated with metaData.activeMeasures, i.e.
     * a measure 'fieldName' becomes 'fieldName:aggregator' where
     * aggregator is the value specified on the field 'fieldName' for
     * the key aggregator.
     *
     * @protected
     * @param {Config} config
     * @return {string[]}
     */
    _getMeasureSpecs(config) {
        const { metaData } = config;
        return metaData.activeMeasures.reduce((acc, measure) => {
            if (measure === "__count") {
                acc.push(measure);
                return acc;
            }
            const field = this.metaData.fields[measure];
            if (field.type === "many2one") {
                field.aggregator = "count_distinct";
            }
            if (field.aggregator === undefined) {
                throw new Error(
                    "No aggregate function has been provided for the measure '" + measure + "'"
                );
            }
            acc.push(measure + ":" + field.aggregator);
            return acc;
        }, []);
    }
    /**
     * Make sure that the labels of different many2one values are distinguished
     * by numbering them if necessary.
     *
     * @protected
     * @param {Array} label
     * @param {string} fieldName
     * @param {Config} config
     * @returns {string}
     */
    _getNumberedLabel(label, fieldName, config) {
        const { data } = config;
        const id = label[0];
        const name = label[1];
        data.numbering[fieldName] = data.numbering[fieldName] || {};
        data.numbering[fieldName][name] = data.numbering[fieldName][name] || {};
        const numbers = data.numbering[fieldName][name];
        numbers[id] = numbers[id] || Object.keys(numbers).length + 1;
        return name + (numbers[id] > 1 ? "  (" + numbers[id] + ")" : "");
    }
    /**
     * Returns a description of the origins row of the pivot table
     *
     * @protected
     * @param {Object[]} columns for which origin cells must be generated
     * @returns {Object[]}
     */
    _getOriginsRow(columns) {
        const sortedColumn = this.metaData.sortedColumn || {};
        const originRow = [];

        columns.forEach((column) => {
            const groupId = column.groupId;
            const measure = column.measure;
            const isSorted =
                sortedColumn.measure === measure &&
                JSON.stringify(sortedColumn.groupId) === JSON.stringify(groupId); // FIXME
            const isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];
            const isSortedByVariation = isSorted && sortedColumn.originIndexes[1];

            this.metaData.origins.forEach((origin, originIndex) => {
                const originCell = {
                    groupId: groupId,
                    height: 1,
                    measure: measure,
                    originIndexes: [originIndex],
                    title: origin,
                    width: 1,
                };
                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {
                    originCell.order = sortedColumn.order;
                }
                originRow.push(originCell);

                if (originIndex > 0) {
                    const variationCell = {
                        groupId: groupId,
                        height: 1,
                        measure: measure,
                        originIndexes: [originIndex - 1, originIndex],
                        title: _t("Variation"),
                        width: 1,
                    };
                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {
                        variationCell.order = sortedColumn.order;
                    }
                    originRow.push(variationCell);
                }
            });
        });

        return originRow;
    }
    /**
     * @protected
     * @param {string[]} groupBy
     * @param {Object} params
     * @returns {Promise<Object[]>}
     */
    async _getSubGroups(groupBy, params) {
        const { resModel, groupDomain, measureSpecs, kwargs, mapping } = params;
        const key = JSON.stringify(groupBy);
        if (!mapping[key]) {
            mapping[key] = this.orm.readGroup(resModel, groupDomain, measureSpecs, groupBy, kwargs);
        }
        return mapping[key];
    }
    /**
     * Returns the list of header rows of the pivot table: the col group rows
     * (depending on the col groupbys), the measures row and optionnaly the
     * origins row (if there are more than one origins).
     *
     * @protected
     * @returns {Object[]}
     */
    _getTableHeaders() {
        const colGroupBys = this.metaData.fullColGroupBys;
        const height = colGroupBys.length + 1;
        const measureCount = this.metaData.activeMeasures.length;
        const originCount = this.metaData.origins.length;
        const leafCounts = this._getLeafCounts(this.data.colGroupTree);
        let headers = [];
        const measureColumns = []; // used to generate the measure cells

        // 1) generate col group rows (total row + one row for each col groupby)
        const colGroupRows = new Array(height).fill(0).map(() => []);
        // blank top left cell
        colGroupRows[0].push({
            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]
            title: "",
            width: 1,
        });

        // col groupby cells with group values
        /**
         * Recursive function that generates the header cells corresponding to
         * the groups of a given tree.
         *
         * @param {Object} tree
         */
        function generateTreeHeaders(tree, fields) {
            const group = tree.root;
            const rowIndex = group.values.length;
            const row = colGroupRows[rowIndex];
            const groupId = [[], group.values];
            const isLeaf = !tree.directSubTrees.size;
            const leafCount = leafCounts[JSON.stringify(tree.root.values)];
            const cell = {
                groupId: groupId,
                height: isLeaf ? colGroupBys.length + 1 - rowIndex : 1,
                isLeaf: isLeaf,
                isFolded: isLeaf && colGroupBys.length > group.values.length,
                label:
                    rowIndex === 0
                        ? undefined
                        : fields[colGroupBys[rowIndex - 1].split(":")[0]].string,
                title: group.labels.length ? group.labels[group.labels.length - 1] : _t("Total"),
                width: leafCount * measureCount * (2 * originCount - 1),
            };
            row.push(cell);
            if (isLeaf) {
                measureColumns.push(cell);
            }

            [...tree.directSubTrees.values()].forEach((subTree) => {
                generateTreeHeaders(subTree, fields);
            });
        }

        generateTreeHeaders(this.data.colGroupTree, this.metaData.fields);
        // blank top right cell for 'Total' group (if there is more that one leaf)
        if (leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] > 1) {
            var groupId = [[], []];
            var totalTopRightCell = {
                groupId: groupId,
                height: height,
                title: "",
                width: measureCount * (2 * originCount - 1),
            };
            colGroupRows[0].push(totalTopRightCell);
            measureColumns.push(totalTopRightCell);
        }
        headers = headers.concat(colGroupRows);

        // 2) generate measures row
        var measuresRow = this._getMeasuresRow(measureColumns);
        headers.push(measuresRow);

        // 3) generate origins row if more than one origin
        if (originCount > 1) {
            headers.push(this._getOriginsRow(measuresRow));
        }

        return headers;
    }
    /**
     * Returns the list of body rows of the pivot table for a given tree.
     *
     * @protected
     * @param {Object} tree
     * @param {Object[]} columns
     * @returns {Object[]}
     */
    _getTableRows(tree, columns) {
        let rows = [];
        const group = tree.root;
        const rowGroupId = [group.values, []];
        const title = group.labels.length ? group.labels[group.labels.length - 1] : _t("Total");
        const indent = group.labels.length;
        const isLeaf = !tree.directSubTrees.size;
        const rowGroupBys = this.metaData.fullRowGroupBys;

        const subGroupMeasurements = columns.map((column) => {
            const colGroupId = column.groupId;
            const groupIntersectionId = [rowGroupId[0], colGroupId[1]];
            const measure = column.measure;
            const originIndexes = column.originIndexes || [0];

            const value = this._getCellValue(groupIntersectionId, measure, originIndexes, {
                data: this.data,
            });

            const measurement = {
                groupId: groupIntersectionId,
                originIndexes: originIndexes,
                measure: measure,
                value: value,
                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,
            };
            return measurement;
        });

        rows.push({
            title: title,
            label:
                indent === 0
                    ? undefined
                    : this.metaData.fields[rowGroupBys[indent - 1].split(":")[0]].string,
            groupId: rowGroupId,
            indent: indent,
            isLeaf: isLeaf,
            isFolded: isLeaf && rowGroupBys.length > group.values.length,
            subGroupMeasurements: subGroupMeasurements,
        });

        const subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];
        subTreeKeys.forEach((subTreeKey) => {
            const subTree = tree.directSubTrees.get(subTreeKey);
            rows = rows.concat(this._getTableRows(subTree, columns));
        });

        return rows;
    }
    /**
     * returns the height of a given groupTree
     *
     * @protected
     * @param {Object} tree, a groupTree
     * @returns {number}
     */
    _getTreeHeight(tree) {
        const subTreeHeights = [...tree.directSubTrees.values()].map(
            this._getTreeHeight.bind(this)
        );
        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;
    }
    /**
     * @protected
     * @param {Data} data
     * @returns {boolean} true iff there's no data in the table
     */
    _hasData(data) {
        return (data.counts[JSON.stringify([[], []])] || []).some((count) => {
            return count > 0;
        });
    }
    /**
     * Initialize/Reinitialize data.rowGroupTree, colGroupTree, measurements,
     * counts and subdivide the group 'Total' as many times it is necessary.
     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in
     * order to see if there is data in the intersection of the group 'Total'
     * and the various origins. In case there is none, non supplementary rpc
     * will be done (see the code of subdivideGroup).
     *
     * @protected
     * @param {Config} config
     */
    async _loadData(config, prune = true) {
        config.data = {}; // data will be completely recomputed
        const { data, metaData } = config;
        data.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        data.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        data.measurements = {};
        data.counts = {};
        data.groupDomains = {};
        data.numbering = {};
        const key = JSON.stringify([[], []]);
        data.groupDomains[key] = metaData.domains.slice(0);

        const group = { rowValues: [], colValues: [] };
        const leftDivisors = sections(metaData.fullRowGroupBys);
        const rightDivisors = sections(metaData.fullColGroupBys);
        const divisors = cartesian(leftDivisors, rightDivisors);

        await this._subdivideGroup(group, divisors.slice(0, 1), config);
        await this._subdivideGroup(group, divisors.slice(1), config);

        // keep folded groups folded after the reload if the structure of the table is the same
        if (prune && this._hasData(data) && this._hasData(this.data)) {
            if (
                symmetricalDifference(metaData.rowGroupBys, this.metaData.rowGroupBys).length === 0
            ) {
                this._pruneTree(data.rowGroupTree, this.data.rowGroupTree);
            }
            if (
                symmetricalDifference(metaData.colGroupBys, this.metaData.colGroupBys).length === 0
            ) {
                this._pruneTree(data.colGroupTree, this.data.colGroupTree);
            }
        }

        this.data = config.data;
        this.metaData = config.metaData;
    }
    /**
     * @protected
     * @param {string} gb
     * @returns {string}
     */
    _normalize(gb) {
        const [fieldName, interval] = gb.split(":");
        const field = this.metaData.fields[fieldName];
        if (["date", "datetime"].includes(field.type)) {
            return `${fieldName}:${interval || "month"}`;
        } else {
            return fieldName;
        }
    }
    /**
     * Extract the information in the read_group results (groupSubdivisions)
     * and develop this.data.rowGroupTree, colGroupTree, measurements, counts, and
     * groupDomains.
     * If a column needs to be sorted, the rowGroupTree corresponding to the
     * group is sorted.
     *
     * @protected
     * @param {Object} group
     * @param {Object[]} groupSubdivisions
     * @param {Config} config
     */
    _prepareData(group, groupSubdivisions, config) {
        const { data, metaData } = config;
        const groupRowValues = group.rowValues;
        let groupRowLabels = [];
        let rowSubTree = data.rowGroupTree;
        let root;
        if (groupRowValues.length) {
            // we should have labels information on hand! regretful!
            rowSubTree = this._findGroup(data.rowGroupTree, groupRowValues);
            root = rowSubTree.root;
            groupRowLabels = root.labels;
        }

        const groupColValues = group.colValues;
        let groupColLabels = [];
        if (groupColValues.length) {
            root = this._findGroup(data.colGroupTree, groupColValues).root;
            groupColLabels = root.labels;
        }

        groupSubdivisions.forEach((groupSubdivision) => {
            groupSubdivision.subGroups.forEach((subGroup) => {
                const rowValues = groupRowValues.concat(
                    this._getGroupValues(subGroup, groupSubdivision.rowGroupBy)
                );
                const rowLabels = groupRowLabels.concat(
                    this._getGroupLabels(subGroup, groupSubdivision.rowGroupBy, config)
                );

                const colValues = groupColValues.concat(
                    this._getGroupValues(subGroup, groupSubdivision.colGroupBy)
                );
                const colLabels = groupColLabels.concat(
                    this._getGroupLabels(subGroup, groupSubdivision.colGroupBy, config)
                );

                if (!colValues.length && rowValues.length) {
                    this._addGroup(data.rowGroupTree, rowLabels, rowValues);
                }
                if (colValues.length && !rowValues.length) {
                    this._addGroup(data.colGroupTree, colLabels, colValues);
                }

                const key = JSON.stringify([rowValues, colValues]);
                const originIndex = groupSubdivision.group.originIndex;

                if (!(key in data.measurements)) {
                    data.measurements[key] = metaData.origins.map(() => {
                        return this._getMeasurements({}, config);
                    });
                }
                data.measurements[key][originIndex] = this._getMeasurements(subGroup, config);

                if (!(key in data.counts)) {
                    data.counts[key] = metaData.origins.map(function () {
                        return 0;
                    });
                }
                data.counts[key][originIndex] = subGroup.__count;

                if (!(key in data.groupDomains)) {
                    data.groupDomains[key] = metaData.origins.map(function () {
                        return Domain.FALSE.toList();
                    });
                }
                // if __domain is not defined this means that we are in the
                // case where
                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []
                if (subGroup.__domain) {
                    data.groupDomains[key][originIndex] = subGroup.__domain;
                }
            });
        });

        if (metaData.sortedColumn) {
            this._sortRows(metaData.sortedColumn, config);
        }
    }
    /**
     * Make any group in tree a leaf if it was a leaf in oldTree.
     *
     * @protected
     * @param {Object} tree
     * @param {Object} oldTree
     */
    _pruneTree(tree, oldTree) {
        if (!oldTree.directSubTrees.size) {
            tree.directSubTrees.clear();
            delete tree.sortedKeys;
            return;
        }
        [...tree.directSubTrees.keys()].forEach((subTreeKey) => {
            const subTree = tree.directSubTrees.get(subTreeKey);
            if (!oldTree.directSubTrees.has(subTreeKey)) {
                subTree.directSubTrees.clear();
                delete subTree.sortedKeys;
            } else {
                const oldSubTree = oldTree.directSubTrees.get(subTreeKey);
                this._pruneTree(subTree, oldSubTree);
            }
        });
    }

    _getEmptyGroupLabel(fieldName) {
        return _t("None");
    }

    /**
     * Extract from a groupBy value a label.
     *
     * @protected
     * @param {any} value
     * @param {string} groupBy
     * @param {Config} config
     * @returns {string}
     */
    _sanitizeLabel(value, groupBy, config) {
        const { metaData } = config;
        const fieldName = groupBy.split(":")[0];
        if (
            fieldName &&
            metaData.fields[fieldName] &&
            metaData.fields[fieldName].type === "boolean"
        ) {
            return value === undefined ? _t("None") : value ? _t("Yes") : _t("No");
        }
        if (value === false) {
            return this._getEmptyGroupLabel(fieldName);
        }
        if (value instanceof Array) {
            return this._getNumberedLabel(value, fieldName, config);
        }
        if (
            fieldName &&
            metaData.fields[fieldName] &&
            metaData.fields[fieldName].type === "selection"
        ) {
            const selected = metaData.fields[fieldName].selection.find((o) => o[0] === value);
            return selected ? selected[1] : value; // selected should be truthy normally ?!
        }
        return value;
    }
    /**
     * Extract from a groupBy value the raw value of that groupBy (discarding
     * a label if any)
     *
     * @protected
     * @param {any} value
     * @returns {any}
     */
    _sanitizeValue(value) {
        if (value instanceof Array) {
            return value[0];
        }
        return value;
    }
    /**
     * Get all partitions of a given group using the provided list of divisors
     * and enrich the objects of this.data.rowGroupTree, colGroupTree,
     * measurements, counts.
     *
     * @protected
     * @param {Object} group
     * @param {Array[]} divisors
     * @param {Config} config
     */
    async _subdivideGroup(group, divisors, config) {
        const { data, metaData } = config;
        const key = JSON.stringify([group.rowValues, group.colValues]);

        const proms = metaData.origins.reduce((acc, origin, originIndex) => {
            // if no information on group content is available, we fetch data.
            // if group is known to be empty for the given origin,
            // we don't need to fetch data for that origin.
            if (!data.counts[key] || data.counts[key][originIndex] > 0) {
                const subGroup = {
                    rowValues: group.rowValues,
                    colValues: group.colValues,
                    originIndex: originIndex,
                };
                const groupDomain = this._getGroupDomain(subGroup, config);
                const measureSpecs = this._getMeasureSpecs(config);
                const resModel = config.metaData.resModel;
                const kwargs = { lazy: false, context: this.searchParams.context };
                const mapping = {};
                divisors.forEach((divisor) => {
                    acc.push(
                        this._getGroupSubdivision(subGroup, divisor[0], divisor[1], {
                            resModel,
                            groupDomain,
                            measureSpecs,
                            kwargs,
                            mapping,
                        })
                    );
                });
            }
            return acc;
        }, []);
        const groupSubdivisions = await this.keepLast.add(Promise.all(proms));
        if (groupSubdivisions.length) {
            this._prepareData(group, groupSubdivisions, config);
        }
    }
    /**
     * Sort the rows, depending on the values of a given column.  This is an
     * in-memory sort.
     *
     * @protected
     * @param {Object} sortedColumn
     * @param {number[]} sortedColumn.groupId
     * @param {Config} config
     */
    _sortRows(sortedColumn, config) {
        const metaData = config.metaData || this.metaData;
        const data = config.data || this.data;
        const colGroupValues = sortedColumn.groupId[1];
        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];
        metaData.sortedColumn = sortedColumn;

        const sortFunction = (tree) => {
            return (subTreeKey) => {
                const subTree = tree.directSubTrees.get(subTreeKey);
                const groupIntersectionId = [subTree.root.values, colGroupValues];
                const value =
                    this._getCellValue(
                        groupIntersectionId,
                        sortedColumn.measure,
                        sortedColumn.originIndexes,
                        { data }
                    ) || 0;
                return sortedColumn.order === "asc" ? value : -value;
            };
        };

        this._sortTree(sortFunction, data.rowGroupTree);
    }
    /**
     * Sort recursively the subTrees of tree using sortFunction.
     * In the end each node of the tree has its direct children sorted
     * according to the criterion reprensented by sortFunction.
     *
     * @protected
     * @param {Function} sortFunction
     * @param {Object} tree
     */
    _sortTree(sortFunction, tree) {
        tree.sortedKeys = sortBy([...tree.directSubTrees.keys()], sortFunction(tree));
        [...tree.directSubTrees.values()].forEach((subTree) => {
            this._sortTree(sortFunction, subTree);
        });
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_renderer.js  *
*  Lines: 256                                               *
************************************************************/
odoo.define('@web/views/pivot/pivot_renderer', ['@web/core/l10n/translation', '@web/core/checkbox/checkbox', '@web/core/l10n/localization', '@web/core/registry', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/views/fields/formatters', '@web/views/pivot/pivot_header', '@odoo/owl', '@web/core/network/download', '@web/core/utils/hooks', '@web/views/view_components/report_view_measures'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { localization } = require("@web/core/l10n/localization");
const { registry } = require("@web/core/registry");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { formatPercentage } = require("@web/views/fields/formatters");
const { PivotHeader } = require("@web/views/pivot/pivot_header");

const { Component, onWillUpdateProps, useRef } = require("@odoo/owl");
const { download } = require("@web/core/network/download");
const { useService } = require("@web/core/utils/hooks");
const { ReportViewMeasures } = require("@web/views/view_components/report_view_measures");

const formatters = registry.category("formatters");

const PivotRenderer = __exports.PivotRenderer = class PivotRenderer extends Component {
    static template = "web.PivotRenderer";
    static components = { Dropdown, DropdownItem, CheckBox, PivotHeader, ReportViewMeasures };
    static props = ["model", "buttonTemplate"];

    setup() {
        this.actionService = useService("action");
        this.model = this.props.model;
        this.table = this.model.getTable();
        this.l10n = localization;
        this.tableRef = useRef("table");

        onWillUpdateProps(this.onWillUpdateProps);
    }
    onWillUpdateProps() {
        this.table = this.model.getTable();
    }
    /**
     * Get the formatted value of the cell.
     *
     * @private
     * @param {Object} cell
     * @returns {string} Formatted value
     */
    getFormattedValue(cell) {
        const field = this.model.metaData.measures[cell.measure];
        let formatType = this.model.metaData.widgets[cell.measure];
        if (!formatType) {
            const fieldType = field.type;
            formatType = ["many2one", "reference"].includes(fieldType) ? "integer" : fieldType;
        }
        const formatter = formatters.get(formatType);
        return formatter(cell.value, field);
    }
    /**
     * Get the formatted variation of a cell.
     *
     * @private
     * @param {Object} cell
     * @returns {string} Formatted variation
     */
    getFormattedVariation(cell) {
        if (isNaN(cell.value)) {
            return "-";
        }
        return formatPercentage(cell.value, this.model.metaData.fields[cell.measure]);
    }

    getHeaderProps({ cell, isXAxis = false, isInHead = false }) {
        const type = isXAxis ? "col" : "row";
        return {
            cell,
            isXAxis,
            isInHead,
            customGroupBys: this.model.metaData.customGroupBys,
            onItemSelected: (payload) => this.onGroupBySelected(type, payload),
            onAddCustomGroupBy: (fieldName) =>
                this.onAddCustomGroupBy(type, cell.groupId, fieldName),
            onClick: () => this.onHeaderClick(cell, type),
        };
    }

    //----------------------------------------------------------------------
    // Handlers
    //----------------------------------------------------------------------

    /**
     * Handle the adding of a custom groupby (inside the view, not the searchview).
     *
     * @param {"col"|"row"} type
     * @param {Array[]} groupId
     * @param {string} fieldName
     */
    onAddCustomGroupBy(type, groupId, fieldName) {
        this.model.addGroupBy({ groupId, fieldName, custom: true, type });
    }

    /**
     * Handle the selection of a groupby dropdown item.
     *
     * @param {"col"|"row"} type
     * @param {Object} payload
     */
    onGroupBySelected(type, payload) {
        this.model.addGroupBy({ ...payload, type });
    }
    /**
     * Handle a click on a header cell.
     *
     * @param {Object} cell
     * @param {string} type col or row
     */
    onHeaderClick(cell, type) {
        if (cell.isLeaf && cell.isFolded) {
            this.model.expandGroup(cell.groupId, type);
        } else if (!cell.isLeaf) {
            this.model.closeGroup(cell.groupId, type);
        }
    }
    /**
     * Handle a click on a measure cell.
     *
     * @param {Object} cell
     */
    onMeasureClick(cell) {
        this.model.sortRows({
            groupId: cell.groupId,
            measure: cell.measure,
            order: (cell.order || "desc") === "asc" ? "desc" : "asc",
            originIndexes: cell.originIndexes,
        });
    }
    /**
     * Hover the column in which the mouse is.
     *
     * @param {MouseEvent} ev
     */
    onMouseEnter(ev) {
        var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);
        if (ev.currentTarget.tagName === "TH") {
            if (
                !ev.currentTarget.classList.contains("o_pivot_origin_row") &&
                this.model.metaData.origins.length === 2
            ) {
                index = 3 * index; // two origins + comparison column
            }
            index += 1; // row groupbys column
        }
        this.tableRef.el
            .querySelectorAll("td:nth-child(" + (index + 1) + ")")
            .forEach((elt) => elt.classList.add("o_cell_hover"));
    }
    /**
     * Remove the hover on the columns.
     */
    onMouseLeave() {
        this.tableRef.el
            .querySelectorAll(".o_cell_hover")
            .forEach((elt) => elt.classList.remove("o_cell_hover"));
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Exports the current pivot table data in a xls file. For this, we have to
     * serialize the current state, then call the server /web/pivot/export_xlsx.
     * Force a reload before exporting to ensure to export up-to-date data.
     */
    onDownloadButtonClicked() {
        if (this.model.getTableWidth() > 16384) {
            throw new Error(
                _t(
                    "For Excel compatibility, data cannot be exported if there are more than 16384 columns.\n\nTip: try to flip axis, filter further or reduce the number of measures."
                )
            );
        }
        const table = this.model.exportData();
        download({
            url: "/web/pivot/export_xlsx",
            data: { data: new Blob([JSON.stringify(table)], { type: "application/json" }) },
        });
    }
    /**
     * Expands all groups
     */
    onExpandButtonClicked() {
        this.model.expandAll();
    }
    /**
     * Flips axis
     */
    onFlipButtonClicked() {
        this.model.flip();
    }
    /**
     * Toggles the given measure
     *
     * @param {Object} param0
     * @param {string} param0.measure
     */
    onMeasureSelected({ measure }) {
        this.model.toggleMeasure(measure);
    }
    /**
     * Execute the action to open the view on the current model.
     *
     * @param {Array} domain
     * @param {Array} views
     * @param {Object} context
     */
    openView(domain, views, context) {
        this.actionService.doAction({
            type: "ir.actions.act_window",
            name: this.model.metaData.title,
            res_model: this.model.metaData.resModel,
            views: views,
            view_mode: "list",
            target: "current",
            context,
            domain,
        });
    }
    /**
     * @param {CustomEvent} ev
     */
    onOpenView(cell) {
        if (cell.value === undefined || this.model.metaData.disableLinking) {
            return;
        }

        const context = Object.assign({}, this.model.searchParams.context);
        Object.keys(context).forEach((x) => {
            if (x === "group_by" || x.startsWith("search_default_")) {
                delete context[x];
            }
        });

        // retrieve form and list view ids from the action
        const { views = [] } = this.env.config;
        this.views = ["list", "form"].map((viewType) => {
            const view = views.find((view) => view[1] === viewType);
            return [view ? view[0] : false, viewType];
        });

        const group = {
            rowValues: cell.groupId[0],
            colValues: cell.groupId[1],
            originIndex: cell.originIndexes[0],
        };
        this.openView(this.model.getGroupDomain(group), this.views, context);
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_search_model.js  *
*  Lines: 29                                                    *
****************************************************************/
odoo.define('@web/views/pivot/pivot_search_model', ['@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
const { SearchModel } = require("@web/search/search_model");

const PivotSearchModel = __exports.PivotSearchModel = class PivotSearchModel extends SearchModel {
    _getIrFilterDescription() {
        this.preparingIrFilterDescription = true;
        const result = super._getIrFilterDescription(...arguments);
        this.preparingIrFilterDescription = false;
        return result;
    }

    _getSearchItemGroupBys(activeItem) {
        const { searchItemId } = activeItem;
        const { context, type } = this.searchItems[searchItemId];
        if (
            !this.preparingIrFilterDescription &&
            type === "favorite" &&
            context.pivot_row_groupby
        ) {
            return context.pivot_row_groupby;
        }
        return super._getSearchItemGroupBys(...arguments);
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_view.js  *
*  Lines: 66                                            *
********************************************************/
odoo.define('@web/views/pivot/pivot_view', ['@web/core/l10n/translation', '@web/core/registry', '@web/views/pivot/pivot_arch_parser', '@web/views/pivot/pivot_controller', '@web/views/pivot/pivot_model', '@web/views/pivot/pivot_renderer', '@web/views/pivot/pivot_search_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { PivotArchParser } = require("@web/views/pivot/pivot_arch_parser");
const { PivotController } = require("@web/views/pivot/pivot_controller");
const { PivotModel } = require("@web/views/pivot/pivot_model");
const { PivotRenderer } = require("@web/views/pivot/pivot_renderer");
const { PivotSearchModel } = require("@web/views/pivot/pivot_search_model");

const viewRegistry = registry.category("views");

const pivotView = __exports.pivotView = {
    type: "pivot",
    Controller: PivotController,
    Renderer: PivotRenderer,
    Model: PivotModel,
    ArchParser: PivotArchParser,
    SearchModel: PivotSearchModel,
    searchMenuTypes: ["filter", "groupBy", "comparison", "favorite"],
    buttonTemplate: "web.PivotView.Buttons",

    props: (genericProps, view) => {
        const modelParams = {};
        if (genericProps.state) {
            modelParams.data = genericProps.state.data;
            modelParams.metaData = genericProps.state.metaData;
        } else {
            const { arch, fields, resModel } = genericProps;

            // parse arch
            const archInfo = new view.ArchParser().parse(arch);

            if (!archInfo.activeMeasures.length || archInfo.displayQuantity) {
                archInfo.activeMeasures.unshift("__count");
            }

            modelParams.metaData = {
                activeMeasures: archInfo.activeMeasures,
                colGroupBys: archInfo.colGroupBys,
                defaultOrder: archInfo.defaultOrder,
                disableLinking: Boolean(archInfo.disableLinking),
                fields: fields,
                fieldAttrs: archInfo.fieldAttrs,
                resModel: resModel,
                rowGroupBys: archInfo.rowGroupBys,
                title: archInfo.title || _t("Untitled"),
                widgets: archInfo.widgets,
            };
        }

        return {
            ...genericProps,
            Model: view.Model,
            modelParams,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

viewRegistry.add("pivot", pivotView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_arch_parser.js  *
*  Lines: 59                                                              *
**************************************************************************/
odoo.define('@mail/views/web/activity/activity_arch_parser', ['@web/core/utils/xml', '@web/views/fields/field'], function (require) {
'use strict';
let __exports = {};
const { visitXML } = require("@web/core/utils/xml");
const { Field } = require("@web/views/fields/field");

const ActivityArchParser = __exports.ActivityArchParser = class ActivityArchParser {
    parse(xmlDoc, models, modelName) {
        const jsClass = xmlDoc.getAttribute("js_class");
        const title = xmlDoc.getAttribute("string");

        const fieldNodes = {};
        const templateDocs = {};
        const fieldNextIds = {};

        visitXML(xmlDoc, (node) => {
            if (node.hasAttribute("t-name")) {
                templateDocs[node.getAttribute("t-name")] = node;
                return;
            }

            if (node.tagName === "field") {
                const fieldInfo = Field.parseFieldNode(
                    node,
                    models,
                    modelName,
                    "activity",
                    jsClass
                );
                if (!(fieldInfo.name in fieldNextIds)) {
                    fieldNextIds[fieldInfo.name] = 0;
                }
                const fieldId = `${fieldInfo.name}_${fieldNextIds[fieldInfo.name]++}`;
                fieldNodes[fieldId] = fieldInfo;
                node.setAttribute("field_id", fieldId);
            }

            // Keep track of last update so images can be reloaded when they may have changed.
            if (node.tagName === "img") {
                const attSrc = node.getAttribute("t-att-src");
                if (
                    attSrc &&
                    /\bactivity_image\b/.test(attSrc) &&
                    !Object.values(fieldNodes).some((f) => f.name === "write_date")
                ) {
                    fieldNodes.write_date_0 = { name: "write_date", type: "datetime" };
                }
            }
        });
        return {
            fieldNodes,
            templateDocs,
            title,
        };
    }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_cell.js  *
*  Lines: 76                                                       *
*******************************************************************/
odoo.define('@mail/views/web/activity/activity_cell', ['@mail/core/web/activity_list_popover', '@mail/views/web/fields/avatar/avatar', '@odoo/owl', '@web/core/popover/popover_hook', '@web/core/l10n/dates'], function (require) {
'use strict';
let __exports = {};
const { ActivityListPopover } = require("@mail/core/web/activity_list_popover");
const { Avatar } = require("@mail/views/web/fields/avatar/avatar");

const { Component, useRef } = require("@odoo/owl");

const { usePopover } = require("@web/core/popover/popover_hook");

const { formatDate } = require("@web/core/l10n/dates");

const ActivityCell = __exports.ActivityCell = class ActivityCell extends Component {
    static components = {
        Avatar,
    };
    static props = {
        activityIds: {
            type: Array,
            elements: Number,
        },
        attachmentsInfo: {
            optional: true,
            type: Object,
        },
        activityTypeId: Number,
        reportingDate: String,
        countByState: Object,
        reloadFunc: Function,
        resId: Number,
        resModel: String,
        userAssignedIds: Array,
    };
    static template = "mail.ActivityCell";

    setup() {
        this.popover = usePopover(ActivityListPopover, { position: "bottom-start" });
        this.contentRef = useRef("content");
    }

    get reportingDateFormatted() {
        return formatDate(luxon.DateTime.fromISO(this.props.reportingDate));
    }

    get ongoingActivityCount() {
        return (
            (this.props.countByState?.planned ?? 0) +
            (this.props.countByState?.today ?? 0) +
            (this.props.countByState?.overdue ?? 0)
        );
    }

    get totalActivityCount() {
        return this.ongoingActivityCount + (this.props.countByState?.done ?? 0);
    }

    onClick() {
        if (this.popover.isOpen) {
            this.popover.close();
        } else {
            this.popover.open(this.contentRef.el, {
                activityIds: this.props.activityIds,
                defaultActivityTypeId: this.props.activityTypeId,
                onActivityChanged: () => {
                    this.props.reloadFunc();
                    this.popover.close();
                },
                resId: this.props.resId,
                resModel: this.props.resModel,
            });
        }
    }
}

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_compiler.js  *
*  Lines: 97                                                           *
***********************************************************************/
odoo.define('@mail/views/web/activity/activity_compiler', ['@web/core/utils/xml', '@web/views/view_compiler', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
const { createElement, extractAttributes } = require("@web/core/utils/xml");
const { toInterpolatedStringExpression, ViewCompiler } = require("@web/views/view_compiler");
const { toStringExpression } = require("@web/views/utils");

const ActivityCompiler = __exports.ActivityCompiler = class ActivityCompiler extends ViewCompiler {
    /**
     * @override
     */
    compileField(el, params) {
        let compiled;
        if (el.hasAttribute("widget")) {
            compiled = super.compileField(el, params);
        } else {
            // fields without a specified widget are rendered as simple spans in activity records
            compiled = createElement("div", {
                "t-out": `record["${el.getAttribute("name")}"].value`,
            });
        }
        const classNames = [];
        const { bold, display, muted } = extractAttributes(el, ["bold", "display", "muted"]);
        if (display === "right") {
            classNames.push("float-end");
        }
        if (display === "full") {
            classNames.push("d-block", "text-truncate");
        } else {
            classNames.push("d-inline-block");
        }
        if (bold) {
            classNames.push("fw-bold");
        }
        if (muted) {
            classNames.push("text-muted");
        }
        if (classNames.length > 0) {
            const clsFormatted = el.hasAttribute("widget")
                ? toStringExpression(classNames.join(" "))
                : classNames.join(" ");
            compiled.setAttribute("class", clsFormatted);
        }

        const attrs = {};
        for (const attr of el.attributes) {
            attrs[attr.name] = attr.value;
        }

        if (el.hasAttribute("widget")) {
            const attrsParts = Object.entries(attrs).map(([key, value]) => {
                if (key.startsWith("t-attf-")) {
                    key = key.slice(7);
                    value = toInterpolatedStringExpression(value);
                } else if (key.startsWith("t-att-")) {
                    key = key.slice(6);
                    value = `"" + (${value})`;
                } else if (key.startsWith("t-att")) {
                    throw new Error("t-att on <field> nodes is not supported");
                } else if (!key.startsWith("t-")) {
                    value = toStringExpression(value);
                }
                return `'${key}':${value}`;
            });
            compiled.setAttribute("attrs", `{${attrsParts.join(",")}}`);
        }

        for (const attr in attrs) {
            if (attr.startsWith("t-") && !attr.startsWith("t-att")) {
                compiled.setAttribute(attr, attrs[attr]);
            }
        }

        return compiled;
    }
}

ActivityCompiler.OWL_DIRECTIVE_WHITELIST = [
    ...ViewCompiler.OWL_DIRECTIVE_WHITELIST,
    "t-name",
    "t-esc",
    "t-out",
    "t-set",
    "t-value",
    "t-if",
    "t-else",
    "t-elif",
    "t-foreach",
    "t-as",
    "t-key",
    "t-att.*",
    "t-call",
    "t-translation",
];

return __exports;
});
;

/*************************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_controller.js  *
*  Lines: 148                                                            *
*************************************************************************/
odoo.define('@mail/views/web/activity/activity_controller', ['@web/core/l10n/translation', '@odoo/owl', '@web/core/utils/hooks', '@web/model/model', '@web/model/relational_model/utils', '@web/search/cog_menu/cog_menu', '@web/search/layout', '@web/search/search_bar/search_bar', '@web/search/pager_hook', '@web/views/standard_view_props', '@web/views/view_dialogs/select_create_dialog'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");

const { Component, useState } = require("@odoo/owl");

const { useService } = require("@web/core/utils/hooks");
const { useModel } = require("@web/model/model");
const { extractFieldsFromArchInfo } = require("@web/model/relational_model/utils");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");
const { Layout } = require("@web/search/layout");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { usePager } = require("@web/search/pager_hook");
const { standardViewProps } = require("@web/views/standard_view_props");
const { SelectCreateDialog } = require("@web/views/view_dialogs/select_create_dialog");

const ActivityController = __exports.ActivityController = class ActivityController extends Component {
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        Renderer: Function,
        archInfo: Object,
    };
    static template = "mail.ActivityController";

    setup() {
        this.model = useState(useModel(this.props.Model, this.modelParams));

        this.dialog = useService("dialog");
        this.action = useService("action");
        this.store = useService("mail.store");
        this.ui = useState(useService("ui"));
        usePager(() => {
            const { count, hasLimitedCount, limit, offset } = this.model.root;
            return {
                offset: offset,
                limit: limit,
                total: count,
                onUpdate: async (params) => {
                    // Ensure that only (active) records with at least one activity, "done" (archived) or not, are fetched.
                    // We don't use active_test=false in the context because otherwise we would also get archived records.
                    params.domain = [...(this.model.originalDomain || []), ["activity_ids.active", "in", [true, false]]];
                    await Promise.all([
                        this.model.root.load(params),
                        this.model.fetchActivityData(params),
                    ]);
                },
                updateTotal: hasLimitedCount ? () => this.model.root.fetchCount() : undefined,
            };
        });
    }

    get modelParams() {
        const { archInfo, resModel } = this.props;
        const { activeFields, fields } = extractFieldsFromArchInfo(archInfo, this.props.fields);
        return {
            config: {
                activeFields,
                resModel,
                fields,
            },
        };
    }

    getSearchProps() {
        const { comparision, context, domain, groupBy, orderBy } = this.env.searchModel;
        return { comparision, context, domain, groupBy, orderBy };
    }

    scheduleActivity() {
        this.dialog.add(SelectCreateDialog, {
            resModel: this.props.resModel,
            searchViewId: this.env.searchModel.searchViewId,
            domain: this.model.originalDomain,
            title: _t("Search: %s", this.props.archInfo.title),
            multiSelect: false,
            context: this.props.context,
            noCreate: this.props.context?.create === false,
            onSelected: async (resIds) => {
                await this.store.scheduleActivity(this.props.resModel, resIds);
            },
        }, {
            onClose: () => this.model.load(this.getSearchProps())
        });
    }

    openActivityFormView(resId, activityTypeId) {
        this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "mail.activity",
                views: [[false, "form"]],
                view_mode: "form",
                view_type: "form",
                res_id: false,
                target: "new",
                context: {
                    default_res_id: resId,
                    default_res_model: this.props.resModel,
                    default_activity_type_id: activityTypeId,
                },
            },
            {
                onClose: () => this.model.load(this.getSearchProps()),
            }
        );
    }

    sendMailTemplate(templateID, activityTypeID) {
        const groupedActivities = this.model.activityData.grouped_activities;
        const resIds = [];
        for (const resId in groupedActivities) {
            const activityByType = groupedActivities[resId];
            const activity = activityByType[activityTypeID];
            if (activity) {
                resIds.push(parseInt(resId));
            }
        }
        this.model.orm.call(this.props.resModel, "activity_send_mail", [resIds, templateID], {});
    }

    async openRecord(record, mode) {
        const activeIds = this.model.root.records.map((datapoint) => datapoint.resId);
        this.props.selectRecord(record.resId, { activeIds, mode });
    }

    get rendererProps() {
        return {
            activityTypes: this.model.activityData.activity_types,
            activityResIds: this.model.activityData.activity_res_ids,
            fields: this.model.root.fields,
            records: this.model.root.records,
            resModel: this.props.resModel,
            archInfo: this.props.archInfo,
            groupedActivities: this.model.activityData.grouped_activities,
            scheduleActivity: this.scheduleActivity.bind(this),
            onReloadData: () => this.model.load(this.getSearchProps()),
            onEmptyCell: this.openActivityFormView.bind(this),
            onSendMailTemplate: this.sendMailTemplate.bind(this),
            openRecord: this.openRecord.bind(this),
        };
    }
}

return __exports;
});
;

/********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_model.js  *
*  Lines: 32                                                        *
********************************************************************/
odoo.define('@mail/views/web/activity/activity_model', ['@web/model/relational_model/relational_model'], function (require) {
'use strict';
let __exports = {};
const { RelationalModel } = require("@web/model/relational_model/relational_model");

const ActivityModel = __exports.ActivityModel = class ActivityModel extends RelationalModel {
    static DEFAULT_LIMIT = 100;

    async load(params = {}) {
        this.originalDomain = params.domain ? [...params.domain] : [];
        // Ensure that only (active) records with at least one activity, "done" (archived) or not, are fetched.
        // We don't use active_test=false in the context because otherwise we would also get archived records.
        params.domain = [...(params.domain || []), ["activity_ids.active", "in", [true, false]]];
        if (params && "groupBy" in params) {
            params.groupBy = [];
        }
        await Promise.all([this.fetchActivityData(params), super.load(params)]);
    }

    async fetchActivityData(params) {
        this.activityData = await this.orm.call("mail.activity", "get_activity_data", [], {
            res_model: this.config.resModel,
            domain: params.domain || this.env.searchModel._domain,
            limit: params.limit || this.initialLimit,
            offset: params.offset || 0,
            fetch_done: true,
        });
    }
}

return __exports;
});
;

/*********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_record.js  *
*  Lines: 52                                                         *
*********************************************************************/
odoo.define('@mail/views/web/activity/activity_record', ['@mail/views/web/activity/activity_compiler', '@odoo/owl', '@web/core/py_js/py', '@web/core/user', '@web/core/utils/html', '@web/views/fields/field', '@web/views/kanban/kanban_record', '@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
const { ActivityCompiler } = require("@mail/views/web/activity/activity_compiler");

const { Component } = require("@odoo/owl");

const { evaluateBooleanExpr } = require("@web/core/py_js/py");
const { user } = require("@web/core/user");
const { isHtmlEmpty } = require("@web/core/utils/html");
const { Field } = require("@web/views/fields/field");
const { getFormattedRecord, getImageSrcFromRecordInfo } = require("@web/views/kanban/kanban_record");
const { useViewCompiler } = require("@web/views/view_compiler");

const ActivityRecord = __exports.ActivityRecord = class ActivityRecord extends Component {
    static components = {
        Field,
    };
    static props = {
        archInfo: { type: Object },
        openRecord: { type: Function },
        record: { type: Object },
    };
    static template = "mail.ActivityRecord";

    setup() {
        this.evaluateBooleanExpr = evaluateBooleanExpr;
        this.widget = {
            deletable: false,
            editable: false,
            isHtmlEmpty,
        };
        const { templateDocs } = this.props.archInfo;
        const templates = useViewCompiler(ActivityCompiler, templateDocs);
        this.recordTemplate = templates["activity-box"];
    }

    getRenderingContext() {
        const { record } = this.props;
        return {
            record: getFormattedRecord(record),
            activity_image: (...args) => getImageSrcFromRecordInfo(record, ...args),
            user_context: user.context,
            widget: this.widget,
            luxon,
            __comp__: Object.assign(Object.create(this), { this: this }),
        };
    }
}

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_renderer.js  *
*  Lines: 199                                                          *
***********************************************************************/
odoo.define('@mail/views/web/activity/activity_renderer', ['@mail/core/web/mail_column_progress', '@mail/views/web/activity/activity_cell', '@mail/views/web/activity/activity_record', '@odoo/owl', '@web/core/browser/browser', '@web/core/checkbox/checkbox', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
const { MailColumnProgress } = require("@mail/core/web/mail_column_progress");
const { ActivityCell } = require("@mail/views/web/activity/activity_cell");
const { ActivityRecord } = require("@mail/views/web/activity/activity_record");

const { Component, useState } = require("@odoo/owl");

const { browser } = require("@web/core/browser/browser");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { _t } = require("@web/core/l10n/translation");

const ActivityRenderer = __exports.ActivityRenderer = class ActivityRenderer extends Component {
    static components = {
        ActivityCell,
        ActivityRecord,
        ColumnProgress: MailColumnProgress,
        Dropdown,
        DropdownItem,
        CheckBox,
    };
    static props = {
        activityTypes: { type: Object },
        activityResIds: { type: Array },
        fields: { type: Object },
        resModel: { type: String },
        records: { type: Array },
        archInfo: { type: Object },
        groupedActivities: { type: Object },
        scheduleActivity: { type: Function },
        onReloadData: { type: Function },
        onEmptyCell: { type: Function },
        onSendMailTemplate: { type: Function },
        openRecord: { type: Function },
    };
    static template = "mail.ActivityRenderer";

    setup() {
        this.activeFilter = useState({
            progressValue: {
                active: null,
            },
            activityTypeId: null,
            resIds: new Set(Object.keys(this.props.groupedActivities)),
        });

        this.storageKey = ["activity_columns", this.props.resModel, this.env.config.viewId];
        this.setupStorageActiveColumns();
    }

    getGroupInfo(activityType) {
        const types = {
            done: {
                color: "secondary",
                inProgressBar: false,
                label: _t("done"), // activity_mixin.activity_state has no done state, so we add it manually here
                value: 0,
            },
            planned: {
                color: "success",
                inProgressBar: true,
                value: 0,
            },
            today: {
                color: "warning",
                inProgressBar: true,
                value: 0,
            },
            overdue: {
                color: "danger",
                inProgressBar: true,
                value: 0,
            },
        };
        for (const [type, label] of this.props.fields.activity_state.selection) {
            types[type].label = label;
        }
        const typeId = activityType.id;
        const isColumnFiltered = this.activeFilter.activityTypeId === activityType.id;
        const progressValue = isColumnFiltered ? this.activeFilter.progressValue : { active: null };

        let totalCountWithoutDone = 0;
        for (const activities of Object.values(this.props.groupedActivities)) {
            if (typeId in activities) {
                for (const [state, stateCount] of Object.entries(
                    activities[typeId].count_by_state
                )) {
                    types[state].value += stateCount;
                    if (state !== "done") {
                        totalCountWithoutDone += stateCount;
                    }
                }
            }
        }

        const progressBar = {
            bars: [],
            activeBar: isColumnFiltered ? this.activeFilter.progressValue.active : null,
        };
        for (const [value, count] of Object.entries(types)) {
            if (count.inProgressBar) {
                progressBar.bars.push({
                    count: count.value,
                    value,
                    string: types[value].label,
                    color: count.color,
                });
            }
        }

        const ongoingActivityCount = types.overdue.value + types.today.value + types.planned.value;
        const ongoingAndDoneCount = ongoingActivityCount + types.done.value;
        const labelAggregate = `${types.overdue.label} + ${types.today.label} + ${types.planned.label}`;
        const aggregateOn =
            ongoingAndDoneCount && this.isTypeDisplayDone(typeId)
                ? {
                      title: `${types.done.label} + ${labelAggregate}`,
                      value: ongoingAndDoneCount,
                  }
                : undefined;
        return {
            aggregate: {
                title: labelAggregate,
                value: isColumnFiltered ? types[progressValue.active].value : ongoingActivityCount,
            },
            aggregateOn: aggregateOn,
            data: {
                count: totalCountWithoutDone,
                filterProgressValue: (name) => this.onSetProgressBarState(typeId, name),
                progressBar,
                progressValue,
            },
        };
    }

    getRecord(resId) {
        return this.props.records.find((r) => r.resId === resId);
    }

    isTypeDisplayDone(typeId) {
        return this.props.activityTypes.find((a) => a.id === typeId).keep_done;
    }

    onSetProgressBarState(typeId, bar) {
        const name = bar.value;
        if (this.activeFilter.progressValue.active === name) {
            this.activeFilter.progressValue.active = null;
            this.activeFilter.activityTypeId = null;
            this.activeFilter.resIds = new Set(Object.keys(this.props.groupedActivities));
        } else {
            this.activeFilter.progressValue.active = name;
            this.activeFilter.activityTypeId = typeId;
            this.activeFilter.resIds = new Set(
                Object.entries(this.props.groupedActivities)
                    .filter(
                        ([, resIds]) => typeId in resIds && name in resIds[typeId].count_by_state
                    )
                    .map(([key]) => parseInt(key))
            );
        }
    }

    get activeColumns() {
        return this.props.activityTypes.filter(
            (activityType) => this.storageActiveColumns[activityType.id]
        );
    }

    setupStorageActiveColumns() {
        const storageActiveColumnsList = browser.localStorage.getItem(this.storageKey)?.split(",");

        this.storageActiveColumns = useState({});
        for (const activityType of this.props.activityTypes) {
            if (storageActiveColumnsList) {
                this.storageActiveColumns[activityType.id] = storageActiveColumnsList.includes(
                    activityType.id.toString()
                );
            } else {
                this.storageActiveColumns[activityType.id] = true;
            }
        }
    }

    toggleDisplayColumn(typeId) {
        this.storageActiveColumns[typeId] = !this.storageActiveColumns[typeId];
        browser.localStorage.setItem(
            this.storageKey.join(","),
            Object.keys(this.storageActiveColumns).filter(
                (activityType) => this.storageActiveColumns[activityType]
            )
        );
    }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_view.js  *
*  Lines: 32                                                       *
*******************************************************************/
odoo.define('@mail/views/web/activity/activity_view', ['@mail/views/web/activity/activity_arch_parser', '@mail/views/web/activity/activity_controller', '@mail/views/web/activity/activity_model', '@mail/views/web/activity/activity_renderer', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { ActivityArchParser } = require("@mail/views/web/activity/activity_arch_parser");
const { ActivityController } = require("@mail/views/web/activity/activity_controller");
const { ActivityModel } = require("@mail/views/web/activity/activity_model");
const { ActivityRenderer } = require("@mail/views/web/activity/activity_renderer");

const { registry } = require("@web/core/registry");

const activityView = __exports.activityView = {
    type: "activity",
    searchMenuTypes: ["filter", "favorite"],
    Controller: ActivityController,
    Renderer: ActivityRenderer,
    ArchParser: ActivityArchParser,
    Model: ActivityModel,
    props: (genericProps, view) => {
        const { arch, relatedModels, resModel } = genericProps;
        const archInfo = new view.ArchParser().parse(arch, relatedModels, resModel);
        return {
            ...genericProps,
            archInfo,
            Model: view.Model,
            Renderer: view.Renderer,
        };
    },
};
registry.category("views").add("activity", activityView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /crm/static/src/views/forecast_graph/forecast_graph_view.js  *
*  Lines: 18                                                              *
**************************************************************************/
odoo.define('@crm/views/forecast_graph/forecast_graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@crm/views/forecast_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { ForecastSearchModel } = require("@crm/views/forecast_search_model");

const forecastGraphView = __exports.forecastGraphView = {
    ...graphView,
    SearchModel: ForecastSearchModel,
};

registry.category("views").add("forecast_graph", forecastGraphView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /crm/static/src/views/forecast_pivot/forecast_pivot_view.js  *
*  Lines: 18                                                              *
**************************************************************************/
odoo.define('@crm/views/forecast_pivot/forecast_pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@crm/views/forecast_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { ForecastSearchModel } = require("@crm/views/forecast_search_model");

const forecastPivotView = __exports.forecastPivotView = {
    ...pivotView,
    SearchModel: ForecastSearchModel,
};

registry.category("views").add("forecast_pivot", forecastPivotView);

return __exports;
});
;

/***********************************************************************
*  Filepath: /web_enterprise/static/src/views/pivot/pivot_renderer.js  *
*  Lines: 37                                                           *
***********************************************************************/
odoo.define('@web_enterprise/views/pivot/pivot_renderer', ['@web/core/utils/patch', '@web/views/pivot/pivot_renderer', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { patch } = require("@web/core/utils/patch");
const { PivotRenderer } = require("@web/views/pivot/pivot_renderer");

const { useEffect, useRef } = require("@odoo/owl");

patch(PivotRenderer.prototype, {
    setup() {
        super.setup();
        this.root = useRef("root");
        if (this.env.isSmall) {
            useEffect(() => {
                if (this.root.el) {
                    const tooltipElems = this.root.el.querySelectorAll("*[data-tooltip]");
                    for (const el of tooltipElems) {
                        el.removeAttribute("data-tooltip");
                        el.removeAttribute("data-tooltip-position");
                    }
                }
            });
        }
    },

    getPadding(cell) {
        if (this.env.isSmall) {
            return 5 + cell.indent * 5;
        }
        return super.getPadding(...arguments);
    },
});

return __exports;
});
;

/***************************************************************************************
*  Filepath: /project/static/src/views/project_task_graph/project_task_graph_model.js  *
*  Lines: 19                                                                           *
***************************************************************************************/
odoo.define('@project/views/project_task_graph/project_task_graph_model', ['@web/views/graph/graph_model', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { GraphModel } = require("@web/views/graph/graph_model");
const { _t } = require("@web/core/l10n/translation");

const ProjectTaskGraphModel = __exports.ProjectTaskGraphModel = class ProjectTaskGraphModel extends GraphModel {
    _getDefaultFilterLabel(field) {
        if (field.fieldName === "project_id") {
            return _t(" Private");
        }
        return super._getDefaultFilterLabel(field);
    }
}

return __exports;
});
;

/**************************************************************************************
*  Filepath: /project/static/src/views/project_task_graph/project_task_graph_view.js  *
*  Lines: 20                                                                          *
**************************************************************************************/
odoo.define('@project/views/project_task_graph/project_task_graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@project/views/project_task_graph/project_task_graph_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { ProjectTaskGraphModel } = require("@project/views/project_task_graph/project_task_graph_model");

const viewRegistry = registry.category("views");

const projectTaskGraphView = __exports.projectTaskGraphView = {
    ...graphView,
    Model: ProjectTaskGraphModel,
};

viewRegistry.add("project_task_graph", projectTaskGraphView);

return __exports;
});
;

/**********************************************************************************
*  Filepath: /project/static/src/views/project_task_pivot/project_pivot_model.js  *
*  Lines: 25                                                                      *
**********************************************************************************/
odoo.define('@project/views/project_task_pivot/project_pivot_model', ['@web/core/l10n/translation', '@web/views/pivot/pivot_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { PivotModel } = require("@web/views/pivot/pivot_model");

const ProjectTaskPivotModel = __exports.ProjectTaskPivotModel = class ProjectTaskPivotModel extends PivotModel {
    /**
     * @override
     */
    _getEmptyGroupLabel(fieldName) {
        if (fieldName === "project_id") {
            return _t("Private");
        } else if (fieldName === "user_ids") {
            return _t("Unassigned");
        } else {
            return super._getEmptyGroupLabel(fieldName);
        }
    }
}

return __exports;
});
;

/*********************************************************************************
*  Filepath: /project/static/src/views/project_task_pivot/project_pivot_view.js  *
*  Lines: 18                                                                     *
*********************************************************************************/
odoo.define('@project/views/project_task_pivot/project_pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@project/views/project_task_pivot/project_pivot_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { ProjectTaskPivotModel } = require("@project/views/project_task_pivot/project_pivot_model");

const projectPivotView = __exports.projectPivotView = {
    ...pivotView,
    Model: ProjectTaskPivotModel,
};

registry.category("views").add("project_pivot", projectPivotView);

return __exports;
});
;

/*******************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_model.js  *
*  Lines: 92                                                                   *
*******************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_model', ['@web/core/l10n/translation', '@web/views/graph/graph_model', '@web/core/utils/arrays'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { GraphModel } = require("@web/views/graph/graph_model");
const { sortBy } = require("@web/core/utils/arrays");

const BurndownChartModel = __exports.BurndownChartModel = class BurndownChartModel extends GraphModel {
    /**
     * @override
     */
    setup(params) {
        super.setup(params);
        this.stageSeqAndNamePerId = {};
    }

    /**
     * Fetch the sequence of each stage in the project. This function alters this.stageSeqAndNamePerId
     * @protected
     * @param {Object} context
     */
    async _fetchStageInfo(context) {
        const searchDomain =
            !context.active_id || !context.default_project_id
                ? []
                : [["project_ids", "in", context.active_id]];
        const data = await this.orm.webSearchRead("project.task.type", searchDomain, {
            specification: {
                name: {},
                sequence: {},
            },
        });
        const stageSeqAndNamePerId = {};
        for (const { id, name, sequence } of data.records) {
            stageSeqAndNamePerId[id] = { name, sequence };
        }
        return stageSeqAndNamePerId;
    }

    /**
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        const { context, groupBy } = searchParams;

        if (groupBy.includes("stage_id")) {
            if (context.stage_name_and_sequence_per_id && context.default_project_id) {
                this.stageSeqAndNamePerId = context.stage_name_and_sequence_per_id;
            } else {
                // if the stage_name_and_sequence_per_id wasn't given by the action (for example if the page is simply reloaded)
                this.stageSeqAndNamePerId = await this._fetchStageInfo(context);
            }
        } else {
            this.stageSeqAndNamePerId = {};
        }
        await super.load(searchParams);
    }

    /**
     * @override
     */
    _prepareData() {
        super._prepareData();
        const { groupBy } = this.searchParams;
        const { mode } = this.metaData;
        if (mode === "line" && groupBy.includes("stage_id")) {
            this.data.datasets = sortBy(this.data.datasets, (dataSet) => {
                const firstIdentifier = [...dataSet.identifiers][0];
                const group = Object.assign(...JSON.parse(firstIdentifier));
                const val = group.stage_id;
                if (Array.isArray(val)) {
                    return this.stageSeqAndNamePerId[val[0]]?.sequence || -1;
                }
                return -1;
            });
        }
    }

    /**
     * @protected
     * @override
     */
    async _loadDataPoints(metaData) {
        metaData.measures.__count.string = _t("# of Tasks");
        return super._loadDataPoints(metaData);
    }
}

return __exports;
});
;

/**************************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_search_model.js  *
*  Lines: 156                                                                         *
**************************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_search_model', ['@web/core/l10n/translation', '@web/core/utils/hooks', '@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { useService } = require("@web/core/utils/hooks");
const { SearchModel } = require("@web/search/search_model");


const BurndownChartSearchModel = __exports.BurndownChartSearchModel = class BurndownChartSearchModel extends SearchModel {

    /**
     * @override
     */
    setup(services) {
        this.notificationService = useService("notification");
        super.setup(...arguments);
    }

    /**
     * @override
     */
    async load(config) {
        await super.load(...arguments);
        // Store date and stage_id searchItemId in the SearchModel for reuse in other functions.
        for (const searchItem of Object.values(this.searchItems)) {
            if (['dateGroupBy', 'groupBy'].includes(searchItem.type)) {
                if (this.stageIdSearchItemId && this.dateSearchItemId && this.isClosedSearchItemId) {
                    return;
                }
                switch (searchItem.fieldName) {
                    case 'date':
                        this.dateSearchItemId = searchItem.id;
                        break;
                    case 'stage_id':
                        this.stageIdSearchItemId = searchItem.id;
                        break;
                    case 'is_closed':
                        this.isClosedSearchItemId = searchItem.id;
                        break;
                }
            }
        }
    }

    /**
     * @override
     */
    deactivateGroup(groupId) {
        // Prevent removing 'Date & Stage' and 'Date & is closed' group by from the search
        if (this.searchItems[this.dateSearchItemId].groupId == groupId) {
            if (this.query.some(queryElem => [this.stageIdSearchItemId, this.isClosedSearchItemId].includes(queryElem.searchItemId))){
                this._addGroupByNotification(_t("The report should be grouped either by \"Stage\" to represent a Burndown Chart or by \"Is Closed\" to represent a Burn-up chart. Without one of these groupings applied, the report will not provide relevant information."));
            }
            return;
        }
        super.deactivateGroup(groupId);
    }

    /**
     * @override
     */
    toggleDateGroupBy(searchItemId, intervalId) {
        // Ensure that there is always one and only one date group by selected.
        if (searchItemId === this.dateSearchItemId) {
            let filtered_query = [];
            let triggerNotification = false;
            for (const queryElem of this.query) {
                if (queryElem.searchItemId !== searchItemId) {
                    filtered_query.push(queryElem);
                } else if (queryElem.intervalId === intervalId) {
                    triggerNotification = true;
                }
            }
            if (filtered_query.length !== this.query.length) {
                this.query = filtered_query;
                if (triggerNotification) {
                    this._addGroupByNotification(_t("The Burndown Chart must be grouped by Date"));
                }
            }
        }
        super.toggleDateGroupBy(...arguments);
    }

    /**
     * @override
     * Ensure here that there is always either the 'stage' or the 'is_closed' searchItemId inside the query.
     */
    toggleSearchItem(searchItemId) {
        // if the current searchItem stage/is_closed, the counterpart is added before removing the current searchItem
        if (searchItemId === this.isClosedSearchItemId){
            super.toggleSearchItem(this.stageIdSearchItemId);
        } else if (searchItemId === this.stageIdSearchItemId){
            super.toggleSearchItem(this.isClosedSearchItemId);
        }
        super.toggleSearchItem(...arguments);
    }

    /**
     * Adds a notification related to the group by constraint of the Burndown Chart.
     * @param body The message to display in the notification.
     * @private
     */
    _addGroupByNotification(body) {
        this.notificationService.add(
            body,
            { type: "danger" }
        );
    }

    /**
     * @override
     */
    async _notify() {
        // Ensure that we always group by date first and by stage_id/is_closed second
        let stageIdIndex = -1;
        let dateIndex = -1;
        let isClosedIndex = -1;
        for (const [index, queryElem] of this.query.entries()) {
            if (dateIndex !== -1 && (stageIdIndex !== -1 || isClosedIndex !== -1)) {
                break;
            }
            switch (queryElem.searchItemId) {
                case this.dateSearchItemId:
                    dateIndex = index;
                    break;
                case this.stageIdSearchItemId:
                    stageIdIndex = index;
                    break;
                case this.isClosedSearchItemId:
                    isClosedIndex = index;
                    break;
            }
        }
        if (isClosedIndex > 0) {
            if (isClosedIndex > dateIndex) {
                dateIndex += 1;
            }
            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);
        } else if (stageIdIndex > 0) {
            if (stageIdIndex > dateIndex) {
                dateIndex += 1;
            }
            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);
        }
        if (dateIndex > 0) {
            this.query.splice(0, 0, this.query.splice(dateIndex, 1)[0]);
        }
        await super._notify(...arguments);
    }

}

return __exports;
});
;

/******************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_view.js  *
*  Lines: 25                                                                  *
******************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_view', ['@project/views/burndown_chart/burndown_chart_model', '@web/views/graph/graph_view', '@web/core/registry', '@project/views/burndown_chart/burndown_chart_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { BurndownChartModel } = require("@project/views/burndown_chart/burndown_chart_model");
const { graphView } = require("@web/views/graph/graph_view");
const { registry } = require("@web/core/registry");
const { BurndownChartSearchModel } = require("@project/views/burndown_chart/burndown_chart_search_model");

const viewRegistry = registry.category("views");

const burndownChartGraphView = {
  ...graphView,
  buttonTemplate: "project.BurndownChartView.Buttons",
  hideCustomGroupBy: true,
  Model: BurndownChartModel,
  searchMenuTypes: graphView.searchMenuTypes.filter(menuType => menuType !== "comparison"),
  SearchModel: BurndownChartSearchModel,
};

viewRegistry.add("burndown_chart", burndownChartGraphView);

return __exports;
});
;

/**************************************************************
*  Filepath: /web_map/static/src/map_view/map_arch_parser.js  *
*  Lines: 79                                                  *
**************************************************************/
odoo.define('@web_map/map_view/map_arch_parser', ['@web/core/utils/arrays', '@web/core/utils/strings', '@web/core/utils/xml'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { unique } = require("@web/core/utils/arrays");
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");

const MapArchParser = __exports.MapArchParser = class MapArchParser {
    parse(arch) {
        const archInfo = {
            fieldNames: [],
            fieldNamesMarkerPopup: [],
        };

        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "map":
                    this.visitMap(node, archInfo);
                    break;
                case "field":
                    this.visitField(node, archInfo);
                    break;
            }
        });

        archInfo.fieldNames = unique(archInfo.fieldNames);
        archInfo.fieldNamesMarkerPopup = unique(archInfo.fieldNamesMarkerPopup);

        return archInfo;
    }

    visitMap(node, archInfo) {
        archInfo.resPartnerField = node.getAttribute("res_partner");
        archInfo.fieldNames.push(archInfo.resPartnerField);

        if (node.hasAttribute("limit")) {
            archInfo.limit = parseInt(node.getAttribute("limit"), 10);
        }
        if (node.hasAttribute("panel_title")) {
            archInfo.panelTitle = node.getAttribute("panel_title");
        }
        if (node.hasAttribute("routing")) {
            archInfo.routing = exprToBoolean(node.getAttribute("routing"));
        }
        if (node.hasAttribute("hide_title")) {
            archInfo.hideTitle = exprToBoolean(node.getAttribute("hide_title"));
        }
        if (node.hasAttribute("hide_address")) {
            archInfo.hideAddress = exprToBoolean(node.getAttribute("hide_address"));
        }
        if (node.hasAttribute("hide_name")) {
            archInfo.hideName = exprToBoolean(node.getAttribute("hide_name"));
        }
        if (!archInfo.hideName) {
            archInfo.fieldNames.push("display_name");
        }
        if (node.hasAttribute("default_order")) {
            archInfo.defaultOrder = {
                name: node.getAttribute("default_order"),
                asc: true,
            };
        }
        if (node.hasAttribute("allow_resequence")) {
            archInfo.allowResequence = exprToBoolean(node.getAttribute("allow_resequence"));
        }
    }
    visitField(node, params) {
        params.fieldNames.push(node.getAttribute("name"));
        params.fieldNamesMarkerPopup.push({
            fieldName: node.getAttribute("name"),
            string: node.getAttribute("string"),
        });
    }
}

return __exports;
});
;

/*************************************************************
*  Filepath: /web_map/static/src/map_view/map_controller.js  *
*  Lines: 105                                                *
*************************************************************/
odoo.define('@web_map/map_view/map_controller', ['@web/core/l10n/translation', '@web/core/assets', '@web/core/utils/hooks', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/layout', '@web/search/pager_hook', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { loadJS, loadCSS } = require("@web/core/assets");
const { useService } = require("@web/core/utils/hooks");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { Layout } = require("@web/search/layout");
const { usePager } = require("@web/search/pager_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, onWillUnmount, onWillStart } = require("@odoo/owl");

const MapController = __exports.MapController = class MapController extends Component {
    static template = "web_map.MapView";
    static components = {
        Layout,
        SearchBar,
        CogMenu,
    };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.action = useService("action");

        /** @type {typeof MapModel} */
        const Model = this.props.Model;
        const model = useModelWithSampleData(Model, this.props.modelParams);
        this.model = model;

        onWillUnmount(() => {
            this.model.stopFetchingCoordinates();
        });

        useSetupAction({
            getLocalState: () => {
                return this.model.metaData;
            },
        });

        onWillStart(() =>
            Promise.all([
                loadJS("/web_map/static/lib/leaflet/leaflet.js"),
                loadCSS("/web_map/static/lib/leaflet/leaflet.css"),
            ])
        );

        usePager(() => {
            return {
                offset: this.model.metaData.offset,
                limit: this.model.metaData.limit,
                total: this.model.data.count,
                onUpdate: ({ offset, limit }) => this.model.load({ offset, limit }),
            };
        });
        this.searchBarToggler = useSearchBarToggler();
    }

    /**
     * @returns {any}
     */
    get rendererProps() {
        return {
            model: this.model,
            onMarkerClick: this.openRecords.bind(this),
        };
    }

    /**
     * Redirects to views when clicked on open button in marker popup.
     *
     * @param {number[]} ids
     */
    openRecords(ids) {
        if (ids.length > 1) {
            this.action.doAction({
                type: "ir.actions.act_window",
                name: this.env.config.getDisplayName() || _t("Untitled"),
                views: [
                    [false, "list"],
                    [false, "form"],
                ],
                res_model: this.props.resModel,
                domain: [["id", "in", ids]],
            });
        } else {
            this.action.switchView("form", { resId: ids[0] });
        }
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web_map/static/src/map_view/map_model.js  *
*  Lines: 699                                           *
********************************************************/
odoo.define('@web_map/map_view/map_model', ['@web/core/l10n/translation', '@web/model/model', '@web/session', '@web/model/relational_model/utils', '@web/core/browser/browser', '@web/core/l10n/dates', '@web/core/utils/concurrency'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { Model } = require("@web/model/model");
const { session } = require("@web/session");
const { resequence } = require("@web/model/relational_model/utils");
const { browser } = require("@web/core/browser/browser");
const { formatDateTime, parseDate, parseDateTime } = require("@web/core/l10n/dates");
const { KeepLast } = require("@web/core/utils/concurrency");

const DATE_GROUP_FORMATS = {
    year: "yyyy",
    quarter: "'Q'q yyyy",
    month: "MMMM yyyy",
    week: "'W'WW yyyy",
    day: "dd MMM yyyy",
};

const MapModel = __exports.MapModel = class MapModel extends Model {
    setup(params, { notification, http }) {
        this.notification = notification;
        this.http = http;

        this.metaData = {
            ...params,
            mapBoxToken: session.map_box_token || "",
        };

        this.data = {
            count: 0,
            fetchingCoordinates: false,
            groupByKey: false,
            isGrouped: false,
            numberOfLocatedRecords: 0,
            partners: {},
            partnerToCache: [],
            recordGroups: [],
            records: [],
            routes: [],
            routingError: null,
            shouldUpdatePosition: true,
            useMapBoxAPI: !!this.metaData.mapBoxToken,
        };

        this.coordinateFetchingTimeoutHandle = undefined;
        this.shouldFetchCoordinates = false;
        this.keepLast = new KeepLast();
    }
    /**
     * @param {any} params
     * @returns {Promise<void>}
     */
    async load(params) {
        if (this.coordinateFetchingTimeoutHandle !== undefined) {
            this.stopFetchingCoordinates();
        }
        const metaData = {
            ...this.metaData,
            ...params,
        };

        // remove the properties fields from the group by
        metaData.groupBy = (metaData.groupBy || []).filter((groupBy) => {
            // properties fields are in the form `[propert_field_name].[property_entry_key]`
            const [fieldName] = groupBy.split(".");
            const field = metaData.fields[fieldName];
            return field?.type !== "properties";
        });

        this.data = await this._fetchData(metaData);
        this.metaData = metaData;

        this.notify();
    }
    /**
     * Tells the model to stop fetching coordinates.
     * In OSM mode, the model starts to fetch coordinates once every second after the
     * model has loaded.
     * This fetching has to be done every second if we don't want to be banned from OSM.
     * There are typically two cases when we need to stop fetching:
     * - when component is about to be unmounted because the request is bound to
     *   the component and it will crash if we do so.
     * - when calling the `load` method as it will start fetching new coordinates.
     */
    stopFetchingCoordinates() {
        browser.clearTimeout(this.coordinateFetchingTimeoutHandle);
        this.coordinateFetchingTimeoutHandle = undefined;
        this.shouldFetchCoordinates = false;
    }

    get canResequence() {
        return (
            this.metaData.defaultOrder &&
            !this.metaData.fields[this.metaData.defaultOrder.name].readonly &&
            this.metaData.fields[this.metaData.defaultOrder.name].type === "integer" &&
            this.metaData.allowResequence &&
            !this.metaData.groupBy?.length
        );
    }

    /**
     * Resequence the records in `this.data.records` such that the record with the id
     * `movedRecordId` is moved after the record with the id `targetRecordId`
     * @param {Number} movedRecordId
     * @param {Number} targetRecordId
     */
    async resequence(movedId, targetId) {
        const fieldName = this.metaData.defaultOrder.name;
        const asc = this.metaData.defaultOrder.asc;
        const resequenceProm = resequence({
            records: this.data.records,
            resModel: this.metaData.resModel,
            movedId,
            targetId,
            fieldName,
            asc,
            context: this.metaData.context,
            orm: this.orm,
        });
        // the resequence method modifies this.data.records before the resequence backend call
        // we need to notify after the synchronous record change
        this.notify();
        const resequencedRecords = await resequenceProm;
        if (resequencedRecords) {
            for (const resequencedRecord of resequencedRecords) {
                const record = this.data.records.find((r) => r.id === resequencedRecord.id);
                record[fieldName] = resequencedRecord[fieldName];
            }
            await this._updatePartnerCoordinate(this.metaData, this.data);
            this.notify();
        }
    }

    //----------------------------------------------------------------------
    // Protected
    //----------------------------------------------------------------------

    /**
     * Adds the corresponding partner to a record.
     *
     * @protected
     */
    _addPartnerToRecord(metaData, data) {
        for (const record of data.records) {
            if (metaData.resModel === "res.partner" && metaData.resPartnerField === "id") {
                record.partner = data.partners[record.id];
            } else {
                record.partner = data.partners[record[metaData.resPartnerField].id];
            }
            data.numberOfLocatedRecords++;
        }
    }

    /**
     * The partner's coordinates should be between -90 <= latitude <= 90 and -180 <= longitude <= 180.
     *
     * @protected
     * @param {Object} partner
     * @param {number} partner.partner_latitude latitude of the partner
     * @param {number} partner.partner_longitude longitude of the partner
     * @returns {boolean}
     */
    _checkCoordinatesValidity(partner) {
        if (
            partner.partner_latitude &&
            partner.partner_longitude &&
            partner.partner_latitude >= -90 &&
            partner.partner_latitude <= 90 &&
            partner.partner_longitude >= -180 &&
            partner.partner_longitude <= 180
        ) {
            return true;
        }
        return false;
    }

    /**
     * Handles the case of an empty map.
     * Handles the case where the model is res_partner.
     * Fetches the records according to the model given in the arch.
     * If the records has no partner_id field it is sliced from the array.
     *
     * @protected
     * @params {any} metaData
     * @return {Promise<any>}
     */
    async _fetchData(metaData) {
        const data = {
            count: 0,
            fetchingCoordinates: false,
            groupByKey: metaData.groupBy.length ? metaData.groupBy[0] : false,
            isGrouped: metaData.groupBy.length > 0,
            numberOfLocatedRecords: 0,
            partners: {},
            partnerToCache: [],
            recordGroups: [],
            records: [],
            routes: [],
            routingError: null,
            shouldUpdatePosition: true,
            useMapBoxAPI: !!metaData.mapBoxToken,
        };

        //case of empty map
        if (!metaData.resPartnerField) {
            data.recordGroups = [];
            data.records = [];
            data.routes = [];
            return this.keepLast.add(Promise.resolve(data));
        }
        const results = await this.keepLast.add(this._fetchRecordData(metaData, data));

        const datetimeFields = metaData.fieldNames.filter(
            (name) => metaData.fields[name].type == "datetime"
        );
        for (const record of results.records) {
            // convert date fields from UTC to local timezone
            for (const field of datetimeFields) {
                if (record[field]) {
                    const dateUTC = luxon.DateTime.fromFormat(
                        record[field],
                        "yyyy-MM-dd HH:mm:ss",
                        { zone: "UTC" }
                    );
                    record[field] = formatDateTime(dateUTC, { format: "yyyy-MM-dd HH:mm:ss" });
                }
            }
        }

        data.records = results.records;
        data.count = results.length;
        if (data.isGrouped) {
            data.recordGroups = await this._getRecordGroups(metaData, data);
        } else {
            data.recordGroups = [];
        }

        if (metaData.resModel === "res.partner" && metaData.resPartnerField === "id") {
            for (const record of data.records) {
                if (!data.partners[record.id]) {
                    data.partners[record.id] = { ...record };
                }
            }
        } else {
            for (const record of data.records) {
                const partner = record[metaData.resPartnerField];
                if (partner && !data.partners[partner.id]) {
                    data.partners[partner.id] = partner;
                }
            }
        }
        this._addPartnerToRecord(metaData, data);
        await this._updatePartnerCoordinate(metaData, data);
        return data;
    }

    _getRecordSpecification(metaData, data) {
        const fieldNames = data.groupByKey
            ? metaData.fieldNames.concat(data.groupByKey.split(":")[0])
            : metaData.fieldNames;
        const specification = {};
        const fieldsToAdd = {
            contact_address_complete: {},
            partner_latitude: {},
            partner_longitude: {},
        };
        for (const fieldName of fieldNames) {
            specification[fieldName] = {};
            if (fieldName === "id" && metaData.resPartnerField === "id") {
                Object.assign(specification, fieldsToAdd);
            } else if (
                ["many2one", "one2many", "many2many"].includes(metaData.fields[fieldName].type)
            ) {
                specification[fieldName].fields = { display_name: {} };
                if (fieldName === metaData.resPartnerField) {
                    Object.assign(specification[fieldName].fields, fieldsToAdd);
                }
            }
        }
        return specification;
    }

    /**
     * Fetch the records for a given model.
     *
     * @protected
     * @returns {Promise}
     */
    _fetchRecordData(metaData, data) {
        const specification = this._getRecordSpecification(metaData, data);
        const orderBy = [];
        if (metaData.defaultOrder) {
            orderBy.push(metaData.defaultOrder.name);
            if (metaData.defaultOrder.asc) {
                orderBy.push("ASC");
            }
        }
        return this.orm.webSearchRead(metaData.resModel, metaData.domain, {
            specification,
            limit: metaData.limit,
            offset: metaData.offset,
            order: orderBy.join(" "),
            context: metaData.context,
        });
    }

    /**
     * This function convert the addresses to coordinates using the mapbox API.
     *
     * @protected
     * @param {Object} record this object contains the record fetched from the database.
     * @returns {Promise} result.query contains the query the the api received
     *      result.features contains results in descendant order of relevance
     */
    _fetchCoordinatesFromAddressMB(metaData, data, record) {
        const address = encodeURIComponent(record.contact_address_complete);
        const token = metaData.mapBoxToken;
        const encodedUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json?access_token=${token}&cachebuster=1552314159970&autocomplete=true`;
        return this.http.get(encodedUrl);
    }

    /**
     * This function convert the addresses to coordinates using the openStreetMap api.
     *
     * @protected
     * @param {Object} record this object contains the record fetched from the database.
     * @returns {Promise} result is an array that contains the result in descendant order of relevance
     *      result[i].lat is the latitude of the converted address
     *      result[i].lon is the longitude of the converted address
     *      result[i].importance is a number that the relevance of the result the closer the number is to one the best it is.
     */
    _fetchCoordinatesFromAddressOSM(metaData, data, record) {
        const address = encodeURIComponent(record.contact_address_complete.replace("/", " "));
        const encodedUrl = `https://nominatim.openstreetmap.org/search?q=${address}&format=jsonv2`;
        return this.http.get(encodedUrl);
    }

    /**
     * Fetch the route from the mapbox api.
     *
     * @protected
     * @returns {Promise}
     *      results.geometry.legs[i] contains one leg (i.e: the trip between two markers).
     *      results.geometry.legs[i].steps contains the sets of coordinates to follow to reach a point from an other.
     *      results.geometry.legs[i].distance: the distance in meters to reach the destination
     *      results.geometry.legs[i].duration the duration of the leg
     *      results.geometry.coordinates contains the sets of coordinates to go from the first to the last marker without the notion of waypoint
     */
    _fetchRoute(metaData, data) {
        const coordinatesParam = data.records
            .filter(
                (record) =>
                    record.partner &&
                    record.partner.partner_latitude &&
                    record.partner.partner_longitude
            )
            .map(({ partner }) => `${partner.partner_longitude},${partner.partner_latitude}`);
        const address = encodeURIComponent(coordinatesParam.join(";"));
        const token = metaData.mapBoxToken;
        const encodedUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${address}?access_token=${token}&steps=true&geometries=geojson`;
        return this.http.get(encodedUrl);
    }

    /**
     * Converts a MapBox error message into a custom translatable one.
     *
     * @protected
     * @param {string} message
     */
    _getErrorMessage(message) {
        const ERROR_MESSAGES = {
            "Too many coordinates; maximum number of coordinates is 25": _t(
                "Too many routing points (maximum 25)"
            ),
            "Route exceeds maximum distance limitation": _t(
                "Some routing points are too far apart"
            ),
            "Too Many Requests": _t("Too many requests, try again in a few minutes"),
        };
        return ERROR_MESSAGES[message];
    }

    _getEmptyGroupLabel(fieldName) {
        return _t("None");
    }

    /**
     * @protected
     * @returns {Object} the fetched records grouped by the groupBy field.
     */
    async _getRecordGroups(metaData, data) {
        const [fieldName, subGroup] = data.groupByKey.split(":");
        const fieldType = metaData.fields[fieldName].type;
        const groups = {};
        function addToGroup(id, name, record) {
            if (!groups[id]) {
                groups[id] = {
                    name,
                    records: [],
                };
            }
            groups[id].records.push(record);
        }
        for (const record of data.records) {
            const value = record[fieldName];
            let id, name;
            if (["one2many", "many2many"].includes(fieldType)) {
                if (value.length) {
                    for (const r of value) {
                        addToGroup(r.id, r.display_name, record);
                    }
                } else {
                    id = name = this._getEmptyGroupLabel(fieldName);
                    addToGroup(id, name, record);
                }
            } else {
                if (["date", "datetime"].includes(fieldType) && value) {
                    const date = fieldType === "date" ? parseDate(value) : parseDateTime(value);
                    id = name = date.toFormat(DATE_GROUP_FORMATS[subGroup]);
                } else if (fieldType === "boolean") {
                    id = name = value ? _t("Yes") : _t("No");
                } else if (fieldType === "selection") {
                    const selected = metaData.fields[fieldName].selection.find(
                        (o) => o[0] === value
                    );
                    id = name = selected ? selected[1] : value;
                } else if (fieldType === "many2one" && value) {
                    id = value.id;
                    name = value.display_name;
                } else {
                    id = value;
                    name = value;
                }
                if (!id && !name) {
                    id = name = this._getEmptyGroupLabel(fieldName);
                }
                addToGroup(id, name, record);
            }
        }
        return groups;
    }

    /**
     * Handles the case where the selected api is MapBox.
     * Iterates on all the partners and fetches their coordinates when they're not set.
     *
     * @protected
     * @return {Promise} if there's more than 2 located records and the routing option is activated it returns a promise that fetches the route
     *      resultResult is an object that contains the computed route
     *      or if either of these conditions are not respected it returns an empty promise
     */
    _maxBoxAPI(metaData, data) {
        const promises = [];
        for (const partner of Object.values(data.partners)) {
            if (
                partner.contact_address_complete &&
                (!partner.partner_latitude || !partner.partner_longitude)
            ) {
                promises.push(
                    this._fetchCoordinatesFromAddressMB(metaData, data, partner).then(
                        (coordinates) => {
                            if (coordinates.features.length) {
                                partner.partner_longitude = parseFloat(
                                    coordinates.features[0].geometry.coordinates[0]
                                );
                                partner.partner_latitude = parseFloat(
                                    coordinates.features[0].geometry.coordinates[1]
                                );
                                data.partnerToCache.push(partner);
                            }
                        }
                    )
                );
            } else if (!this._checkCoordinatesValidity(partner)) {
                partner.partner_latitude = undefined;
                partner.partner_longitude = undefined;
            }
        }
        return Promise.all(promises).then(() => {
            data.routes = [];
            if (data.numberOfLocatedRecords > 1 && metaData.routing && !data.groupByKey) {
                return this._fetchRoute(metaData, data).then((routeResult) => {
                    if (routeResult.routes) {
                        data.routes = routeResult.routes;
                    } else {
                        data.routingError = this._getErrorMessage(routeResult.message);
                    }
                });
            } else {
                return Promise.resolve();
            }
        });
    }

    /**
     * Handles the displaying of error message according to the error.
     *
     * @protected
     * @param {Object} err contains the error returned by the requests
     * @param {number} err.status contains the status_code of the failed http request
     */
    _mapBoxErrorHandling(metaData, data, err) {
        switch (err.status) {
            case 401:
                this.notification.add(
                    _t(
                        "The view has switched to another provider but functionalities will be limited"
                    ),
                    {
                        title: _t("Token invalid"),
                        type: "danger",
                    }
                );
                break;
            case 403:
                this.notification.add(
                    _t(
                        "The view has switched to another provider but functionalities will be limited"
                    ),
                    {
                        title: _t("Unauthorized connection"),
                        type: "danger",
                    }
                );
                break;
            case 422: // Max. addresses reached
            case 429: // Max. requests reached
                data.routingError = this._getErrorMessage(err.responseJSON.message);
                break;
            case 500:
                this.notification.add(
                    _t(
                        "The view has switched to another provider but functionalities will be limited"
                    ),
                    {
                        title: _t("MapBox servers unreachable"),
                        type: "danger",
                    }
                );
        }
    }

    /**
     * Notifies the fetched coordinates to server and controller.
     *
     * @protected
     */
    _notifyFetchedCoordinate(metaData, data) {
        this._writeCoordinatesUsers(metaData, data);
        data.shouldUpdatePosition = false;
        this.notify();
    }

    /**
     * Calls (without awaiting) _openStreetMapAPIAsync with a delay of 1000ms
     * to not get banned from openstreetmap's server.
     *
     * Tests should patch this function to wait for coords to be fetched.
     *
     * @see _openStreetMapAPIAsync
     * @protected
     * @return {Promise}
     */
    _openStreetMapAPI(metaData, data) {
        this._openStreetMapAPIAsync(metaData, data);
        return Promise.resolve();
    }
    /**
     * Handles the case where the selected api is open street map.
     * Iterates on all the partners and fetches their coordinates when they're not set.
     *
     * @protected
     * @returns {Promise}
     */
    _openStreetMapAPIAsync(metaData, data) {
        // Group partners by address to reduce address list
        const addressPartnerMap = new Map();
        for (const partner of Object.values(data.partners)) {
            if (
                partner.contact_address_complete &&
                (!partner.partner_latitude || !partner.partner_longitude)
            ) {
                if (!addressPartnerMap.has(partner.contact_address_complete)) {
                    addressPartnerMap.set(partner.contact_address_complete, []);
                }
                addressPartnerMap.get(partner.contact_address_complete).push(partner);
                partner.fetchingCoordinate = true;
            } else if (!this._checkCoordinatesValidity(partner)) {
                partner.partner_latitude = undefined;
                partner.partner_longitude = undefined;
            }
        }

        // `fetchingCoordinates` is used to display the "fetching banner"
        // We need to check if there are coordinates to fetch before reload the
        // view to prevent flickering
        data.fetchingCoordinates = addressPartnerMap.size > 0;
        this.shouldFetchCoordinates = true;
        const fetch = async () => {
            const partnersList = Array.from(addressPartnerMap.values());
            for (let i = 0; i < partnersList.length; i++) {
                await new Promise((resolve) => {
                    this.coordinateFetchingTimeoutHandle = browser.setTimeout(
                        resolve,
                        this.constructor.COORDINATE_FETCH_DELAY
                    );
                });
                if (!this.shouldFetchCoordinates) {
                    return;
                }
                const partners = partnersList[i];
                try {
                    const coordinates = await this._fetchCoordinatesFromAddressOSM(
                        metaData,
                        data,
                        partners[0]
                    );
                    if (!this.shouldFetchCoordinates) {
                        return;
                    }
                    if (coordinates.length) {
                        for (const partner of partners) {
                            partner.partner_longitude = parseFloat(coordinates[0].lon);
                            partner.partner_latitude = parseFloat(coordinates[0].lat);
                            data.partnerToCache.push(partner);
                        }
                    }
                    for (const partner of partners) {
                        partner.fetchingCoordinate = false;
                    }
                    data.fetchingCoordinates = i < partnersList.length - 1;
                    this._notifyFetchedCoordinate(metaData, data);
                } catch {
                    for (const partner of Object.values(data.partners)) {
                        partner.fetchingCoordinate = false;
                    }
                    data.fetchingCoordinates = false;
                    this.shouldFetchCoordinates = false;
                    this.notification.add(
                        _t("OpenStreetMap's request limit exceeded, try again later."),
                        { type: "danger" }
                    );
                    this.notify();
                }
            }
        };
        return fetch();
    }

    /**
     * if the token is set it uses the mapBoxApi to fetch address and route
     * if not is uses the openstreetmap api to fetch the address.
     *
     * @protected
     * @returns {Promise}
     */
    async _updatePartnerCoordinate(metaData, data) {
        if (data.useMapBoxAPI) {
            return this.keepLast
                .add(this._maxBoxAPI(metaData, data))
                .then(() => {
                    this._writeCoordinatesUsers(metaData, data);
                })
                .catch((err) => {
                    this._mapBoxErrorHandling(metaData, data, err);
                    data.useMapBoxAPI = false;
                    return this._openStreetMapAPI(metaData, data);
                });
        } else {
            return this._openStreetMapAPI(metaData, data).then(() => {
                this._writeCoordinatesUsers(metaData, data);
            });
        }
    }
    /**
     * Writes partner_longitude and partner_latitude of the res.partner model.
     *
     * @protected
     * @return {Promise}
     */
    async _writeCoordinatesUsers(metaData, data) {
        const partners = data.partnerToCache;
        data.partnerToCache = [];
        if (partners.length) {
            await this.orm.call("res.partner", "update_latitude_longitude", [partners], {
                context: metaData.context,
            });
        }
    }
}

MapModel.services = ["notification", "http"];
MapModel.COORDINATE_FETCH_DELAY = 1000;

return __exports;
});
;

/***********************************************************
*  Filepath: /web_map/static/src/map_view/map_renderer.js  *
*  Lines: 474                                              *
***********************************************************/
odoo.define('@web_map/map_view/map_renderer', ['@web/core/l10n/translation', '@web/core/utils/render', '@web/core/utils/concurrency', '@odoo/owl', '@web/core/utils/sortable_owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
/*global L*/

const { renderToString } = require("@web/core/utils/render");
const { delay } = require("@web/core/utils/concurrency");

const {
    Component,
    onWillUnmount,
    onWillUpdateProps,
    useEffect,
    useRef,
    useState,
} = require("@odoo/owl");

const { useSortable } = require("@web/core/utils/sortable_owl");

const apiTilesRouteWithToken =
    "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}";
const apiTilesRouteWithoutToken = "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png";

const colors = [
    "#F06050",
    "#6CC1ED",
    "#F7CD1F",
    "#814968",
    "#30C381",
    "#D6145F",
    "#475577",
    "#F4A460",
    "#EB7E7F",
    "#2C8397",
];

const mapTileAttribution = `
     <a href="https://www.mapbox.com/about/maps/">Mapbox</a>
     <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>
    <strong>
        <a href="https://www.mapbox.com/map-feedback/" target="_blank">
            Improve this map
        </a>
    </strong>`;

const MapRenderer = __exports.MapRenderer = class MapRenderer extends Component {
    static template = "web_map.MapRenderer";
    static props = {
        model: Object,
        onMarkerClick: Function,
    };

    setup() {
        this.leafletMap = null;
        this.markers = [];
        this.polylines = [];
        this.mapContainerRef = useRef("mapContainer");
        this.state = useState({
            closedGroupIds: [],
            expendedPinList: false,
        });
        this.nextId = 1;

        useEffect(
            () => {
                this.leafletMap = L.map(this.mapContainerRef.el, {
                    maxBounds: [L.latLng(180, -180), L.latLng(-180, 180)],
                });
                this.leafletMap.attributionControl.setPrefix(
                    '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">Leaflet</a>'
                );
                L.tileLayer(this.apiTilesRoute, {
                    attribution: mapTileAttribution,
                    tileSize: 512,
                    zoomOffset: -1,
                    minZoom: 2,
                    maxZoom: 19,
                    id: "mapbox/streets-v11",
                    accessToken: this.props.model.metaData.mapBoxToken,
                }).addTo(this.leafletMap);
            },
            () => []
        );
        useEffect(() => {
            this.updateMap();
        });

        this.pinListRef = useRef("pinList");
        useSortable({
            enable: () => this.props.model.canResequence,
            ref: this.pinListRef,
            elements: ".o-map-renderer--pin-located",
            handle: ".o_row_handle",
            onDrop: async (params) => {
                const rowId = parseInt(params.element.dataset.id);
                const previousRowId = parseInt(params.previous?.dataset?.id) || null;
                await this.props.model.resequence(rowId, previousRowId);
            },
        });

        onWillUpdateProps(this.onWillUpdateProps);
        onWillUnmount(this.onWillUnmount);
    }
    /**
     * Update group opened/closed state.
     */
    async onWillUpdateProps(nextProps) {
        if (this.props.model.data.groupByKey !== nextProps.model.data.groupByKey) {
            this.state.closedGroupIds = [];
        }
    }
    /**
     * Remove map and the listeners on its markers and routes.
     */
    onWillUnmount() {
        this.removeMarkers();
        this.removeRoutes();
        if (this.leafletMap) {
            this.leafletMap.remove();
        }
    }

    /**
     * Return the route to the tiles api with or without access token.
     *
     * @returns {string}
     */
    get apiTilesRoute() {
        return this.props.model.data.useMapBoxAPI
            ? apiTilesRouteWithToken
            : apiTilesRouteWithoutToken;
    }

    /**
     * If there's located records, adds the corresponding marker on the map.
     * Binds events to the created markers.
     */
    addMarkers() {
        this.removeMarkers();

        const markersInfo = {};
        let records = this.props.model.data.records;
        if (this.props.model.data.isGrouped) {
            records = Object.entries(this.props.model.data.recordGroups)
                .filter(([key]) => !this.state.closedGroupIds.includes(key))
                .flatMap(([groupId, value]) => value.records.map((elem) => ({ ...elem, groupId })));
        }

        const pinInSamePlace = {};
        for (const record of records) {
            const partner = record.partner;
            if (partner && partner.partner_latitude && partner.partner_longitude) {
                const lat_long = `${partner.partner_latitude}-${partner.partner_longitude}`;
                const group = this.props.model.data.recordGroups ? `-${record.groupId}` : "";
                const key = `${lat_long}${group}`;
                if (key in markersInfo) {
                    markersInfo[key].record = record;
                    markersInfo[key].ids.push(record.id);
                } else {
                    pinInSamePlace[lat_long] = ++pinInSamePlace[lat_long] || 0;
                    markersInfo[key] = {
                        record: record,
                        ids: [record.id],
                        pinInSamePlace: pinInSamePlace[lat_long],
                    };
                }
            }
        }

        for (const markerInfo of Object.values(markersInfo)) {
            const params = {
                count: markerInfo.ids.length,
                isMulti: markerInfo.ids.length > 1,
                number: this.props.model.data.records.indexOf(markerInfo.record) + 1,
                numbering: this.props.model.metaData.numbering,
            };

            if (this.props.model.data.isGrouped) {
                const groupId = markerInfo.record.groupId;
                params.color = this.getGroupColor(groupId);
                params.number =
                    this.props.model.data.recordGroups[groupId].records.findIndex((record) => {
                        return record.id === markerInfo.record.id;
                    }) + 1;
            }

            // Icon creation
            const iconInfo = {
                className: "o-map-renderer--marker",
                html: renderToString("web_map.marker", params),
            };

            const offset = markerInfo.pinInSamePlace * 0.000025;
            // Attach marker with icon and popup
            const marker = L.marker(
                [
                    markerInfo.record.partner.partner_latitude + offset,
                    markerInfo.record.partner.partner_longitude - offset,
                ],
                { icon: L.divIcon(iconInfo) }
            );
            marker.addTo(this.leafletMap);
            marker.on("click", () => {
                this.createMarkerPopup(markerInfo, offset);
            });
            this.markers.push(marker);
        }
    }
    /**
     * If there are computed routes, create polylines and add them to the map.
     * each element of this.props.routeInfo[0].legs array represent the route between
     * two waypoints thus each of these must be a polyline.
     */
    addRoutes() {
        this.removeRoutes();
        if (!this.props.model.data.useMapBoxAPI || !this.props.model.data.routes.length) {
            return;
        }

        for (const leg of this.props.model.data.routes[0].legs) {
            const latLngs = [];
            for (const step of leg.steps) {
                for (const coordinate of step.geometry.coordinates) {
                    latLngs.push(L.latLng(coordinate[1], coordinate[0]));
                }
            }

            const polyline = L.polyline(latLngs, {
                color: "blue",
                weight: 5,
                opacity: 0.3,
            }).addTo(this.leafletMap);

            const polylines = this.polylines;
            polyline.on("click", function () {
                for (const polyline of polylines) {
                    polyline.setStyle({ color: "blue", opacity: 0.3 });
                }
                this.setStyle({ color: "darkblue", opacity: 1.0 });
            });
            this.polylines.push(polyline);
        }
    }
    /**
     * Create a popup for the specified marker.
     *
     * @param {Object} markerInfo
     * @param {Number} latLongOffset
     */
    createMarkerPopup(markerInfo, latLongOffset = 0) {
        const popupFields = this.getMarkerPopupFields(markerInfo);
        const partner = markerInfo.record.partner;
        const encodedAddress = encodeURIComponent(partner.contact_address_complete);
        const popupHtml = renderToString("web_map.markerPopup", {
            fields: popupFields,
            hasFormView: this.props.model.metaData.hasFormView,
            url: `https://www.google.com/maps/dir/?api=1&destination=${encodedAddress}`,
        });

        const popup = L.popup({ offset: [0, -30] })
            .setLatLng([
                partner.partner_latitude + latLongOffset,
                partner.partner_longitude - latLongOffset,
            ])
            .setContent(popupHtml)
            .openOn(this.leafletMap);

        const openBtn = popup
            .getElement()
            .querySelector("button.o-map-renderer--popup-buttons-open");
        if (openBtn) {
            openBtn.onclick = () => {
                this.props.onMarkerClick(markerInfo.ids);
            };
        }
        return popup;
    }
    /**
     * @param {Number} groupId
     */
    getGroupColor(groupId) {
        const index = Object.keys(this.props.model.data.recordGroups).indexOf(groupId);
        return colors[index % colors.length];
    }
    /**
     * Creates an array of latLng objects if there is located records.
     *
     * @returns {latLngBounds|boolean} objects containing the coordinates that
     *          allows all the records to be shown on the map or returns false
     *          if the records does not contain any located record.
     */
    getLatLng() {
        const tabLatLng = [];
        for (const record of this.props.model.data.records) {
            const partner = record.partner;
            if (partner && partner.partner_latitude && partner.partner_longitude) {
                tabLatLng.push(L.latLng(partner.partner_latitude, partner.partner_longitude));
            }
        }
        if (!tabLatLng.length) {
            return false;
        }
        return L.latLngBounds(tabLatLng);
    }
    /**
     * Get the fields' name and value to display in the popup.
     *
     * @param {Object} markerInfo
     * @returns {Object} value contains the value of the field and string
     *                   contains the value of the xml's string attribute
     */
    getMarkerPopupFields(markerInfo) {
        const record = markerInfo.record;
        const fieldsView = [];
        // Only display address in multi coordinates marker popup
        if (markerInfo.ids.length > 1) {
            if (!this.props.model.metaData.hideAddress) {
                fieldsView.push({
                    id: this.nextId++,
                    value: record.partner.contact_address_complete,
                    string: _t("Address"),
                });
            }
            return fieldsView;
        }
        if (!this.props.model.metaData.hideName) {
            fieldsView.push({
                id: this.nextId++,
                value: record.display_name,
                string: _t("Name"),
            });
        }
        if (!this.props.model.metaData.hideAddress) {
            fieldsView.push({
                id: this.nextId++,
                value: record.partner.contact_address_complete,
                string: _t("Address"),
            });
        }
        const fields = this.props.model.metaData.fields;
        for (const field of this.props.model.metaData.fieldNamesMarkerPopup) {
            if (record[field.fieldName]) {
                let value = record[field.fieldName];
                if (fields[field.fieldName].type === "many2one") {
                    value = record[field.fieldName].display_name;
                } else if (["one2many", "many2many"].includes(fields[field.fieldName].type)) {
                    value = record[field.fieldName]
                        ? record[field.fieldName].map((r) => r.display_name).join(", ")
                        : "";
                }
                fieldsView.push({
                    id: this.nextId++,
                    value,
                    string: field.string,
                });
            }
        }
        return fieldsView;
    }
    /**
     * @returns {string}
     */
    get googleMapUrl() {
        let url = "https://www.google.com/maps/dir/?api=1";
        if (this.props.model.data.records.length) {
            const allCoordinates = this.props.model.data.records.filter(
                ({ partner }) => partner && partner.partner_latitude && partner.partner_longitude
            );
            const uniqueCoordinates = allCoordinates.reduce((coords, { partner }) => {
                const coord = partner.partner_latitude + "," + partner.partner_longitude;
                if (!coords.includes(coord)) {
                    coords.push(coord);
                }
                return coords;
            }, []);
            if (uniqueCoordinates.length && this.props.model.metaData.routing) {
                // When routing is enabled, make last record the destination
                url += `&destination=${uniqueCoordinates.pop()}`;
            }
            if (uniqueCoordinates.length) {
                url += `&waypoints=${uniqueCoordinates.join("|")}`;
            }
        }
        return url;
    }
    /**
     * Remove the markers from the map and empty the markers array.
     */
    removeMarkers() {
        for (const marker of this.markers) {
            marker.off("click");
            this.leafletMap.removeLayer(marker);
        }
        this.markers = [];
    }
    /**
     * Remove the routes from the map and empty the the polyline array.
     */
    removeRoutes() {
        for (const polyline of this.polylines) {
            polyline.off("click");
            this.leafletMap.removeLayer(polyline);
        }
        this.polylines = [];
    }
    /**
     * Update position in the map, markers and routes.
     */
    updateMap() {
        if (this.props.model.data.shouldUpdatePosition) {
            const initialCoord = this.getLatLng();
            if (initialCoord) {
                this.leafletMap.flyToBounds(initialCoord, { animate: false });
            } else {
                this.leafletMap.fitWorld();
            }
            this.leafletMap.closePopup();
        }
        this.addMarkers();
        this.addRoutes();
    }

    /**
     * Center the map on a certain pin and open the popup linked to it.
     *
     * @param {Object} record
     */
    async centerAndOpenPin(record) {
        this.state.expendedPinList = false;
        // wait the next owl render to avoid marker popup create => destroy
        await delay(0);
        const popup = this.createMarkerPopup({
            record: record,
            ids: [record.id],
        });
        const px = this.leafletMap.project([
            record.partner.partner_latitude,
            record.partner.partner_longitude,
        ]);
        const popupHeight = popup.getElement().offsetHeight;
        px.y -= popupHeight / 2;
        const latlng = this.leafletMap.unproject(px);
        this.leafletMap.panTo(latlng, { animate: true });
    }
    /**
     * @param {Number} id
     */
    toggleGroup(id) {
        if (this.state.closedGroupIds.includes(id)) {
            const index = this.state.closedGroupIds.indexOf(id);
            this.state.closedGroupIds.splice(index, 1);
        } else {
            this.state.closedGroupIds.push(id);
        }
    }

    togglePinList() {
        this.state.expendedPinList = !this.state.expendedPinList;
    }

    get expendedPinList() {
        return this.env.isSmall ? this.state.expendedPinList : false;
    }

    get canDisplayPinList() {
        return !this.env.isSmall || this.expendedPinList;
    }
}

return __exports;
});
;

/*******************************************************
*  Filepath: /web_map/static/src/map_view/map_view.js  *
*  Lines: 62                                           *
*******************************************************/
odoo.define('@web_map/map_view/map_view', ['@web/core/l10n/translation', '@web/core/registry', '@web_map/map_view/map_arch_parser', '@web_map/map_view/map_model', '@web_map/map_view/map_controller', '@web_map/map_view/map_renderer'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { MapArchParser } = require("@web_map/map_view/map_arch_parser");
const { MapModel } = require("@web_map/map_view/map_model");
const { MapController } = require("@web_map/map_view/map_controller");
const { MapRenderer } = require("@web_map/map_view/map_renderer");

const mapView = __exports.mapView = {
    type: "map",
    Controller: MapController,
    Renderer: MapRenderer,
    Model: MapModel,
    ArchParser: MapArchParser,
    buttonTemplate: "web_map.MapView.Buttons",

    props: (genericProps, view, config) => {
        let modelParams = genericProps.state;
        if (!modelParams) {
            const { arch, resModel, fields, context } = genericProps;
            const parser = new view.ArchParser();
            const archInfo = parser.parse(arch);
            const views = config.views || [];
            modelParams = {
                allowResequence: archInfo.allowResequence || false,
                context: context,
                defaultOrder: archInfo.defaultOrder,
                fieldNames: archInfo.fieldNames,
                fieldNamesMarkerPopup: archInfo.fieldNamesMarkerPopup,
                fields: fields,
                hasFormView: views.some((view) => view[1] === "form"),
                hideAddress: archInfo.hideAddress || false,
                hideName: archInfo.hideName || false,
                hideTitle: archInfo.hideTitle || false,
                limit: archInfo.limit || 80,
                numbering: archInfo.routing || false,
                offset: 0,
                panelTitle: archInfo.panelTitle || config.getDisplayName() || _t("Items"),
                resModel: resModel,
                resPartnerField: archInfo.resPartnerField,
                routing: archInfo.routing || false,
            };
        }

        return {
            ...genericProps,
            Model: view.Model,
            modelParams,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

registry.category("views").add("map", mapView);

return __exports;
});
;

/*********************************************************
*  Filepath: /web_gantt/static/src/gantt_arch_parser.js  *
*  Lines: 351                                            *
*********************************************************/
odoo.define('@web_gantt/gantt_arch_parser', ['@web/core/l10n/dates', '@web/core/l10n/translation', '@web/core/py_js/py', '@web/core/utils/strings', '@web/core/utils/xml', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
const { getLocalYearAndWeek } = require("@web/core/l10n/dates");
const { _t } = require("@web/core/l10n/translation");
const { evaluateExpr } = require("@web/core/py_js/py");
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");
const { getActiveActions } = require("@web/views/utils");

const DECORATIONS = [
    "decoration-danger",
    "decoration-info",
    "decoration-secondary",
    "decoration-success",
    "decoration-warning",
];
const PARTS = { full: 1, half: 2, quarter: 4 };
const SCALES = {
    day: {
        // determines subcolumns
        cellPrecisions: { full: 60, half: 30, quarter: 15 },
        defaultPrecision: "full",
        time: "minute",
        unitDescription: _t("minutes"),

        // determines columns
        interval: "hour",
        minimalColumnWidth: 40,

        // determines column groups
        unit: "day",
        groupHeaderFormatter: (date) => date.toFormat("dd MMMM yyyy"),

        defaultRange: { unit: "day", count: 3 },
    },
    week: {
        cellPrecisions: { full: 24, half: 12 },
        defaultPrecision: "half",
        time: "hour",
        unitDescription: _t("hours"),

        interval: "day",
        minimalColumnWidth: 192,
        colHeaderFormatter: (date) => date.toFormat("dd"),

        unit: "week",
        groupHeaderFormatter: formatLocalWeekYear,

        defaultRange: { unit: "week", count: 3 },
    },
    week_2: {
        cellPrecisions: { full: 24, half: 12 },
        defaultPrecision: "half",
        time: "hour",
        unitDescription: _t("hours"),

        interval: "day",
        minimalColumnWidth: 96,
        colHeaderFormatter: (date) => date.toFormat("dd"),

        unit: "week",
        groupHeaderFormatter: formatLocalWeekYear,

        defaultRange: { unit: "week", count: 6 },
    },
    month: {
        cellPrecisions: { full: 24, half: 12 },
        defaultPrecision: "half",
        time: "hour",
        unitDescription: _t("hours"),

        interval: "day",
        minimalColumnWidth: 50,
        colHeaderFormatter: (date) => date.toFormat("dd"),

        unit: "month",
        groupHeaderFormatter: (date, env) => date.toFormat(env.isSmall ? "MMM yyyy" : "MMMM yyyy"),

        defaultRange: { unit: "month", count: 3 },
    },
    month_3: {
        cellPrecisions: { full: 24, half: 12 },
        defaultPrecision: "half",
        time: "hour",
        unitDescription: _t("hours"),

        interval: "day",
        minimalColumnWidth: 18,
        colHeaderFormatter: (date) => date.toFormat("dd"),

        unit: "month",
        groupHeaderFormatter: (date, env) => date.toFormat(env.isSmall ? "MMM yyyy" : "MMMM yyyy"),

        defaultRange: { unit: "month", count: 6 },
    },
    year: {
        cellPrecisions: { full: 1 },
        defaultPrecision: "full",
        time: "month",
        unitDescription: _t("months"),

        interval: "month",
        minimalColumnWidth: 60,
        colHeaderFormatter: (date, env) => date.toFormat(env.isSmall ? "MMM" : "MMMM"),

        unit: "year",
        groupHeaderFormatter: (date) => date.toFormat("yyyy"),

        defaultRange: { unit: "year", count: 1 },
    },
};

/**
 * Formats a date to a `'W'W kkkk` datetime string, in the user's locale settings.
 *
 * @param {Date|luxon.DateTime} date
 * @returns {string}
 */
function formatLocalWeekYear(date) {
    const { year, week } = getLocalYearAndWeek(date);
    return `W${week} ${year}`;
}

function getPreferedScaleId(scaleId, scales) {
    // we assume that scales is not empty
    if (scaleId in scales) {
        return scaleId;
    }
    const scaleIds = Object.keys(SCALES);
    const index = scaleIds.findIndex((id) => id === scaleId);
    for (let j = index - 1; j >= 0; j--) {
        const id = scaleIds[j];
        if (id in scales) {
            return id;
        }
    }
    for (let j = index + 1; j < scaleIds.length; j++) {
        const id = scaleIds[j];
        if (id in scales) {
            return id;
        }
    }
}

const RANGES = {
    day: { scaleId: "day", description: _t("Today") },
    week: { scaleId: "week", description: _t("This week") },
    month: { scaleId: "month", description: _t("This month") },
    quarter: { scaleId: "month_3", description: _t("This quarter") },
    year: { scaleId: "year", description: _t("This year") },
};

const GanttArchParser = __exports.GanttArchParser = class GanttArchParser {
    parse(arch) {
        let infoFromRootNode;
        const decorationFields = [];
        const popoverArchParams = {
            displayGenericButtons: true,
            bodyTemplate: null,
            footerTemplate: null,
        };

        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "gantt": {
                    infoFromRootNode = getInfoFromRootNode(node);
                    break;
                }
                case "field": {
                    const fieldName = node.getAttribute("name");
                    decorationFields.push(fieldName);
                    break;
                }
                case "templates": {
                    const body = node.querySelector("[t-name=gantt-popover]") || null;
                    if (body) {
                        popoverArchParams.bodyTemplate = body.cloneNode(true);
                        popoverArchParams.bodyTemplate.removeAttribute("t-name");
                        const footer = popoverArchParams.bodyTemplate.querySelector("footer");
                        if (footer) {
                            popoverArchParams.displayGenericButtons = false;
                            footer.remove();
                            const footerTemplate = new Document().createElement("t");
                            footerTemplate.append(...footer.children);
                            popoverArchParams.footerTemplate = footerTemplate;
                            const replace = footer.getAttribute("replace");
                            if (replace && !exprToBoolean(replace)) {
                                popoverArchParams.displayGenericButtons = true;
                            }
                        }
                    }
                }
            }
        });

        return {
            ...infoFromRootNode,
            decorationFields,
            popoverArchParams,
        };
    }
}

function getInfoFromRootNode(rootNode) {
    const attrs = {};
    for (const { name, value } of rootNode.attributes) {
        attrs[name] = value;
    }

    const { create: canCreate, delete: canDelete, edit: canEdit } = getActiveActions(rootNode);
    const canCellCreate = exprToBoolean(attrs.cell_create, true) && canCreate;
    const canPlan = exprToBoolean(attrs.plan, true) && canEdit;

    let consolidationMaxField;
    let consolidationMaxValue;
    const consolidationMax = attrs.consolidation_max ? evaluateExpr(attrs.consolidation_max) : {};
    if (Object.keys(consolidationMax).length > 0) {
        consolidationMaxField = Object.keys(consolidationMax)[0];
        consolidationMaxValue = consolidationMax[consolidationMaxField];
    }

    const consolidationParams = {
        excludeField: attrs.consolidation_exclude,
        field: attrs.consolidation,
        maxField: consolidationMaxField,
        maxValue: consolidationMaxValue,
    };

    const dependencyField = attrs.dependency_field || null;
    const dependencyEnabled = !!dependencyField;
    const dependencyInvertedField = attrs.dependency_inverted_field || null;

    const allowedScales = [];
    if (attrs.scales) {
        for (const key of attrs.scales.split(",")) {
            if (SCALES[key]) {
                allowedScales.push(key);
            }
        }
    }
    if (allowedScales.length === 0) {
        allowedScales.push(...Object.keys(SCALES));
    }

    let defaultScale = attrs.default_scale;
    if (defaultScale) {
        if (!allowedScales.includes(defaultScale) && SCALES[defaultScale]) {
            allowedScales.push(defaultScale);
        }
    } else if (allowedScales.includes("month")) {
        defaultScale = "month";
    } else {
        defaultScale = allowedScales[0];
    }

    // Cell precision
    const cellPrecisions = {};

    // precision = {'day': 'hour:half', 'week': 'day:half', 'month': 'day', 'year': 'month:quarter'}
    const precisionAttrs = attrs.precision ? evaluateExpr(attrs.precision) : {};
    for (const scaleId in SCALES) {
        if (precisionAttrs[scaleId]) {
            const precision = precisionAttrs[scaleId].split(":"); // hour:half
            // Note that precision[0] (which is the cell interval) is not
            // taken into account right now because it is no customizable.
            if (
                precision[1] &&
                Object.keys(SCALES[scaleId].cellPrecisions).includes(precision[1])
            ) {
                cellPrecisions[scaleId] = precision[1];
            }
        }
        cellPrecisions[scaleId] ||= SCALES[scaleId].defaultPrecision;
    }

    const scales = {};
    for (const scaleId of allowedScales) {
        const precision = cellPrecisions[scaleId];
        const referenceScale = SCALES[scaleId];
        scales[scaleId] = {
            ...referenceScale,
            cellPart: PARTS[precision],
            cellTime: referenceScale.cellPrecisions[precision],
            id: scaleId,
            unitDescription: referenceScale.unitDescription.toString(),
        };
        // protect SCALES content
        delete scales[scaleId].cellPrecisions;
    }

    const ranges = {};
    for (const rangeId in RANGES) {
        const referenceRange = RANGES[rangeId];
        const { groupHeaderFormatter } = SCALES[referenceRange.scaleId];
        ranges[rangeId] = {
            ...referenceRange,
            groupHeaderFormatter,
            id: rangeId,
            scaleId: getPreferedScaleId(referenceRange.scaleId, scales),
            description: referenceRange.description.toString(),
        };
    }

    let pillDecorations = null;
    for (const decoration of DECORATIONS) {
        if (decoration in attrs) {
            if (!pillDecorations) {
                pillDecorations = {};
            }
            pillDecorations[decoration] = attrs[decoration];
        }
    }

    return {
        canCellCreate,
        canCreate,
        canDelete,
        canEdit,
        canPlan,
        colorField: attrs.color,
        computePillDisplayName: !!attrs.pill_label,
        consolidationParams,
        createAction: attrs.on_create || null,
        dateStartField: attrs.date_start,
        dateStopField: attrs.date_stop,
        defaultGroupBy: attrs.default_group_by ? attrs.default_group_by.split(",") : [],
        defaultRange: attrs.default_range,
        defaultScale,
        dependencyEnabled,
        dependencyField,
        dependencyInvertedField,
        disableDrag: exprToBoolean(attrs.disable_drag_drop),
        displayMode: attrs.display_mode || "dense",
        displayTotalRow: exprToBoolean(attrs.total_row),
        displayUnavailability: exprToBoolean(attrs.display_unavailability),
        formViewId: attrs.form_view_id ? parseInt(attrs.form_view_id, 10) : false,
        offset: attrs.offset,
        pagerLimit: attrs.groups_limit ? parseInt(attrs.groups_limit, 10) : null,
        pillDecorations,
        progressBarFields: attrs.progress_bar ? attrs.progress_bar.split(",") : null,
        progressField: attrs.progress || null,
        ranges,
        scales,
        string: attrs.string || _t("Gantt View").toString(),
        thumbnails: attrs.thumbnails ? evaluateExpr(attrs.thumbnails) : {},
    };
}

return __exports;
});
;

/******************************************************
*  Filepath: /web_gantt/static/src/gantt_compiler.js  *
*  Lines: 25                                          *
******************************************************/
odoo.define('@web_gantt/gantt_compiler', ['@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
const { ViewCompiler } = require("@web/views/view_compiler");

const GanttCompiler = __exports.GanttCompiler = class GanttCompiler extends ViewCompiler {}
GanttCompiler.OWL_DIRECTIVE_WHITELIST = [
    ...ViewCompiler.OWL_DIRECTIVE_WHITELIST,
    "t-name",
    "t-esc",
    "t-out",
    "t-set",
    "t-value",
    "t-if",
    "t-else",
    "t-elif",
    "t-foreach",
    "t-as",
    "t-key",
    "t-att.*",
    "t-call",
];

return __exports;
});
;

/*******************************************************
*  Filepath: /web_gantt/static/src/gantt_connector.js  *
*  Lines: 300                                          *
*******************************************************/
odoo.define('@web_gantt/gantt_connector', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Component, onWillRender, useEffect, useRef } = require("@odoo/owl");

/**
 * @typedef {"error" | "warning"} ConnectorAlert
 * @typedef {`__connector__${number | "new"}`} ConnectorId
 * @typedef {import("./gantt_renderer").Point} Point
 *
 * @typedef ConnectorProps
 * @property {ConnectorId} id
 * @property {ConnectorAlert | null} alert
 * @property {boolean} highlighted
 * @property {boolean} displayButtons
 * @property {Point | () => Point | null} sourcePoint
 * @property {Point | () => Point | null} targetPoint
 *
 * @typedef {Object} PathInfo
 * @property {Point} sourceControlPoint
 * @property {Point} targetControlPoint
 * @property {Point} removeButtonPosition
 *
 * @typedef Point
 * @property {number} [x]
 * @property {number} [y]
 */

/**
 * Gets the stroke's rgba css string corresponding to the provided parameters for both the stroke and its
 * hovered state.
 *
 * @param {number} r [0, 255]
 * @param {number} g [0, 255]
 * @param {number} b [0, 255]
 * @return {{ stroke: string, hoveredStroke: string }} the css colors.
 */
__exports.getStrokeAndHoveredStrokeColor = getStrokeAndHoveredStrokeColor; function getStrokeAndHoveredStrokeColor(r, g, b) {
    return {
        color: `rgba(${r},${g},${b},0.5)`,
        highlightedColor: `rgba(${r},${g},${b},1)`,
    };
}

const COLORS = __exports.COLORS = {
    default: getStrokeAndHoveredStrokeColor(143, 143, 143),
    error: getStrokeAndHoveredStrokeColor(211, 65, 59),
    warning: getStrokeAndHoveredStrokeColor(236, 151, 31),
    outline: getStrokeAndHoveredStrokeColor(255, 255, 255),
};

/** @extends {Component<{ reactive: ConnectorProps }, any>} */
const GanttConnector = __exports.GanttConnector = class GanttConnector extends Component {
    static props = {
        reactive: {
            type: Object,
            shape: {
                id: String,
                alert: {
                    type: [{ value: "error" }, { value: "warning" }, { value: null }],
                    optional: true,
                },
                highlighted: { type: Boolean, optional: true },
                displayButtons: { type: Boolean, optional: true },
                sourcePoint: [
                    { value: null },
                    Function,
                    { type: Object, shape: { left: Number, top: Number } },
                ],
                targetPoint: [
                    { value: null },
                    Function,
                    { type: Object, shape: { left: Number, top: Number } },
                ],
            },
        },
        onLeftButtonClick: { type: Function, optional: true },
        onRemoveButtonClick: { type: Function, optional: true },
        onRightButtonClick: { type: Function, optional: true },
    };
    static defaultProps = {
        highlighted: false,
        displayButtons: false,
    };
    static template = "web_gantt.GanttConnector";

    rootRef = useRef("root");
    style = {
        hoverEaseWidth: 10,
        slackness: 0.9,
        stroke: { width: 2 },
        outlineStroke: { width: 1 },
    };

    get alert() {
        return this.props.reactive.alert;
    }

    get displayButtons() {
        return this.props.reactive.displayButtons;
    }

    get highlighted() {
        return this.props.reactive.highlighted;
    }

    get id() {
        return this.props.reactive.id;
    }

    get isNew() {
        return this.id.endsWith("new");
    }

    get sourcePoint() {
        return this.props.reactive.sourcePoint;
    }

    get targetPoint() {
        return this.props.reactive.targetPoint;
    }

    setup() {
        onWillRender(this.onWillRender);

        useEffect(
            (el, sourceLeft, sourceTop, targetLeft, targetTop) => {
                if (!el) {
                    return;
                }
                const { sourceControlPoint, targetControlPoint, removeButtonPosition } =
                    this.getPathInfo(
                        { left: sourceLeft, top: sourceTop },
                        { left: targetLeft, top: targetTop },
                        this.style.slackness
                    );

                const drawingCommands = [
                    `M`,
                    `${sourceLeft},${sourceTop}`,
                    `C`,
                    `${sourceControlPoint.left},${sourceControlPoint.top}`,
                    `${targetControlPoint.left},${targetControlPoint.top}`,
                    `${targetLeft},${targetTop}`,
                ].join(" ");

                const paths = el.querySelectorAll(
                    ".o_connector_stroke, .o_connector_stroke_hover_ease"
                );
                for (const path of paths) {
                    path.setAttribute("d", drawingCommands);
                }

                const svgButtons = el.querySelector(".o_connector_stroke_buttons");
                if (svgButtons) {
                    svgButtons.setAttribute("x", removeButtonPosition.left - 24);
                    svgButtons.setAttribute("y", removeButtonPosition.top - 8);
                }
            },
            () => this.getEffectDependencies()
        );
    }

    /**
     * Refreshes the connector properties from the props.
     *
     * @param {ConnectorProps} props
     */
    computeStyle({ alert, highlighted }) {
        const key = highlighted ? "highlightedColor" : "color";
        const strokeType = alert || "default";
        this.style = {
            hoverEaseWidth: 10,
            slackness: 0.9,
            stroke: {
                color: COLORS[strokeType][key],
                width: 2,
            },
            outlineStroke: {
                color: COLORS.outline[key],
                width: 1,
            },
        };
    }

    getEffectDependencies() {
        let sourcePoint = this.sourcePoint || { left: 0, top: 0 };
        if (typeof sourcePoint === "function") {
            sourcePoint = sourcePoint();
        }
        let targetPoint = this.targetPoint || { left: 0, top: 0 };
        if (typeof targetPoint === "function") {
            targetPoint = targetPoint();
        }
        const { x, y } = this.rootRef.el?.getBoundingClientRect() || { x: 0, y: 0 };

        return [
            this.rootRef.el,
            sourcePoint.left - x,
            sourcePoint.top - y,
            targetPoint.left - x,
            targetPoint.top - y,
            this.displayButtons,
        ];
    }

    /**
     * Returns the linear interpolation for a point to be found somewhere on the line startingPoint, endingPoint.
     *
     * @param {Point} startingPoint
     * @param {Point} endingPoint
     * @param {number} lambda
     * @returns {Point}
     */
    getLinearInterpolation(startingPoint, endingPoint, lambda = 0.5) {
        return {
            left: lambda * startingPoint.left + (1 - lambda) * endingPoint.left,
            top: lambda * startingPoint.top + (1 - lambda) * endingPoint.top,
        };
    }

    /**
     * Returns the parameters of both the single Bezier curve as well as is decomposition into two beziers curves
     * (which allows to get the middle position of the single Bezier curve) for the provided source, target and
     * slackness (0 being a straight line).
     *
     * @param {Point} sourcePoint
     * @param {Point} targetPoint
     * @param {number} slackness [0, 1]
     * @returns {PathInfo}
     */
    getPathInfo(sourcePoint, targetPoint, slackness) {
        // If the source is on the left of the target, we need to invert the control points.
        const xDelta = targetPoint.left - sourcePoint.left;
        const yDelta = targetPoint.top - sourcePoint.top;
        const directionFactor = Math.sign(xDelta);

        // What follows can be seen as magic numbers. And those are indeed such numbers as they have been determined
        // by observing their shape while creating short and long connectors. These seems to allow keeping the same
        // kind of shape amongst short and long connectors.
        const xInc = 100 + (Math.abs(xDelta) * slackness) / 10;
        const yInc =
            Math.abs(yDelta) < 16 && directionFactor === -1 ? 15 - 0.001 * xDelta * slackness : 0;

        const b = {
            left: sourcePoint.left + xInc,
            top: sourcePoint.top + yInc,
        };

        // Prevent having the air pin effect when in creation and having target on the left of the source
        const c = {
            left: targetPoint.left + (this.isNew && directionFactor === -1 ? xInc : -xInc),
            top: targetPoint.top + yInc,
        };

        const e = this.getLinearInterpolation(sourcePoint, b);
        const f = this.getLinearInterpolation(b, c);
        const g = this.getLinearInterpolation(c, targetPoint);
        const h = this.getLinearInterpolation(e, f);
        const i = this.getLinearInterpolation(f, g);
        const j = this.getLinearInterpolation(h, i);

        return {
            sourceControlPoint: b,
            targetControlPoint: c,
            removeButtonPosition: j,
        };
    }

    //-------------------------------------------------------------------------
    // Handlers
    //-------------------------------------------------------------------------

    onLeftButtonClick() {
        if (this.props.onLeftButtonClick) {
            this.props.onLeftButtonClick();
        }
    }

    onRemoveButtonClick() {
        if (this.props.onRemoveButtonClick) {
            this.props.onRemoveButtonClick();
        }
    }

    onRightButtonClick() {
        if (this.props.onRightButtonClick) {
            this.props.onRightButtonClick();
        }
    }

    onWillRender() {
        const key = this.highlighted ? "highlightedColor" : "color";
        this.style.stroke.color = COLORS[this.alert || "default"][key];
        this.style.outlineStroke.color = COLORS.outline[key];
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web_gantt/static/src/gantt_controller.js  *
*  Lines: 199                                           *
********************************************************/
odoo.define('@web_gantt/gantt_controller', ['@web/core/l10n/translation', '@odoo/owl', '@web/core/confirmation_dialog/confirmation_dialog', '@web/views/view_dialogs/form_view_dialog', '@web/search/layout', '@web/views/standard_view_props', '@web/model/model', '@web/search/pager_hook', '@web/core/utils/hooks', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@web/search/action_hook'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { Component, onWillUnmount, useEffect, useRef, useSubEnv } = require("@odoo/owl");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { FormViewDialog } = require("@web/views/view_dialogs/form_view_dialog");
const { Layout } = require("@web/search/layout");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useModelWithSampleData } = require("@web/model/model");
const { usePager } = require("@web/search/pager_hook");
const { useService } = require("@web/core/utils/hooks");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");
const { CallbackRecorder, useSetupAction } = require("@web/search/action_hook");

const GanttController = __exports.GanttController = class GanttController extends Component {
    static components = {
        CogMenu,
        Layout,
        SearchBar,
    };
    static props = {
        ...standardViewProps,
        Model: Function,
        Renderer: Function,
        buttonTemplate: String,
        modelParams: Object,
        scrollPosition: { type: Object, optional: true },
    };
    static template = "web_gantt.GanttController";

    setup() {
        this.actionService = useService("action");
        this.dialogService = useService("dialog");
        this.orm = useService("orm");

        useSubEnv({
            getCurrentFocusDateCallBackRecorder: new CallbackRecorder(),
        });

        const rootRef = useRef("root");

        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);
        useSetupAction({
            rootRef,
            getLocalState: () => {
                return { metaData: this.model.metaData, displayParams: this.model.displayParams };
            },
        });

        onWillUnmount(() => this.closeDialog?.());

        usePager(() => {
            const { groupedBy, pagerLimit, pagerOffset } = this.model.metaData;
            const { count } = this.model.data;
            if (pagerLimit !== null && groupedBy.length) {
                return {
                    offset: pagerOffset,
                    limit: pagerLimit,
                    total: count,
                    onUpdate: async ({ offset, limit }) => {
                        await this.model.updatePagerParams({ offset, limit });
                    },
                };
            }
        });

        useEffect(
            (showNoContentHelp) => {
                if (showNoContentHelp) {
                    const realRows = [
                        ...rootRef.el.querySelectorAll(
                            ".o_gantt_row_header:not(.o_sample_data_disabled)"
                        ),
                    ];
                    // interactive rows created in extensions (fromServer undefined)
                    const headerContainerWidth =
                        rootRef.el.querySelector(".o_gantt_header_groups").clientHeight +
                        rootRef.el.querySelector(".o_gantt_header_columns").clientHeight;

                    const offset = realRows.reduce(
                        (current, el) => current + el.clientHeight,
                        headerContainerWidth
                    );

                    const noContentHelperEl = rootRef.el.querySelector(".o_view_nocontent");
                    noContentHelperEl.style.top = `${offset}px`;
                }
            },
            () => [this.showNoContentHelp]
        );
        this.searchBarToggler = useSearchBarToggler();
    }

    get className() {
        if (this.env.isSmall) {
            const classList = (this.props.className || "").split(" ");
            classList.push("o_action_delegate_scroll");
            return classList.join(" ");
        }
        return this.props.className;
    }

    get showNoContentHelp() {
        return this.model.useSampleModel;
    }

    /**
     * @param {Record<string, any>} [context]
     */
    create(context) {
        const { createAction } = this.model.metaData;
        if (createAction) {
            this.actionService.doAction(createAction, {
                additionalContext: context,
                onClose: () => {
                    this.model.fetchData();
                },
            });
        } else {
            this.openDialog({ context });
        }
    }

    /**
     * Opens dialog to add/edit/view a record
     *
     * @param {Record<string, any>} props FormViewDialog props
     * @param {Record<string, any>} [options={}]
     */
    openDialog(props, options = {}) {
        const { canDelete, canEdit, resModel, formViewId: viewId } = this.model.metaData;

        const title = props.title || (props.resId ? _t("Open") : _t("Create"));

        let removeRecord;
        if (canDelete && props.resId) {
            removeRecord = () => {
                return new Promise((resolve) => {
                    this.dialogService.add(ConfirmationDialog, {
                        body: _t("Are you sure to delete this record?"),
                        confirm: async () => {
                            await this.orm.unlink(resModel, [props.resId]);
                            resolve();
                        },
                        cancel: () => {},
                    });
                });
            };
        }

        this.closeDialog = this.dialogService.add(
            FormViewDialog,
            {
                title,
                resModel,
                viewId,
                resId: props.resId,
                size: props.size,
                mode: canEdit ? "edit" : "readonly",
                context: props.context,
                removeRecord,
            },
            {
                ...options,
                onClose: () => {
                    this.closeDialog = null;
                    this.model.fetchData();
                },
            }
        );
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    onAddClicked() {
        const { scale } = this.model.metaData;
        const focusDate = this.getCurrentFocusDate();
        const start = focusDate.startOf(scale.unit);
        const stop = focusDate.endOf(scale.unit).plus({ millisecond: 1 });
        const context = this.model.getDialogContext({ start, stop, withDefault: true });
        this.create(context);
    }

    getCurrentFocusDate() {
        const { callbacks } = this.env.getCurrentFocusDateCallBackRecorder;
        if (callbacks.length) {
            return callbacks[0]();
        }
        return this.model.metaData.focusDate;
    }
}

return __exports;
});
;

/*****************************************************
*  Filepath: /web_gantt/static/src/gantt_helpers.js  *
*  Lines: 751                                        *
*****************************************************/
odoo.define('@web_gantt/gantt_helpers', ['@odoo/owl', '@web/core/l10n/dates', '@web/core/popover/popover_hook', '@web/core/utils/draggable_hook_builder_owl', '@web/core/utils/hooks', '@web/core/utils/numbers', '@web/core/utils/objects', '@web_gantt/gantt_popover_in_dialog'], function (require) {
'use strict';
let __exports = {};
const { onWillUnmount, status, useComponent, useEffect, useEnv } = require("@odoo/owl");
const { getEndOfLocalWeek, getStartOfLocalWeek } = require("@web/core/l10n/dates");
const { makePopover, usePopover } = require("@web/core/popover/popover_hook");
const { makeDraggableHook } = require("@web/core/utils/draggable_hook_builder_owl");
const { useService } = require("@web/core/utils/hooks");
const { clamp } = require("@web/core/utils/numbers");
const { pick } = require("@web/core/utils/objects");
const { GanttPopoverInDialog } = require("@web_gantt/gantt_popover_in_dialog");

/** @typedef {luxon.DateTime} DateTime */

/**
 * @param {number} target
 * @param {number[]} values
 * @returns {number}
 */
function closest(target, values) {
    return values.reduce(
        (prev, val) => (Math.abs(val - target) < Math.abs(prev - target) ? val : prev),
        Infinity
    );
}

/**
 * Adds a time diff to a date keeping the same value even if the offset changed
 * during the manipulation. This is typically needed with timezones using DayLight
 * Saving offset changes.
 *
 * @example dateAddFixedOffset(luxon.DateTime.local(), { hour: 1 });
 * @param {DateTime} date
 * @param {Record<string, number>} plusParams
 */
__exports.dateAddFixedOffset = dateAddFixedOffset; function dateAddFixedOffset(date, plusParams) {
    const shouldApplyOffset = Object.keys(plusParams).some((key) =>
        /^(hour|minute|second)s?$/i.test(key)
    );
    const result = date.plus(plusParams);
    if (shouldApplyOffset) {
        const initialOffset = date.offset;
        const diff = initialOffset - result.offset;
        if (diff) {
            const adjusted = result.plus({ minute: diff });
            return adjusted.offset === initialOffset ? result : adjusted;
        }
    }
    return result;
}

__exports.diffColumn = diffColumn; function diffColumn(col1, col2, unit) {
    return col2.diff(col1, unit).values[`${unit}s`];
}

__exports.getRangeFromDate = getRangeFromDate; function getRangeFromDate(rangeId, date) {
    const startDate = localStartOf(date, rangeId);
    const stopDate = startDate.plus({ [rangeId]: 1 }).minus({ day: 1 });
    return { focusDate: date, startDate, stopDate, rangeId };
}

__exports.localStartOf = localStartOf; function localStartOf(date, unit) {
    return unit === "week" ? getStartOfLocalWeek(date) : date.startOf(unit);
}

__exports.localEndOf = localEndOf; function localEndOf(date, unit) {
    return unit === "week" ? getEndOfLocalWeek(date) : date.endOf(unit);
}

/**
 * @param {number} cellPart
 * @param {(0 | 1)[]} subSlotUnavailabilities
 * @param {boolean} isToday
 * @returns {string | null}
 */
__exports.getCellColor = getCellColor; function getCellColor(cellPart, subSlotUnavailabilities, isToday) {
    const sum = subSlotUnavailabilities.reduce((acc, d) => acc + d);
    if (!sum) {
        return null;
    }
    switch (cellPart) {
        case sum: {
            return `background-color:${getCellPartColor(sum, isToday)}`;
        }
        case 2: {
            const [c0, c1] = subSlotUnavailabilities.map((d) => getCellPartColor(d, isToday));
            return `background:linear-gradient(90deg,${c0}49%,${c1}50%)`;
        }
        case 4: {
            const [c0, c1, c2, c3] = subSlotUnavailabilities.map((d) =>
                getCellPartColor(d, isToday)
            );
            return `background:linear-gradient(90deg,${c0}24%,${c1}25%,${c1}49%,${c2}50%,${c2}74%,${c3}75%)`;
        }
    }
}

/**
 * @param {0 | 1} availability
 * @param {boolean} isToday
 * @returns {string}
 */
__exports.getCellPartColor = getCellPartColor; function getCellPartColor(availability, isToday) {
    if (availability) {
        return "var(--Gantt__DayOff-background-color)";
    } else if (isToday) {
        return "var(--Gantt__DayOffToday-background-color)";
    } else {
        return "var(--Gantt__Day-background-color)";
    }
}

/**
 * @param {number | [number, string]} value
 * @returns {number}
 */
__exports.getColorIndex = getColorIndex; function getColorIndex(value) {
    if (typeof value === "number") {
        return Math.round(value) % NB_GANTT_RECORD_COLORS;
    } else if (Array.isArray(value)) {
        return value[0] % NB_GANTT_RECORD_COLORS;
    }
    return 0;
}

/**
 * Intervals are supposed to intersect (intersection duration >= 1 milliseconds)
 *
 * @param {[DateTime, DateTime]} interval
 * @param {[DateTime, DateTime]} otherInterval
 * @returns {[DateTime, DateTime]}
 */
__exports.getIntersection = getIntersection; function getIntersection(interval, otherInterval) {
    const [start, end] = interval;
    const [otherStart, otherEnd] = otherInterval;
    return [start >= otherStart ? start : otherStart, end <= otherEnd ? end : otherEnd];
}

/**
 * Computes intersection of a closed interval with a union of closed intervals ordered and disjoint
 * = a union of intersections
 *
 * @param {[DateTime, DateTime]} interval
 * @param {[DateTime, DateTime]} intervals
 * @returns {[DateTime, DateTime][]}
 */
__exports.getUnionOfIntersections = getUnionOfIntersections; function getUnionOfIntersections(interval, intervals) {
    const [start, end] = interval;
    const intersecting = intervals.filter((otherInterval) => {
        const [otheStart, otherEnd] = otherInterval;
        return otherEnd > start && end > otheStart;
    });
    const len = intersecting.length;
    if (len === 0) {
        return [];
    }
    const union = [];
    const first = getIntersection(interval, intersecting[0]);
    union.push(first);
    if (len >= 2) {
        const last = getIntersection(interval, intersecting[len - 1]);
        union.push(...intersecting.slice(1, len - 1), last);
    }
    return union;
}

/**
 * @param {Object} params
 * @param {Ref<HTMLElement>} params.ref
 * @param {string} params.selector
 * @param {string} params.related
 * @param {string} params.className
 */
__exports.useMultiHover = useMultiHover; function useMultiHover({ ref, selector, related, className }) {
    /**
     * @param {HTMLElement} el
     */
    const findSiblings = (el) =>
        ref.el.querySelectorAll(
            related
                .map((attr) => `[${attr}='${el.getAttribute(attr).replace(/'/g, "\\'")}']`)
                .join("")
        );

    /**
     * @param {PointerEvent} ev
     */
    const onPointerEnter = (ev) => {
        for (const sibling of findSiblings(ev.target)) {
            sibling.classList.add(...classList);
            classedEls.add(sibling);
        }
    };

    /**
     * @param {PointerEvent} ev
     */
    const onPointerLeave = (ev) => {
        for (const sibling of findSiblings(ev.target)) {
            sibling.classList.remove(...classList);
            classedEls.delete(sibling);
        }
    };

    const classList = className.split(/\s+/g);
    const classedEls = new Set();

    useEffect(
        (...targets) => {
            if (targets.length) {
                for (const target of targets) {
                    target.addEventListener("pointerenter", onPointerEnter);
                    target.addEventListener("pointerleave", onPointerLeave);
                }
                return () => {
                    for (const el of classedEls) {
                        el.classList.remove(...classList);
                    }
                    classedEls.clear();
                    for (const target of targets) {
                        target.removeEventListener("pointerenter", onPointerEnter);
                        target.removeEventListener("pointerleave", onPointerLeave);
                    }
                };
            }
        },
        () => [...ref.el.querySelectorAll(selector)]
    );
}

const NB_GANTT_RECORD_COLORS = 12;

function getElementCenter(el) {
    const { x, y, width, height } = el.getBoundingClientRect();
    return {
        x: x + width / 2,
        y: y + height / 2,
    };
}

// Resizable hook handles

const HANDLE_CLASS_START = "o_handle_start";
const HANDLE_CLASS_END = "o_handle_end";
const handles = {
    start: document.createElement("div"),
    end: document.createElement("div"),
};

// Draggable hooks

const useGanttConnectorDraggable = __exports.useGanttConnectorDraggable = makeDraggableHook({
    name: "useGanttConnectorDraggable",
    acceptedParams: {
        parentWrapper: [String],
    },
    onComputeParams({ ctx, params }) {
        ctx.parentWrapper = params.parentWrapper;
        ctx.followCursor = false;
    },
    onDragStart: ({ ctx, addStyle }) => {
        const { current } = ctx;
        const parent = current.element.closest(ctx.parentWrapper);
        if (!parent) {
            return;
        }
        for (const otherParent of ctx.ref.el.querySelectorAll(ctx.parentWrapper)) {
            if (otherParent !== parent) {
                addStyle(otherParent, { pointerEvents: "auto" });
            }
        }
        return { sourcePill: parent, ...current.connectorCenter };
    },
    onDrag: ({ ctx }) => {
        ctx.current.connectorCenter = getElementCenter(ctx.current.element);
        return pick(ctx.current, "connectorCenter");
    },
    onDragEnd: ({ ctx }) => pick(ctx.current, "element"),
    onDrop: ({ ctx, target }) => {
        const { current } = ctx;
        const parent = current.element.closest(ctx.parentWrapper);
        const targetParent = target.closest(ctx.parentWrapper);
        if (!targetParent || targetParent === parent) {
            return;
        }
        return { target: targetParent };
    },
    onWillStartDrag: ({ ctx }) => {
        ctx.current.connectorCenter = getElementCenter(ctx.current.element);
    },
});

function getCoordinate(style, name) {
    return +style.getPropertyValue(name).slice(1);
}

function getColumnStart(style) {
    return getCoordinate(style, "grid-column-start");
}

function getColumnEnd(style) {
    return getCoordinate(style, "grid-column-end");
}

const useGanttDraggable = __exports.useGanttDraggable = makeDraggableHook({
    name: "useGanttDraggable",
    acceptedParams: {
        cells: [String, Function],
        cellDragClassName: [String, Function],
        ghostClassName: [String, Function],
        hoveredCell: [Object],
        addStickyCoordinates: [Function],
    },
    onComputeParams({ ctx, params }) {
        ctx.cellSelector = params.cells;
        ctx.ghostClassName = params.ghostClassName;
        ctx.cellDragClassName = params.cellDragClassName;
        ctx.hoveredCell = params.hoveredCell;
        ctx.addStickyCoordinates = params.addStickyCoordinates;
    },
    onDragStart({ ctx }) {
        const { current, ghostClassName } = ctx;
        current.element.before(current.placeHolder);
        if (ghostClassName) {
            current.placeHolder.classList.add(ghostClassName);
        }
        return { pill: current.element };
    },
    onDrag({ ctx, addStyle }) {
        const { cellSelector, current, hoveredCell } = ctx;
        let { el: cell, part } = hoveredCell;

        const isDifferentCell = cell !== current.cell.el;
        const isDifferentPart = part !== current.cell.part;

        if (cell && !cell.matches(cellSelector)) {
            cell = null; // Not a cell
        }

        current.cell.el = cell;
        current.cell.part = part;

        if (cell) {
            // Recompute cell style if in a different cell
            if (isDifferentCell) {
                const style = getComputedStyle(cell);
                current.cell.gridRow = style.getPropertyValue("grid-row");
                current.cell.gridColumnStart = getColumnStart(style) + current.gridColumnOffset;
            }
            // Assign new grid coordinates if in different cell or different cell part
            if (isDifferentCell || isDifferentPart) {
                const { pillSpan } = current;
                const { gridRow, gridColumnStart: start } = current.cell;
                const gridColumnStart = clamp(start + part, 1, current.maxGridColumnStart);
                const gridColumnEnd = gridColumnStart + pillSpan;

                addStyle(current.cellGhost, {
                    gridRow,
                    gridColumn: `c${gridColumnStart} / c${gridColumnEnd}`,
                });

                const [gridRowStart, gridRowEnd] = /r(\d+) \/ r(\d+)/g.exec(gridRow).slice(1);
                ctx.addStickyCoordinates(
                    [gridRowStart, gridRowEnd],
                    [gridColumnStart, gridColumnEnd]
                );
                current.cell.col = gridColumnStart;
            }
        } else {
            current.cell.col = null;
        }

        // Attach or remove cell ghost
        if (isDifferentCell) {
            if (cell) {
                cell.after(current.cellGhost);
            } else {
                current.cellGhost.remove();
            }
        }

        return { pill: current.element };
    },
    onDragEnd({ ctx }) {
        return { pill: ctx.current.element };
    },
    onDrop({ ctx }) {
        const { cell, element, initialCol } = ctx.current;
        if (cell.col !== null) {
            return {
                pill: element,
                cell: cell.el,
                diff: cell.col - initialCol,
            };
        }
    },
    onWillStartDrag({ ctx, addCleanup, addClass }) {
        const { current } = ctx;
        const { el: cell, part } = ctx.hoveredCell;

        current.placeHolder = current.element.cloneNode(true);
        current.cellGhost = document.createElement("div");
        current.cellGhost.className = ctx.cellDragClassName;
        current.cell = { el: null, index: null, part: 0 };

        const gridStyle = getComputedStyle(cell.parentElement);
        const pillStyle = getComputedStyle(current.element);
        const cellStyle = getComputedStyle(cell);

        const gridTemplateColumns = gridStyle.getPropertyValue("grid-template-columns");
        const pGridColumnStart = getColumnStart(pillStyle);
        const pGridColumnEnd = getColumnEnd(pillStyle);
        const cGridColumnStart = getColumnStart(cellStyle) + part;

        let highestGridCol;
        for (const e of gridTemplateColumns.split(/\s+/).reverse()) {
            const res = /\[c(\d+)\]/g.exec(e);
            if (res) {
                highestGridCol = +res[1];
                break;
            }
        }

        const pillSpan = pGridColumnEnd - pGridColumnStart;

        current.initialCol = pGridColumnStart;
        current.maxGridColumnStart = highestGridCol - pillSpan;
        current.gridColumnOffset = pGridColumnStart - cGridColumnStart;
        current.pillSpan = pillSpan;

        addClass(ctx.ref.el, "pe-auto");
        addCleanup(() => {
            current.placeHolder.remove();
            current.cellGhost.remove();
        });
    },
});

const useGanttUndraggable = __exports.useGanttUndraggable = makeDraggableHook({
    name: "useGanttUndraggable",
    onDragStart({ ctx }) {
        return { pill: ctx.current.element };
    },
    onDragEnd({ ctx }) {
        return { pill: ctx.current.element };
    },
    onWillStartDrag({ ctx, addCleanup, addClass, addStyle, getRect }) {
        const { x, y, width, height } = getRect(ctx.current.element);
        ctx.current.container = document.createElement("div");

        addClass(ctx.ref.el, "pe-auto");
        addStyle(ctx.current.container, {
            position: "fixed",
            left: `${x}px`,
            top: `${y}px`,
            width: `${width}px`,
            height: `${height}px`,
        });

        ctx.current.element.after(ctx.current.container);
        addCleanup(() => ctx.current.container.remove());
    },
});

const useGanttResizable = __exports.useGanttResizable = makeDraggableHook({
    name: "useGanttResizable",
    requiredParams: ["handles"],
    acceptedParams: {
        innerPills: [String, Function],
        handles: [String, Function],
        hoveredCell: [Object],
        rtl: [Boolean, Function],
        cells: [String, Function],
        precision: [Number, Function],
        showHandles: [Function],
    },
    onComputeParams({ ctx, params, addCleanup, addEffectCleanup, getRect }) {
        const onElementPointerEnter = (ev) => {
            if (ctx.dragging || ctx.willDrag) {
                return;
            }

            const pill = ev.target;
            const innerPill = pill.querySelector(params.innerPills);

            const pillRect = getRect(innerPill);

            for (const el of Object.values(handles)) {
                el.style.height = `${pillRect.height}px`;
            }

            const showHandles = params.showHandles ? params.showHandles(pill) : {};
            if ("start" in showHandles && !showHandles.start) {
                handles.start.remove();
            } else {
                innerPill.appendChild(handles.start);
            }
            if ("end" in showHandles && !showHandles.end) {
                handles.end.remove();
            } else {
                innerPill.appendChild(handles.end);
            }
        };

        const onElementPointerLeave = () => {
            const remove = () => Object.values(handles).forEach((h) => h.remove());
            if (ctx.dragging || ctx.current.element) {
                addCleanup(remove);
            } else {
                remove();
            }
        };

        ctx.cellSelector = params.cells;
        ctx.hoveredCell = params.hoveredCell;
        ctx.precision = params.precision;
        ctx.rtl = params.rtl;

        for (const el of ctx.ref.el.querySelectorAll(params.elements)) {
            el.addEventListener("pointerenter", onElementPointerEnter);
            el.addEventListener("pointerleave", onElementPointerLeave);
            addEffectCleanup(() => {
                el.removeEventListener("pointerenter", onElementPointerEnter);
                el.removeEventListener("pointerleave", onElementPointerLeave);
            });
        }

        handles.start.className = `${params.handles} ${HANDLE_CLASS_START}`;
        handles.start.style.cursor = `${params.rtl ? "e" : "w"}-resize`;

        handles.end.className = `${params.handles} ${HANDLE_CLASS_END}`;
        handles.end.style.cursor = `${params.rtl ? "w" : "e"}-resize`;

        // Override "full" and "element" selectors: we want the draggable feature
        // to apply to the handles
        ctx.pillSelector = ctx.elementSelector;
        ctx.fullSelector = ctx.elementSelector = `.${params.handles}`;

        // Force the handles to stay in place
        ctx.followCursor = false;
    },
    onDragStart({ ctx, addStyle }) {
        addStyle(ctx.current.pill, { zIndex: 15 });
        return { pill: ctx.current.pill };
    },
    onDrag({ ctx, addStyle, getRect }) {
        const { cellSelector, current, hoveredCell, pointer, precision, rtl, ref } = ctx;
        let { el: cell, part } = hoveredCell;

        const point = [pointer.x, current.initialPosition.y];
        if (!cell) {
            let rect;
            cell = document.elementsFromPoint(...point).find((el) => el.matches(cellSelector));
            if (!cell) {
                const cells = Array.from(ref.el.querySelectorAll(".o_gantt_cells .o_gantt_cell"));
                if (pointer.x < current.initialPosition.x) {
                    cell = rtl ? cells.at(-1) : cells[0];
                } else {
                    cell = rtl ? cells[0] : cells.at(-1);
                }
                rect = getRect(cell);
                point[0] = rtl ? rect.right - 1 : rect.left + 1;
            } else {
                rect = getRect(cell);
            }
            const x = Math.floor(rect.x);
            const width = Math.floor(rect.width);
            part = Math.floor((point[0] - x) / (width / precision));
        }

        const cellStyle = getComputedStyle(cell);
        const cGridColStart = getColumnStart(cellStyle);

        const { x, width } = getRect(cell);
        const coef = ((rtl ? -1 : 1) * width) / precision;
        const startBorder = (rtl ? x + width : x) + part * coef;
        const endBorder = startBorder + coef;

        const theClosest = closest(point[0], [startBorder, endBorder]);

        let diff =
            cGridColStart +
            part +
            (theClosest === startBorder ? 0 : 1) -
            (current.isStart ? current.firstCol : current.lastCol);

        if (diff === current.lastDiff) {
            return;
        }

        if (current.isStart) {
            diff = Math.min(diff, current.initialDiff - 1);
            addStyle(current.pill, { "grid-column-start": `c${current.firstCol + diff}` });
        } else {
            diff = Math.max(diff, 1 - current.initialDiff);
            addStyle(current.pill, { "grid-column-end": `c${current.lastCol + diff}` });
        }
        current.lastDiff = diff;

        const isLeftHandle = rtl ? !current.isStart : current.isStart;
        const grabbedHandle = isLeftHandle ? "left" : "right";
        diff = current.isStart ? -diff : diff;
        return { pill: current.pill, grabbedHandle, diff };
    },
    onDragEnd({ ctx }) {
        const { current, pillSelector } = ctx;
        const pill = current.element.closest(pillSelector);
        return { pill };
    },
    onDrop({ ctx }) {
        const { current } = ctx;

        if (!current.lastDiff) {
            return;
        }

        const direction = current.isStart ? "start" : "end";
        return { pill: current.pill, diff: current.lastDiff, direction };
    },
    onWillStartDrag({ ctx, addClass }) {
        const { current, pillSelector } = ctx;

        const pill = ctx.current.element.closest(pillSelector);
        current.pill = pill;

        const pillStyle = getComputedStyle(pill);
        current.firstCol = getColumnStart(pillStyle);
        current.lastCol = getColumnEnd(pillStyle);
        current.initialDiff = current.lastCol - current.firstCol;

        ctx.cursor = getComputedStyle(current.element).cursor;

        current.isStart = current.element.classList.contains(HANDLE_CLASS_START);

        addClass(ctx.ref.el, "pe-auto");
    },
});

function getCellsOnRow(refEl, rowId) {
    return refEl.querySelectorAll(
        `.o_gantt_cell:not(.o_gantt_group)[data-row-id='${CSS.escape(rowId)}']`
    );
}

function getMinMax(a, b) {
    return a <= b ? [a, b] : [b, a];
}

const useGanttSelectable = __exports.useGanttSelectable = makeDraggableHook({
    name: "useGanttSelectable",
    acceptedParams: {
        hoveredCell: [Object],
        rtl: [Boolean, Function],
    },
    onComputeParams({ ctx, params }) {
        ctx.followCursor = false;
        ctx.hoveredCell = params.hoveredCell;
        ctx.rtl = params.rtl;
    },
    onDrag({ ctx, addClass, getRect, removeClass }) {
        const { current, hoveredCell, pointer, ref, rtl } = ctx;
        let { el: cell } = hoveredCell;
        if (!cell) {
            const point = [pointer.x, current.initialPosition.y];
            cell = document.elementsFromPoint(...point).find((el) => el.matches(".o_gantt_cell"));
            if (!cell) {
                const cells = Array.from(ref.el.querySelectorAll(".o_gantt_cells .o_gantt_cell"));
                if (pointer.x < current.initialPosition.x) {
                    cell = rtl ? cells.at(-1) : cells[0];
                } else {
                    cell = rtl ? cells[0] : cells.at(-1);
                }
            }
        }
        const col = +cell.dataset.col;
        const lastSelectedCol = current.lastSelectedCol;
        current.lastSelectedCol = col;
        if (lastSelectedCol === col) {
            return;
        }
        const [startCol, stopCol] = getMinMax(current.initialCol, col);
        for (const cell of getCellsOnRow(ref.el, current.rowId)) {
            const cellCol = +cell.dataset.col;
            if (cellCol < startCol || cellCol > stopCol) {
                removeClass(cell, "o_drag_hover");
            } else {
                addClass(cell, "o_drag_hover");
            }
        }
    },
    onDrop({ ctx }) {
        const { current } = ctx;
        const { rowId, initialCol, lastSelectedCol } = current;
        const [startCol, stopCol] = getMinMax(initialCol, lastSelectedCol);
        return { rowId, startCol, stopCol };
    },
    onWillStartDrag({ ctx, addClass }) {
        const { current, hoveredCell, ref } = ctx;
        const { el: cell } = hoveredCell;
        current.rowId = cell.dataset.rowId;
        current.initialCol = +cell.dataset.col;
        addClass(ref.el, "pe-auto");
        addClass(cell, "pe-auto");
    },
});

/**
 * Same as usePopover, but replaces the popover by a dialog when display size is small.
 *
 * @param {typeof import("@odoo/owl").Component} component
 * @param {import("@web/core/popover/popover_service").PopoverServiceAddOptions} [options]
 * @returns {import("@web/core/popover/popover_hook").PopoverHookReturnType}
 */
__exports.useGanttResponsivePopover = useGanttResponsivePopover; function useGanttResponsivePopover(dialogTitle, component, options = {}) {
    const dialogService = useService("dialog");
    const env = useEnv();
    const owner = useComponent();
    const popover = usePopover(component, options);
    const onClose = () => {
        if (status(owner) !== "destroyed") {
            options.onClose?.();
        }
    };
    const dialogAddFn = (_, comp, props, options) => dialogService.add(comp, props, options);
    const popoverInDialog = makePopover(dialogAddFn, GanttPopoverInDialog, { onClose });
    const ganttReponsivePopover = {
        open: (target, props) => {
            if (env.isSmall) {
                popoverInDialog.open(target, {
                    component: component,
                    componentProps: props,
                    dialogTitle,
                });
            } else {
                popover.open(target, props);
            }
        },
        close: () => {
            popover.close();
            popoverInDialog.close();
        },
        get isOpen() {
            return popover.isOpen || popoverInDialog.isOpen;
        },
    };
    onWillUnmount(ganttReponsivePopover.close);
    return ganttReponsivePopover;
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web_gantt/static/src/gantt_mock_server.js  *
*  Lines: 41                                             *
*********************************************************/
odoo.define('@web_gantt/gantt_mock_server', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

function _mockGetGanttData(_, { model, kwargs }) {
    const lazy = !kwargs.limit && !kwargs.offset && kwargs.groupby.length === 1;
    const { groups, length } = this.mockWebReadGroup(model, {
        ...kwargs,
        lazy,
        fields: ["__record_ids:array_agg(id)"],
    });

    const recordIds = [];
    for (const group of groups) {
        recordIds.push(...(group.__record_ids || []));
    }

    const { records } = this.mockWebSearchReadUnity(model, [], {
        domain: [["id", "in", recordIds]],
        context: kwargs.context,
        specification: kwargs.read_specification,
    });

    const unavailabilities = {};
    for (const fieldName of kwargs.unavailability_fields || []) {
        unavailabilities[fieldName] = {};
    }

    const progress_bars = {};
    for (const fieldName of kwargs.progress_bar_fields || []) {
        progress_bars[fieldName] = {};
    }

    return { groups, length, records, unavailabilities, progress_bars };
}

registry.category("mock_server").add("get_gantt_data", _mockGetGanttData);

return __exports;
});
;

/***************************************************
*  Filepath: /web_gantt/static/src/gantt_model.js  *
*  Lines: 1132                                     *
***************************************************/
odoo.define('@web_gantt/gantt_model', ['@web/core/browser/browser', '@web/core/domain', '@web/core/l10n/translation', '@web/core/l10n/dates', '@web/core/orm_service', '@web/core/registry', '@web/core/utils/arrays', '@web/core/utils/concurrency', '@web/core/utils/objects', '@web/core/utils/strings', '@web/model/model', '@web/model/relational_model/utils', '@web/views/fields/formatters', '@web_gantt/gantt_helpers'], function (require) {
'use strict';
let __exports = {};
const { browser } = require("@web/core/browser/browser");
const { Domain } = require("@web/core/domain");
const { _t } = require("@web/core/l10n/translation");
const {
    deserializeDate,
    deserializeDateTime,
    serializeDate,
    serializeDateTime,
} = require("@web/core/l10n/dates");
const { x2ManyCommands } = require("@web/core/orm_service");
const { registry } = require("@web/core/registry");
const { groupBy, unique } = require("@web/core/utils/arrays");
const { KeepLast, Mutex } = require("@web/core/utils/concurrency");
const { pick } = require("@web/core/utils/objects");
const { sprintf } = require("@web/core/utils/strings");
const { Model } = require("@web/model/model");
const { parseServerValue } = require("@web/model/relational_model/utils");
const { formatFloatTime, formatPercentage } = require("@web/views/fields/formatters");
const { getRangeFromDate, localStartOf } = require("@web_gantt/gantt_helpers");

const { DateTime } = luxon;

/**
 * @typedef {luxon.DateTime} DateTime
 * @typedef {`[{${string}}]`} RowId
 * @typedef {import("./gantt_arch_parser").Scale} Scale
 * @typedef {import("./gantt_arch_parser").ScaleId} ScaleId
 *
 * @typedef ConsolidationParams
 * @property {string} excludeField
 * @property {string} field
 * @property {string} [maxField]
 * @property {string} [maxValue]
 *
 * @typedef Data
 * @property {Record<string, any>[]} records
 * @property {Row[]} rows
 *
 * @typedef Field
 * @property {string} name
 * @property {string} type
 * @property {[any, string][]} [selection]
 *
 * @typedef MetaData
 * @property {ConsolidationParams} consolidationParams
 * @property {string} dateStartField
 * @property {string} dateStopField
 * @property {string[]} decorationFields
 * @property {ScaleId} defaultScale
 * @property {string} dependencyField
 * @property {boolean} dynamicRange
 * @property {Record<string, Field>} fields
 * @property {DateTime} focusDate
 * @property {number | false} formViewId
 * @property {string[]} groupedBy
 * @property {Element | null} popoverTemplate
 * @property {string} resModel
 * @property {Scale} scale
 * @property {Scale[]} scales
 * @property {DateTime} startDate
 * @property {DateTime} stopDate
 *
 * @typedef ProgressBar
 * @property {number} value_formatted
 * @property {number} max_value_formatted
 * @property {number} ratio
 * @property {string} warning
 *
 * @typedef Row
 * @property {RowId} id
 * @property {boolean} consolidate
 * @property {boolean} fromServer
 * @property {string[]} groupedBy
 * @property {string} groupedByField
 * @property {number} groupLevel
 * @property {string} name
 * @property {number[]} recordIds
 * @property {ProgressBar} [progressBar]
 * @property {number | false} resId
 * @property {Row[]} [rows]
 */

function firstColumnBefore(date, unit) {
    return localStartOf(date, unit);
}

function firstColumnAfter(date, unit) {
    const start = localStartOf(date, unit);
    if (date.equals(start)) {
        return date;
    }
    return start.plus({ [unit]: 1 });
}

/**
 * @param {Record<string, Field>} fields
 * @param {Record<string, any>} values
 */
__exports.parseServerValues = parseServerValues; function parseServerValues(fields, values) {
    /** @type {Record<string, any>} */
    const parsedValues = {};
    if (!values) {
        return parsedValues;
    }
    for (const fieldName in values) {
        const field = fields[fieldName];
        const value = values[fieldName];
        switch (field.type) {
            case "date": {
                parsedValues[fieldName] = value ? deserializeDate(value) : false;
                break;
            }
            case "datetime": {
                parsedValues[fieldName] = value ? deserializeDateTime(value) : false;
                break;
            }
            case "selection": {
                if (value === false) {
                    // process selection: convert false to 0, if 0 is a valid key
                    const hasKey0 = field.selection.some((option) => option[0] === 0);
                    parsedValues[fieldName] = hasKey0 ? 0 : value;
                } else {
                    parsedValues[fieldName] = value;
                }
                break;
            }
            case "html": {
                parsedValues[fieldName] = parseServerValue(field, value);
                break;
            }
            case "many2one": {
                parsedValues[fieldName] = value ? [value.id, value.display_name] : false;
                break;
            }
            default: {
                parsedValues[fieldName] = value;
            }
        }
    }
    return parsedValues;
}

const GanttModel = __exports.GanttModel = class GanttModel extends Model {
    static services = ["notification"];

    setup(params, services) {
        this.notification = services.notification;

        /** @type {Data} */
        this.data = {};
        /** @type {MetaData} */
        this.metaData = params.metaData;
        this.displayParams = params.displayParams;

        this.searchParams = null;

        /** @type {Set<RowId>} */
        this.closedRows = new Set();

        // concurrency management
        this.keepLast = new KeepLast();
        this.mutex = new Mutex();
        /** @type {MetaData | null} */
        this._nextMetaData = null;
    }

    /**
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        this.searchParams = searchParams;

        const metaData = this._buildMetaData();

        const params = {
            groupedBy: this._getGroupedBy(metaData, searchParams),
            pagerOffset: 0,
        };

        if (!metaData.scale || !metaData.startDate || !metaData.stopDate) {
            Object.assign(
                params,
                this._getInitialRangeParams(this._buildMetaData(params), searchParams)
            );
        }

        await this._fetchData(this._buildMetaData(params));
    }

    //-------------------------------------------------------------------------
    // Public
    //-------------------------------------------------------------------------

    collapseRows() {
        const collapse = (rows) => {
            for (const row of rows) {
                this.closedRows.add(row.id);
                if (row.rows) {
                    collapse(row.rows);
                }
            }
        };
        collapse(this.data.rows);
        this.notify();
    }

    /**
     * Create a copy of a task with defaults determined by schedule.
     *
     * @param {number} id
     * @param {Record<string, any>} schedule
     * @param {(result: any) => any} [callback]
     */
    copy(id, schedule, callback) {
        const { resModel } = this.metaData;
        const { context } = this.searchParams;
        const data = this._scheduleToData(schedule);
        return this.mutex.exec(async () => {
            const result = await this.orm.call(resModel, "copy", [[id]], {
                context,
                default: data,
            });
            if (callback) {
                callback(result[0]);
            }
            this.fetchData();
        });
    }

    /**
     * Adds a dependency between masterId and slaveId (slaveId depends
     * on masterId).
     *
     * @param {number} masterId
     * @param {number} slaveId
     */
    async createDependency(masterId, slaveId) {
        const { dependencyField, resModel } = this.metaData;
        const writeCommand = {
            [dependencyField]: [x2ManyCommands.link(masterId)],
        };
        await this.mutex.exec(() => this.orm.write(resModel, [slaveId], writeCommand));
        await this.fetchData();
    }

    dateStartFieldIsDate(metaData = this.metaData) {
        return metaData?.fields[metaData.dateStartField].type === "date";
    }

    dateStopFieldIsDate(metaData = this.metaData) {
        return metaData?.fields[metaData.dateStopField].type === "date";
    }

    expandRows() {
        this.closedRows.clear();
        this.notify();
    }

    async fetchData(params) {
        await this._fetchData(this._buildMetaData(params));
        this.useSampleModel = false;
        this.notify();
    }

    /**
     * @param {Object} params
     * @param {RowId} [params.rowId]
     * @param {DateTime} [params.start]
     * @param {DateTime} [params.stop]
     * @param {boolean} [params.withDefault]
     * @returns {Record<string, any>}
     */
    getDialogContext(params) {
        /** @type {Record<string, any>} */
        const context = { ...this.getSchedule(params) };

        if (params.withDefault) {
            for (const k in context) {
                context[sprintf("default_%s", k)] = context[k];
            }
        }

        return Object.assign({}, this.searchParams.context, context);
    }

    /**
     * @param {Object} params
     * @param {RowId} [params.rowId]
     * @param {DateTime} [params.start]
     * @param {DateTime} [params.stop]
     * @returns {Record<string, any>}
     */
    getSchedule({ rowId, start, stop } = {}) {
        const { dateStartField, dateStopField, fields, groupedBy } = this.metaData;

        /** @type {Record<string, any>} */
        const schedule = {};

        if (start) {
            schedule[dateStartField] = this.dateStartFieldIsDate()
                ? serializeDate(start)
                : serializeDateTime(start);
        }
        if (stop && dateStartField !== dateStopField) {
            schedule[dateStopField] = this.dateStopFieldIsDate()
                ? serializeDate(stop)
                : serializeDateTime(stop);
        }
        if (rowId) {
            const group = Object.assign({}, ...JSON.parse(rowId));
            for (const fieldName of groupedBy) {
                if (fieldName in group) {
                    const value = group[fieldName];
                    if (Array.isArray(value)) {
                        const { type } = fields[fieldName];
                        schedule[fieldName] = type === "many2many" ? [value[0]] : value[0];
                    } else {
                        schedule[fieldName] = value;
                    }
                }
            }
        }

        return schedule;
    }

    /**
     * @override
     * @returns {boolean}
     */
    hasData() {
        return Boolean(this.data.records.length);
    }

    /**
     * @param {RowId} rowId
     * @returns {boolean}
     */
    isClosed(rowId) {
        return this.closedRows.has(rowId);
    }

    /**
     * Removes the dependency between masterId and slaveId (slaveId is no
     * more dependent on masterId).
     *
     * @param {number} masterId
     * @param {number} slaveId
     */
    async removeDependency(masterId, slaveId) {
        const { dependencyField, resModel } = this.metaData;
        const writeCommand = {
            [dependencyField]: [x2ManyCommands.unlink(masterId)],
        };
        await this.mutex.exec(() => this.orm.write(resModel, [slaveId], writeCommand));
        await this.fetchData();
    }

    /**
     * Removes from 'data' the fields holding the same value as the records targetted
     * by 'ids'.
     *
     * @template {Record<string, any>} T
     * @param {T} data
     * @param {number[]} ids
     * @returns {Partial<T>}
     */
    removeRedundantData(data, ids) {
        const records = this.data.records.filter((rec) => ids.includes(rec.id));
        if (!records.length) {
            return data;
        }

        /**
         *
         * @param {Record<string, any>} record
         * @param {Field} field
         */
        const isSameValue = (record, { name, type }) => {
            const recordValue = record[name];
            let newValue = data[name];
            if (Array.isArray(newValue)) {
                [newValue] = newValue;
            }
            if (Array.isArray(recordValue)) {
                if (type === "many2many") {
                    return recordValue.includes(newValue);
                } else {
                    return recordValue[0] === newValue;
                }
            } else if (type === "date") {
                return serializeDate(recordValue) === newValue;
            } else if (type === "datetime") {
                return serializeDateTime(recordValue) === newValue;
            } else {
                return recordValue === newValue;
            }
        };

        /** @type {Partial<T>} */
        const trimmed = { ...data };

        for (const fieldName in data) {
            const field = this.metaData.fields[fieldName];
            if (records.every((rec) => isSameValue(rec, field))) {
                // All the records already have the given value.
                delete trimmed[fieldName];
            }
        }

        return trimmed;
    }

    /**
     * Reschedule a task to the given schedule.
     *
     * @param {number | number[]} ids
     * @param {Record<string, any>} schedule
     * @param {(result: any) => any} [callback]
     */
    async reschedule(ids, schedule, callback) {
        if (!Array.isArray(ids)) {
            ids = [ids];
        }
        const allData = this._scheduleToData(schedule);
        const data = this.removeRedundantData(allData, ids);
        const context = this._getRescheduleContext();
        return this.mutex.exec(async () => {
            try {
                const result = await this._reschedule(ids, data, context);
                if (callback) {
                    await callback(result);
                }
            } finally {
                this.fetchData();
            }
        });
    }

    async _reschedule(ids, data, context) {
        return this.orm.write(this.metaData.resModel, ids, data, {
            context,
        });
    }

    toggleHighlightPlannedFilter(ids) {}

    /**
     * Reschedule masterId or slaveId according to the direction
     *
     * @param {"forward" | "backward"} direction
     * @param {number} masterId
     * @param {number} slaveId
     * @returns {Promise<any>}
     */
    async rescheduleAccordingToDependency(
        direction,
        masterId,
        slaveId,
        rescheduleAccordingToDependencyCallback
    ) {
        const {
            dateStartField,
            dateStopField,
            dependencyField,
            dependencyInvertedField,
            resModel,
        } = this.metaData;

        return await this.mutex.exec(async () => {
            try {
                const result = await this.orm.call(resModel, "web_gantt_reschedule", [
                    direction,
                    masterId,
                    slaveId,
                    dependencyField,
                    dependencyInvertedField,
                    dateStartField,
                    dateStopField,
                ]);
                if (rescheduleAccordingToDependencyCallback) {
                    await rescheduleAccordingToDependencyCallback(result);
                }
            } finally {
                this.fetchData();
            }
        });
    }

    /**
     * @param {string} rowId
     */
    toggleRow(rowId) {
        if (this.isClosed(rowId)) {
            this.closedRows.delete(rowId);
        } else {
            this.closedRows.add(rowId);
        }
        this.notify();
    }

    async toggleDisplayMode() {
        this.displayParams.displayMode =
            this.displayParams.displayMode === "dense" ? "sparse" : "dense";
        this.notify();
    }

    async updatePagerParams({ limit, offset }) {
        await this.fetchData({ pagerLimit: limit, pagerOffset: offset });
    }

    //-------------------------------------------------------------------------
    // Protected
    //-------------------------------------------------------------------------

    /**
     * Return a copy of this.metaData or of the last copy, extended with optional
     * params. This is useful for async methods that need to modify this.metaData,
     * but it can't be done in place directly for the model to be concurrency
     * proof (so they work on a copy and commit it at the end).
     *
     * @protected
     * @param {Object} params
     * @param {DateTime} [params.focusDate]
     * @param {DateTime} [params.startDate]
     * @param {DateTime} [params.stopDate]
     * @param {string[]} [params.groupedBy]
     * @param {ScaleId} [params.scaleId]
     * @returns {MetaData}
     */
    _buildMetaData(params = {}) {
        this._nextMetaData = { ...(this._nextMetaData || this.metaData) };

        if (params.groupedBy) {
            this._nextMetaData.groupedBy = params.groupedBy;
        }
        if (params.scaleId) {
            browser.localStorage.setItem(this._getLocalStorageKey(), params.scaleId);
            this._nextMetaData.scale = { ...this._nextMetaData.scales[params.scaleId] };
        }
        if (params.focusDate) {
            this._nextMetaData.focusDate = params.focusDate;
        }
        if (params.startDate) {
            this._nextMetaData.startDate = params.startDate;
        }
        if (params.stopDate) {
            this._nextMetaData.stopDate = params.stopDate;
        }
        if (params.rangeId) {
            this._nextMetaData.rangeId = params.rangeId;
        }

        if ("pagerLimit" in params) {
            this._nextMetaData.pagerLimit = params.pagerLimit;
        }
        if ("pagerOffset" in params) {
            this._nextMetaData.pagerOffset = params.pagerOffset;
        }

        if ("scaleId" in params || "startDate" in params || "stopDate" in params) {
            // we assume that scale, startDate, and stopDate are already set in this._nextMetaData

            let exchange = false;
            if (this._nextMetaData.startDate > this._nextMetaData.stopDate) {
                exchange = true;
                const temp = this._nextMetaData.startDate;
                this._nextMetaData.startDate = this._nextMetaData.stopDate;
                this._nextMetaData.stopDate = temp;
            }
            const { interval } = this._nextMetaData.scale;

            const rightLimit = this._nextMetaData.startDate.plus({ year: 10, day: -1 });
            if (this._nextMetaData.stopDate > rightLimit) {
                if (exchange) {
                    this._nextMetaData.startDate = this._nextMetaData.stopDate.minus({
                        year: 10,
                        day: -1,
                    });
                } else {
                    this._nextMetaData.stopDate = this._nextMetaData.startDate.plus({
                        year: 10,
                        day: -1,
                    });
                }
            }
            this._nextMetaData.globalStart = firstColumnBefore(
                this._nextMetaData.startDate,
                interval
            );
            this._nextMetaData.globalStop = firstColumnAfter(
                this._nextMetaData.stopDate.plus({ day: 1 }),
                interval
            );

            if (params.currentFocusDate) {
                this._nextMetaData.focusDate = params.currentFocusDate;
                if (this._nextMetaData.focusDate < this._nextMetaData.startDate) {
                    this._nextMetaData.focusDate = this._nextMetaData.startDate;
                } else if (this._nextMetaData.stopDate < this._nextMetaData.focusDate) {
                    this._nextMetaData.focusDate = this._nextMetaData.stopDate;
                }
            }
        }

        return this._nextMetaData;
    }

    /**
     * Fetches records to display (and groups if necessary).
     *
     * @protected
     * @param {MetaData} metaData
     * @param {Object} [additionalContext]
     */
    async _fetchData(metaData, additionalContext) {
        const { globalStart, globalStop, groupedBy, pagerLimit, pagerOffset, resModel, scale } =
            metaData;
        const context = {
            ...this.searchParams.context,
            group_by: groupedBy,
            ...additionalContext,
        };
        const domain = this._getDomain(metaData);
        const fields = this._getFields(metaData);
        const specification = {};
        for (const fieldName of fields) {
            specification[fieldName] = {};
            if (metaData.fields[fieldName].type === "many2one") {
                specification[fieldName].fields = { display_name: {} };
            }
        }

        const { length, groups, records, progress_bars, unavailabilities } =
            await this.keepLast.add(
                this.orm.call(resModel, "get_gantt_data", [], {
                    domain,
                    groupby: groupedBy,
                    read_specification: specification,
                    scale: scale.unit,
                    start_date: serializeDateTime(globalStart),
                    stop_date: serializeDateTime(globalStop),
                    unavailability_fields: this._getUnavailabilityFields(metaData),
                    progress_bar_fields: this._getProgressBarFields(metaData),
                    context,
                    limit: pagerLimit,
                    offset: pagerOffset,
                })
            );

        groups.forEach((g) => (g.fromServer = true));

        const data = { count: length };

        data.records = this._parseServerData(metaData, records);
        data.rows = this._generateRows(metaData, {
            groupedBy,
            groups,
            parentGroup: [],
        });
        data.unavailabilities = this._processUnavailabilities(unavailabilities);
        data.progressBars = this._processProgressBars(progress_bars);

        await this.keepLast.add(this._fetchDataPostProcess(metaData, data));

        this.data = data;
        this.metaData = metaData;
        this._nextMetaData = null;
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @param {Data} data
     */
    async _fetchDataPostProcess(metaData, data) {}

    /**
     * Remove date in groupedBy field
     *
     * @protected
     * @param {MetaData} metaData
     * @param {string[]} groupedBy
     * @returns {string[]}
     */
    _filterDateIngroupedBy(metaData, groupedBy) {
        return groupedBy.filter((gb) => {
            const [fieldName] = gb.split(":");
            const { type } = metaData.fields[fieldName];
            return !["date", "datetime"].includes(type);
        });
    }

    /**
     * @protected
     * @param {number} floatVal
     * @param {string}
     */
    _formatTime(floatVal) {
        const timeStr = formatFloatTime(floatVal, { noLeadingZeroHour: true });
        const [hourStr, minuteStr] = timeStr.split(":");
        const hour = parseInt(hourStr, 10);
        const minute = parseInt(minuteStr, 10);
        return minute ? _t("%(hour)sh%(minute)s", { hour, minute }) : _t("%sh", hour);
    }

    /**
     * Process groups to generate a recursive structure according
     * to groupedBy fields. Note that there might be empty groups (filled by
     * read_goup with group_expand) that also need to be processed.
     *
     * @protected
     * @param {MetaData} metaData
     * @param {Object} params
     * @param {Object[]} params.groups
     * @param {string[]} params.groupedBy
     * @param {Object[]} params.parentGroup
     * @returns {Row[]}
     */
    _generateRows(metaData, params) {
        const groupedBy = params.groupedBy;
        const groups = params.groups;
        const groupLevel = metaData.groupedBy.length - groupedBy.length;
        const parentGroup = params.parentGroup;

        if (!groupedBy.length || !groups.length) {
            const recordIds = [];
            for (const g of groups) {
                recordIds.push(...(g.__record_ids || []));
            }
            const part = parentGroup.at(-1);
            const [[parentGroupedField, value]] = part ? Object.entries(part) : [[]];
            return [
                {
                    groupLevel,
                    id: JSON.stringify([...parentGroup, {}]),
                    name: "",
                    recordIds: unique(recordIds),
                    parentGroupedField,
                    parentResId: Array.isArray(value) ? value[0] : value,
                    __extra__: true,
                },
            ];
        }

        /** @type {Row[]} */
        const rows = [];

        // Some groups might be empty (thanks to expand_groups), so we can't
        // simply group the data, we need to keep all returned groups
        const groupedByField = groupedBy[0];
        const currentLevelGroups = groupBy(groups, (g) => {
            if (g[groupedByField] === undefined) {
                // we want to group the groups with undefined values for groupedByField with the ones
                // with false value for the same field.
                // we also want to be sure that stringification keeps groupedByField:
                // JSON.stringify({ key: undefined }) === "{}"
                // see construction of id below.
                g[groupedByField] = false;
            }
            return g[groupedByField];
        });
        const { maxField } = metaData.consolidationParams;
        const consolidate = groupLevel === 0 && groupedByField === maxField;
        const generateSubRow = maxField ? true : groupedBy.length > 1;
        for (const key in currentLevelGroups) {
            const subGroups = currentLevelGroups[key];
            const value = subGroups[0][groupedByField];
            const part = {};
            part[groupedByField] = value;
            const fakeGroup = [...parentGroup, part];
            const id = JSON.stringify(fakeGroup);
            const resId = Array.isArray(value) ? value[0] : value; // not really a resId
            const fromServer = subGroups.some((g) => g.fromServer);
            const recordIds = [];
            for (const g of subGroups) {
                recordIds.push(...(g.__record_ids || []));
            }
            const row = {
                consolidate,
                fromServer,
                groupedBy,
                groupedByField,
                groupLevel,
                id,
                name: this._getRowName(metaData, groupedByField, value),
                resId, // not really a resId
                recordIds: unique(recordIds),
            };
            if (generateSubRow) {
                row.rows = this._generateRows(metaData, {
                    ...params,
                    groupedBy: groupedBy.slice(1),
                    groups: subGroups,
                    parentGroup: fakeGroup,
                });
            }
            if (resId === false) {
                rows.unshift(row);
            } else {
                rows.push(row);
            }
        }

        return rows;
    }

    /**
     * Get domain of records to display in the gantt view.
     *
     * @protected
     * @param {MetaData} metaData
     * @returns {any[]}
     */
    _getDomain(metaData) {
        const { dateStartField, dateStopField, globalStart, globalStop } = metaData;
        const domain = Domain.and([
            this.searchParams.domain,
            [
                "&",
                [
                    dateStartField,
                    "<",
                    this.dateStopFieldIsDate(metaData)
                        ? serializeDate(globalStop)
                        : serializeDateTime(globalStop),
                ],
                [
                    dateStopField,
                    this.dateStartFieldIsDate(metaData) ? ">=" : ">",
                    this.dateStartFieldIsDate(metaData)
                        ? serializeDate(globalStart)
                        : serializeDateTime(globalStart),
                ],
            ],
        ]);
        return domain.toList();
    }

    /**
     * Format field value to display purpose.
     *
     * @protected
     * @param {any} value
     * @param {Object} field
     * @returns {string} formatted field value
     */
    _getFieldFormattedValue(value, field) {
        if (field.type === "boolean") {
            return value ? "True" : "False";
        } else if (!value) {
            return _t("Undefined %s", field.string);
        } else if (field.type === "many2many") {
            return value[1];
        }
        const formatter = registry.category("formatters").get(field.type);
        return formatter(value, field);
    }

    /**
     * Get all the fields needed.
     *
     * @protected
     * @param {MetaData} metaData
     * @returns {string[]}
     */
    _getFields(metaData) {
        const fields = new Set([
            "display_name",
            metaData.dateStartField,
            metaData.dateStopField,
            ...metaData.groupedBy,
            ...metaData.decorationFields,
        ]);
        if (metaData.colorField) {
            fields.add(metaData.colorField);
        }
        if (metaData.consolidationParams.field) {
            fields.add(metaData.consolidationParams.field);
        }
        if (metaData.consolidationParams.excludeField) {
            fields.add(metaData.consolidationParams.excludeField);
        }
        if (metaData.dependencyField) {
            fields.add(metaData.dependencyField);
        }
        if (metaData.progressField) {
            fields.add(metaData.progressField);
        }
        return [...fields];
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @param {{ groupBy: string[] }} searchParams
     * @returns {string[]}
     */
    _getGroupedBy(metaData, searchParams) {
        let groupedBy = [...searchParams.groupBy];
        groupedBy = groupedBy.filter((gb) => {
            const [fieldName] = gb.split(".");
            const field = metaData.fields[fieldName];
            return field?.type !== "properties";
        });
        groupedBy = this._filterDateIngroupedBy(metaData, groupedBy);
        if (!groupedBy.length) {
            groupedBy = metaData.defaultGroupBy;
        }
        return groupedBy;
    }

    _getDefaultFocusDate(metaData, searchParams, scaleId) {
        const { context } = searchParams;
        let focusDate =
            "initialDate" in context ? deserializeDateTime(context.initialDate) : DateTime.local();
        focusDate = focusDate.startOf("day");
        if (metaData.offset) {
            const { unit } = metaData.scales[scaleId];
            focusDate = focusDate.plus({ [unit]: metaData.offset });
        }
        return focusDate;
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @param {{ context: Record<string, any> }} searchParams
     * @returns {{ focusDate: DateTime, scaleId: ScaleId, startDate: DateTime, stopDate: DateTime }}
     */
    _getInitialRangeParams(metaData, searchParams) {
        const { context } = searchParams;
        const localScaleId = this._getScaleIdFromLocalStorage(metaData);
        /** @type {ScaleId} */
        const scaleId = localScaleId || context.default_scale || metaData.defaultScale;
        const { defaultRange } = metaData.scales[scaleId];

        const rangeId =
            context.default_range in metaData.ranges
                ? context.range_type
                : metaData.defaultRange || "custom";
        let focusDate;
        if (rangeId in metaData.ranges) {
            focusDate = this._getDefaultFocusDate(metaData, searchParams, scaleId);
            return { scaleId, ...getRangeFromDate(rangeId, focusDate) };
        }
        let startDate = context.default_start_date && deserializeDate(context.default_start_date);
        let stopDate = context.default_stop_date && deserializeDate(context.default_stop_date);
        if (!startDate && !stopDate) {
            /** @type {DateTime} */
            focusDate = this._getDefaultFocusDate(metaData, searchParams, scaleId);
            startDate = firstColumnBefore(focusDate, defaultRange.unit);
            stopDate = startDate
                .plus({ [defaultRange.unit]: defaultRange.count })
                .minus({ day: 1 });
        } else if (startDate && !stopDate) {
            const column = firstColumnBefore(startDate, defaultRange.unit);
            focusDate = startDate;
            stopDate = column.plus({ [defaultRange.unit]: defaultRange.count }).minus({ day: 1 });
        } else if (!startDate && stopDate) {
            const column = firstColumnAfter(stopDate, defaultRange.unit);
            focusDate = stopDate;
            startDate = column.minus({ [defaultRange.unit]: defaultRange.count });
        } else {
            focusDate = DateTime.local();
            if (focusDate < startDate) {
                focusDate = startDate;
            } else if (focusDate > stopDate) {
                focusDate = stopDate;
            }
        }

        return { focusDate, scaleId, startDate, stopDate, rangeId };
    }

    _getLocalStorageKey() {
        return `scaleOf-viewId-${this.env.config.viewId}`;
    }

    _getProgressBarFields(metaData) {
        if (metaData.progressBarFields && !this.orm.isSample) {
            return metaData.progressBarFields.filter(
                (fieldName) =>
                    metaData.groupedBy.includes(fieldName) &&
                    ["many2many", "many2one"].includes(metaData.fields[fieldName]?.type)
            );
        }
        return [];
    }

    _getRescheduleContext() {
        return { ...this.searchParams.context };
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @param {string} groupedByField
     * @param {any} value
     * @returns {string}
     */
    _getRowName(metaData, groupedByField, value) {
        const field = metaData.fields[groupedByField];
        return this._getFieldFormattedValue(value, field);
    }

    _getScaleIdFromLocalStorage(metaData) {
        const { scales } = metaData;
        const localScaleId = browser.localStorage.getItem(this._getLocalStorageKey());
        return localScaleId in scales ? localScaleId : null;
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @returns {string[]}
     */
    _getUnavailabilityFields(metaData) {
        if (metaData.displayUnavailability && !this.orm.isSample && metaData.groupedBy.length) {
            const lastGroupBy = metaData.groupedBy.at(-1);
            const { type } = metaData.fields[lastGroupBy] || {};
            if (["many2many", "many2one"].includes(type)) {
                return [lastGroupBy];
            }
        }
        return [];
    }

    /**
     * @protected
     * @param {MetaData} metaData
     * @param {Record<string, any>[]} records the server records to parse
     * @returns {Record<string, any>[]}
     */
    _parseServerData(metaData, records) {
        const { dateStartField, dateStopField, fields, globalStart, globalStop } = metaData;
        /** @type {Record<string, any>[]} */
        const parsedRecords = [];
        for (const record of records) {
            const parsedRecord = parseServerValues(fields, record);
            const dateStart = parsedRecord[dateStartField];
            const dateStop = parsedRecord[dateStopField];
            if (this.orm.isSample) {
                // In sample mode, we want enough data to be displayed, so we
                // swap the dates as the records are randomly generated anyway.
                if (dateStart > dateStop) {
                    parsedRecord[dateStartField] = dateStop;
                    parsedRecord[dateStopField] = dateStart;
                }
                // Record could also be outside the displayed range since the
                // sample server doesn't take the domain into account
                if (parsedRecord[dateStopField] < globalStart) {
                    parsedRecord[dateStopField] = globalStart;
                }
                if (parsedRecord[dateStartField] > globalStop) {
                    parsedRecord[dateStartField] = globalStop;
                }
                parsedRecords.push(parsedRecord);
            } else if (dateStart <= dateStop) {
                parsedRecords.push(parsedRecord);
            }
        }
        return parsedRecords;
    }

    _processProgressBar(progressBar, warning) {
        const processedProgressBar = {
            ...progressBar,
            value_formatted: this._formatTime(progressBar.value),
            max_value_formatted: this._formatTime(progressBar.max_value),
            ratio: progressBar.max_value ? (progressBar.value / progressBar.max_value) * 100 : 0,
            warning,
        };
        if (processedProgressBar?.max_value) {
            processedProgressBar.ratio_formatted = formatPercentage(
                processedProgressBar.ratio / 100
            );
        }
        return processedProgressBar;
    }

    _processProgressBars(progressBars) {
        const processedProgressBars = {};
        for (const fieldName in progressBars) {
            processedProgressBars[fieldName] = {};
            const progressBarInfo = progressBars[fieldName];
            for (const [resId, progressBar] of Object.entries(progressBarInfo)) {
                processedProgressBars[fieldName][resId] = this._processProgressBar(
                    progressBar,
                    progressBarInfo.warning
                );
            }
        }
        return processedProgressBars;
    }

    _processUnavailabilities(unavailabilities) {
        const processedUnavailabilities = {};
        for (const fieldName in unavailabilities) {
            processedUnavailabilities[fieldName] = {};
            for (const [resId, resUnavailabilities] of Object.entries(
                unavailabilities[fieldName]
            )) {
                processedUnavailabilities[fieldName][resId] = resUnavailabilities.map((u) => ({
                    start: deserializeDateTime(u.start),
                    stop: deserializeDateTime(u.stop),
                }));
            }
        }
        return processedUnavailabilities;
    }

    /**
     * @template {Record<string, any>} T
     * @param {T} schedule
     * @returns {Partial<T>}
     */
    _scheduleToData(schedule) {
        const allowedFields = [
            this.metaData.dateStartField,
            this.metaData.dateStopField,
            ...this.metaData.groupedBy,
        ];
        return pick(schedule, ...allowedFields);
    }
}

return __exports;
});
;

/*****************************************************
*  Filepath: /web_gantt/static/src/gantt_popover.js  *
*  Lines: 65                                         *
*****************************************************/
odoo.define('@web_gantt/gantt_popover', ['@odoo/owl', '@web/views/view_button/view_button', '@web/views/view_button/view_button_hook', '@web/views/view_compiler', '@web_gantt/gantt_compiler'], function (require) {
'use strict';
let __exports = {};
const { Component, useRef } = require("@odoo/owl");
const { ViewButton } = require("@web/views/view_button/view_button");
const { useViewButtons } = require("@web/views/view_button/view_button_hook");
const { useViewCompiler } = require("@web/views/view_compiler");
const { GanttCompiler } = require("@web_gantt/gantt_compiler");

const GanttPopover = __exports.GanttPopover = class GanttPopover extends Component {
    static template = "web_gantt.GanttPopover";
    static components = { ViewButton };
    static props = [
        "title",
        "displayGenericButtons",
        "bodyTemplate?",
        "footerTemplate?",
        "resModel",
        "resId",
        "context",
        "close",
        "reload",
        "buttons",
    ];

    setup() {
        this.rootRef = useRef("root");

        this.templates = { body: "web_gantt.GanttPopover.default" };
        const toCompile = {};
        const { bodyTemplate, footerTemplate } = this.props;
        if (bodyTemplate) {
            toCompile.body = bodyTemplate;
            if (footerTemplate) {
                toCompile.footer = footerTemplate;
            }
        }
        Object.assign(
            this.templates,
            useViewCompiler(GanttCompiler, toCompile, { recordExpr: "__record__" })
        );

        useViewButtons(this.rootRef, {
            reload: async () => {
                await this.props.reload();
                this.props.close();
            },
        });
    }

    get renderingContext() {
        return Object.assign({}, this.props.context, {
            __comp__: this,
            __record__: { resModel: this.props.resModel, resId: this.props.resId },
        });
    }

    async onClick(button) {
        await button.onClick();
        this.props.close();
    }
}

return __exports;
});
;

/***************************************************************
*  Filepath: /web_gantt/static/src/gantt_popover_in_dialog.js  *
*  Lines: 17                                                   *
***************************************************************/
odoo.define('@web_gantt/gantt_popover_in_dialog', ['@odoo/owl', '@web/core/dialog/dialog'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");

const GanttPopoverInDialog = __exports.GanttPopoverInDialog = class GanttPopoverInDialog extends Component {
    static components = { Dialog };
    static props = ["close", "component", "componentProps", "dialogTitle"];
    static template = "web_gantt.GanttPopoverInDialog";
    get componentProps() {
        return { ...this.props.componentProps, close: this.props.close };
    }
}

return __exports;
});
;

/******************************************************
*  Filepath: /web_gantt/static/src/gantt_renderer.js  *
*  Lines: 2564                                        *
******************************************************/
odoo.define('@web_gantt/gantt_renderer', ['@odoo/owl', '@web/core/browser/feature_detection', '@web/core/domain', '@web/core/l10n/dates', '@web/core/l10n/localization', '@web/core/l10n/translation', '@web/core/popover/popover_hook', '@web/core/py_js/py', '@web/core/user', '@web/core/utils/hooks', '@web/core/utils/objects', '@web/core/utils/timing', '@web/core/utils/urls', '@web/core/utils/strings', '@web/core/virtual_grid_hook', '@web/views/fields/formatters', '@web/views/view_dialogs/select_create_dialog', '@web_gantt/gantt_connector', '@web_gantt/gantt_helpers', '@web_gantt/gantt_popover', '@web_gantt/gantt_renderer_controls', '@web_gantt/gantt_resize_badge', '@web_gantt/gantt_row_progress_bar', '@web/core/utils/numbers'], function (require) {
'use strict';
let __exports = {};
const {
    Component,
    onWillRender,
    onWillStart,
    onWillUpdateProps,
    reactive,
    useEffect,
    useExternalListener,
    useRef,
    markup,
} = require("@odoo/owl");
const { hasTouch, isMobileOS } = require("@web/core/browser/feature_detection");
const { Domain } = require("@web/core/domain");
const {
    getStartOfLocalWeek,
    is24HourFormat,
    serializeDate,
    serializeDateTime,
} = require("@web/core/l10n/dates");
const { localization } = require("@web/core/l10n/localization");
const { _t } = require("@web/core/l10n/translation");
const { usePopover } = require("@web/core/popover/popover_hook");
const { evaluateBooleanExpr } = require("@web/core/py_js/py");
const { user } = require("@web/core/user");
const { useService } = require("@web/core/utils/hooks");
const { omit, pick } = require("@web/core/utils/objects");
const { debounce, throttleForAnimation } = require("@web/core/utils/timing");
const { url } = require("@web/core/utils/urls");
const { escape } = require("@web/core/utils/strings");
const { useVirtualGrid } = require("@web/core/virtual_grid_hook");
const { formatFloatTime } = require("@web/views/fields/formatters");
const { SelectCreateDialog } = require("@web/views/view_dialogs/select_create_dialog");
const { GanttConnector } = require("@web_gantt/gantt_connector");
const {
    dateAddFixedOffset,
    diffColumn,
    getCellColor,
    getColorIndex,
    localEndOf,
    localStartOf,
    useGanttConnectorDraggable,
    useGanttDraggable,
    useGanttResizable,
    useGanttSelectable,
    useGanttUndraggable,
    useMultiHover,
} = require("@web_gantt/gantt_helpers");
const { GanttPopover } = require("@web_gantt/gantt_popover");
const { GanttRendererControls } = require("@web_gantt/gantt_renderer_controls");
const { GanttResizeBadge } = require("@web_gantt/gantt_resize_badge");
const { GanttRowProgressBar } = require("@web_gantt/gantt_row_progress_bar");
const { clamp } = require("@web/core/utils/numbers");

const { DateTime } = luxon;

/**
 * @typedef {`__column__${number}`} ColumnId
 * @typedef {`__connector__${number | "new"}`} ConnectorId
 * @typedef {import("./gantt_connector").ConnectorProps} ConnectorProps
 * @typedef {luxon.DateTime} DateTime
 * @typedef {"copy" | "reschedule"} DragActionMode
 * @typedef {"drag" | "locked" | "resize"} InteractionMode
 * @typedef {`__pill__${number}`} PillId
 * @typedef {import("./gantt_model").RowId} RowId
 *
 * @typedef Column
 * @property {ColumnId} id
 * @property {GridPosition} grid
 * @property {boolean} [isToday]
 * @property {DateTime} start
 * @property {DateTime} stop
 *
 * @typedef GridPosition
 * @property {number | number[]} [row]
 * @property {number | number[]} [column]
 *
 * @typedef Group
 * @property {boolean} break
 * @property {number} col
 * @property {Pill[]} pills
 * @property {number} aggregateValue
 * @property {GridPosition} grid
 *
 * @typedef GanttRendererProps
 * @property {import("./gantt_model").GanttModel} model
 * @property {Document} arch
 * @property {string} class
 * @property {(context: Record<string, any>)} create
 * @property {{ content?: Point }} [scrollPosition]
 * @property {{ el: HTMLDivElement | null }} [contentRef]
 *
 * @typedef HoveredInfo
 * @property {Element | null} connector
 * @property {HTMLElement | null} hoverable
 * @property {HTMLElement | null} pill
 *
 * @typedef Interaction
 * @property {InteractionMode | null} mode
 * @property {DragActionMode} dragAction
 *
 * @typedef Pill
 * @property {PillId} id
 * @property {boolean} disableStartResize
 * @property {boolean} disableStopResize
 * @property {boolean} highlighted
 * @property {number} leftMargin
 * @property {number} level
 * @property {string} name
 * @property {DateTime} startDate
 * @property {DateTime} stopDate
 * @property {GridPosition} grid
 * @property {RelationalRecord} record
 * @property {number} _color
 * @property {number} _progress
 *
 * @typedef Point
 * @property {number} [x]
 * @property {number} [y]
 *
 * @typedef {Record<string, any>} RelationalRecord
 * @property {number | false} id
 *
 * @typedef ResizeBadge
 * @property {Point & { right?: number }} position
 * @property {number} diff
 * @property {string} scale
 *
 * @typedef {import("./gantt_model").Row & {
 *  grid: GridPosition,
 *  pills: Pill[],
 *  cellColors?: Record<string, string>,
 *  thumbnailUrl?: string
 * }} Row
 *
 * @typedef SubColumn
 * @property {ColumnId} columnId
 * @property {boolean} [isToday]
 * @property {DateTime} start
 * @property {DateTime} stop
 */

/** @type {[Omit<InteractionMode, "drag"> | DragActionMode, string][]} */
const INTERACTION_CLASSNAMES = [
    ["connect", "o_connect"],
    ["copy", "o_copying"],
    ["locked", "o_grabbing_locked"],
    ["reschedule", "o_grabbing"],
    ["resize", "o_resizing"],
];
const NEW_CONNECTOR_ID = "__connector__new";

/**
 * Gantt Renderer
 *
 * @extends {Component<GanttRendererProps, any>}
 */
const GanttRenderer = __exports.GanttRenderer = class GanttRenderer extends Component {
    static components = {
        GanttConnector,
        GanttRendererControls,
        GanttResizeBadge,
        GanttRowProgressBar,
        Popover: GanttPopover,
    };
    static props = [
        "model",
        "arch",
        "class",
        "create",
        "openDialog",
        "scrollPosition?",
        "contentRef?",
    ];

    static template = "web_gantt.GanttRenderer";
    static connectorCreatorTemplate = "web_gantt.GanttRenderer.ConnectorCreator";
    static headerTemplate = "web_gantt.GanttRenderer.Header";
    static pillTemplate = "web_gantt.GanttRenderer.Pill";
    static groupPillTemplate = "web_gantt.GanttRenderer.GroupPill";
    static rowContentTemplate = "web_gantt.GanttRenderer.RowContent";
    static rowHeaderTemplate = "web_gantt.GanttRenderer.RowHeader";
    static totalRowTemplate = "web_gantt.GanttRenderer.TotalRow";

    static getRowHeaderWidth = (width) => 100 / (width > 768 ? 6 : 3);

    setup() {
        this.model = this.props.model;

        this.gridRef = useRef("grid");
        this.cellContainerRef = useRef("cellContainer");

        this.actionService = useService("action");
        this.dialogService = useService("dialog");
        this.notificationService = useService("notification");
        this.orm = useService("orm");

        this.is24HourFormat = is24HourFormat();

        /** @type {HoveredInfo} */
        this.hovered = {
            connector: null,
            hoverable: null,
            pill: null,
        };

        /** @type {Interaction} */
        this.interaction = reactive(
            {
                mode: null,
                dragAction: "reschedule",
            },
            () => this.onInteractionChange()
        );
        this.onInteractionChange(); // Used to hook into "interaction"
        /** @type {Record<ConnectorId, ConnectorProps>} */
        this.connectors = reactive({});
        this.progressBarsReactive = reactive({ hoveredRowId: null });
        /** @type {ResizeBadge} */
        this.resizeBadgeReactive = reactive({});

        /** @type {Object[]} */
        this.columnsGroups = [];
        /** @type {Column[]} */
        this.columns = [];
        /** @type {Pill[]} */
        this.extraPills = [];
        /** @type {Record<PillId, Pill>} */
        this.pills = {}; // mapping to retrieve pills from pill ids
        /** @type {Row[]} */
        this.rows = [];
        /** @type {SubColumn[]} */
        this.subColumns = [];
        /** @type {Record<RowId, Pill[]>} */
        this.rowPills = {};

        this.mappingColToColumn = new Map();
        this.mappingColToSubColumn = new Map();
        this.cursorPosition = {
            x: 0,
            y: 0,
        };
        const position = "bottom";
        this.popover = usePopover(this.constructor.components.Popover, {
            position,
            onPositioned: (el, { direction }) => {
                if (direction !== position) {
                    return;
                }
                const { left, right } = el.getBoundingClientRect();
                if ((0 <= left && right <= window.innerWidth) || window.innerWidth < right - left) {
                    return;
                }
                const { left: pillLeft, right: pillRight } =
                    this.popover.target.getBoundingClientRect();
                const middle =
                    (clamp(pillLeft, 0, window.innerWidth) +
                        clamp(pillRight, 0, window.innerWidth)) /
                    2;
                el.style.left = `0px`;
                const { width } = el.getBoundingClientRect();
                el.style.left = `${middle - width / 2}px`;
            },
            onClose: () => {
                delete this.popover.target;
            },
        });

        this.throttledComputeHoverParams = throttleForAnimation((ev) =>
            this.computeHoverParams(ev)
        );

        useExternalListener(window, "keydown", (ev) => this.onWindowKeyDown(ev));
        useExternalListener(window, "keyup", (ev) => this.onWindowKeyUp(ev));

        useExternalListener(
            window,
            "resize",
            debounce(() => {
                this.shouldComputeSomeWidths = true;
                this.render();
            }, 100)
        );

        useMultiHover({
            ref: this.gridRef,
            selector: ".o_gantt_group",
            related: ["data-row-id"],
            className: "o_gantt_group_hovered",
        });

        // Draggable pills
        this.cellForDrag = { el: null, part: 0 };
        const dragState = useGanttDraggable({
            enable: () => Boolean(this.cellForDrag.el),
            // Refs and selectors
            ref: this.gridRef,
            hoveredCell: this.cellForDrag,
            elements: ".o_draggable",
            ignore: ".o_resize_handle,.o_connector_creator_bullet",
            cells: ".o_gantt_cell",
            // Style classes
            cellDragClassName: "o_gantt_cell o_drag_hover",
            ghostClassName: "o_dragged_pill_ghost",
            addStickyCoordinates: (rows, columns) => {
                this.stickyGridRows = Object.assign({}, ...rows.map((row) => ({ [row]: true })));
                this.stickyGridColumns = Object.assign(
                    {},
                    ...columns.map((column) => ({ [column]: true }))
                );
                this.setSomeGridStyleProperties();
            },
            // Handlers
            onDragStart: ({ pill }) => {
                this.popover.close();
                this.setStickyPill(pill);
                this.interaction.mode = "drag";
            },
            onDragEnd: () => {
                this.setStickyPill();
                this.interaction.mode = null;
            },
            onDrop: (params) => this.dragPillDrop(params),
        });

        // Un-draggable pills
        const unDragState = useGanttUndraggable({
            // Refs and selectors
            ref: this.gridRef,
            elements: ".o_undraggable",
            ignore: ".o_resize_handle,.o_connector_creator_bullet",
            edgeScrolling: { enabled: false },
            // Handlers
            onDragStart: () => {
                this.interaction.mode = "locked";
            },
            onDragEnd: () => {
                this.interaction.mode = null;
            },
        });

        // Cells selection
        const selectState = useGanttSelectable({
            enable: () => {
                const { canCellCreate, canPlan } = this.model.metaData;
                return Boolean(this.cellForDrag.el) && (canCellCreate || canPlan);
            },
            ref: this.gridRef,
            hoveredCell: this.cellForDrag,
            elements: ".o_gantt_cell:not(.o_gantt_group)",
            edgeScrolling: { speed: 40, threshold: 150, direction: "horizontal" },
            rtl: () => localization.direction === "rtl",
            onDrop: ({ rowId, startCol, stopCol }) => {
                const { canPlan } = this.model.metaData;
                if (canPlan) {
                    this.onPlan(rowId, startCol, stopCol);
                } else {
                    this.onCreate(rowId, startCol, stopCol);
                }
            },
        });

        // Resizable pills
        const resizeState = useGanttResizable({
            // Refs and selectors
            ref: this.gridRef,
            hoveredCell: this.cellForDrag,
            elements: ".o_resizable",
            innerPills: ".o_gantt_pill",
            cells: ".o_gantt_cell",
            // Other params
            handles: "o_resize_handle",
            edgeScrolling: { speed: 40, threshold: 150, direction: "horizontal" },
            showHandles: (pillEl) => {
                const pill = this.pills[pillEl.dataset.pillId];
                const hideHandles = this.connectorDragState.dragging;
                return {
                    start: !pill.disableStartResize && !hideHandles,
                    end: !pill.disableStopResize && !hideHandles,
                };
            },
            rtl: () => localization.direction === "rtl",
            precision: () => this.model.metaData.scale.cellPart,
            // Handlers
            onDragStart: ({ pill, addClass }) => {
                this.popover.close();
                this.setStickyPill(pill);
                addClass(pill, "o_resized");
                this.interaction.mode = "resize";
            },
            onDrag: ({ pill, grabbedHandle, diff }) => {
                const rect = pill.getBoundingClientRect();
                const position = { top: rect.y + rect.height };
                if (grabbedHandle === "left") {
                    position.left = rect.x;
                } else {
                    position.right = document.body.offsetWidth - rect.x - rect.width;
                }
                const { cellTime, unitDescription } = this.model.metaData.scale;
                Object.assign(this.resizeBadgeReactive, {
                    position,
                    diff: diff * cellTime,
                    scale: unitDescription,
                });
            },
            onDragEnd: ({ pill, removeClass }) => {
                delete this.resizeBadgeReactive.position;
                delete this.resizeBadgeReactive.diff;
                delete this.resizeBadgeReactive.scale;
                this.setStickyPill();
                removeClass(pill, "o_resized");
                this.interaction.mode = null;
            },
            onDrop: (params) => this.resizePillDrop(params),
        });

        // Draggable connector
        let initialPillId;
        this.connectorDragState = useGanttConnectorDraggable({
            ref: this.gridRef,
            elements: ".o_connector_creator_bullet",
            parentWrapper: ".o_gantt_cells .o_gantt_pill_wrapper",
            onDragStart: ({ sourcePill, x, y, addClass }) => {
                this.popover.close();
                initialPillId = sourcePill.dataset.pillId;
                addClass(sourcePill, "o_connector_creator_lock");
                this.setConnector({
                    id: NEW_CONNECTOR_ID,
                    highlighted: true,
                    sourcePoint: { left: x, top: y },
                    targetPoint: { left: x, top: y },
                });
                this.setStickyPill(sourcePill);
                this.interaction.mode = "connect";
            },
            onDrag: ({ connectorCenter, x, y }) => {
                this.setConnector({
                    id: NEW_CONNECTOR_ID,
                    sourcePoint: { left: connectorCenter.x, top: connectorCenter.y },
                    targetPoint: { left: x, top: y },
                });
            },
            onDragEnd: () => {
                this.setConnector({ id: NEW_CONNECTOR_ID, sourcePoint: null, targetPoint: null });
                this.setStickyPill();
                this.interaction.mode = null;
            },
            onDrop: ({ target }) => {
                if (initialPillId === target.dataset.pillId) {
                    return;
                }
                const { id: masterId } = this.pills[initialPillId].record;
                const { id: slaveId } = this.pills[target.dataset.pillId].record;
                this.model.createDependency(masterId, slaveId);
            },
        });

        this.dragStates = [dragState, unDragState, resizeState, selectState];

        onWillStart(this.computeDerivedParams);
        onWillUpdateProps(this.computeDerivedParams);

        this.virtualGrid = useVirtualGrid({
            scrollableRef: this.props.contentRef,
            initialScroll: this.props.scrollPosition,
            bufferCoef: 0.1,
            onChange: (changed) => {
                if ("columnsIndexes" in changed) {
                    this.shouldComputeGridColumns = true;
                }
                if ("rowsIndexes" in changed) {
                    this.shouldComputeGridRows = true;
                }
                this.render();
            },
        });

        onWillRender(this.onWillRender);

        useEffect(
            (content) => {
                content.addEventListener("scroll", this.throttledComputeHoverParams);
                return () => {
                    content.removeEventListener("scroll", this.throttledComputeHoverParams);
                };
            },
            () => [this.gridRef.el?.parentElement]
        );

        useEffect(() => {
            if (this.useFocusDate) {
                this.useFocusDate = false;
                this.focusDate(this.model.metaData.focusDate);
            }
        });

        this.env.getCurrentFocusDateCallBackRecorder.add(this, this.getCurrentFocusDate.bind(this));
    }

    //-------------------------------------------------------------------------
    // Getters
    //-------------------------------------------------------------------------

    get controlsProps() {
        return {
            displayExpandCollapseButtons: this.rows[0]?.isGroup, // all rows on same level have same type
            model: this.model,
            focusToday: () => this.focusToday(),
            getCurrentFocusDate: () => this.getCurrentFocusDate(),
        };
    }

    /**
     * @returns {boolean}
     */
    get hasRowHeaders() {
        const { groupedBy } = this.model.metaData;
        const { displayMode } = this.model.displayParams;
        return groupedBy.length || displayMode === "sparse";
    }

    get isDragging() {
        return this.dragStates.some((s) => s.dragging);
    }

    /**
     * @returns {boolean}
     */
    get isTouchDevice() {
        return isMobileOS() || hasTouch();
    }

    //-------------------------------------------------------------------------
    // Methods
    //-------------------------------------------------------------------------

    /**
     *
     * @param {Object} param
     * @param {Object} param.grid
     */
    addCoordinatesToCoarseGrid({ grid }) {
        if (grid.row) {
            this.coarseGridRows[this.getFirstGridRow({ grid })] = true;
            this.coarseGridRows[this.getLastGridRow({ grid })] = true;
        }
        if (grid.column) {
            this.coarseGridCols[this.getFirstGridCol({ grid })] = true;
            this.coarseGridCols[this.getLastGridCol({ grid })] = true;
        }
    }

    /**
     * @param {Pill} pill
     * @param {Group} group
     */
    addTo(pill, group) {
        group.pills.push(pill);
        group.aggregateValue++; // pill count
        return true;
    }

    /**
     * Conditional function for aggregating pills when grouping the gantt view
     * The first, unused parameter is added in case it's needed when overwriting the method.
     * @param {Row} row
     * @param {Group} group
     * @returns {boolean}
     */
    shouldAggregate(row, group) {
        return Boolean(group.pills.length);
    }

    /**
     * Aggregates overlapping pills in group rows.
     *
     * @param {Pill[]} pills
     * @param {Row} row
     */
    aggregatePills(pills, row) {
        /** @type {Record<number, Group>} */
        const groups = {};
        function getGroup(col) {
            if (!(col in groups)) {
                groups[col] = {
                    break: false,
                    col,
                    pills: [],
                    aggregateValue: 0,
                    grid: { column: [col, col + 1] },
                };
                // group.break = true means that the group cannot be merged with the previous one
                // We will merge groups that can be merged together (if this.shouldMergeGroups returns true)
            }
            return groups[col];
        }

        const lastCol = this.columnCount * this.model.metaData.scale.cellPart + 1;
        for (const pill of pills) {
            let addedInPreviousCol = false;
            let col;
            for (col = this.getFirstGridCol(pill); col < this.getLastGridCol(pill); col++) {
                const group = getGroup(col);
                const added = this.addTo(pill, group);
                if (addedInPreviousCol !== added) {
                    group.break = true;
                }
                addedInPreviousCol = added;
            }
            // here col = this.getLastGridCol(pill)
            if (addedInPreviousCol && col < lastCol) {
                const group = getGroup(col);
                group.break = true;
            }
        }

        const filteredGroups = Object.values(groups).filter((g) => this.shouldAggregate(row, g));

        if (this.shouldMergeGroups()) {
            return this.mergeGroups(filteredGroups);
        }

        return filteredGroups;
    }

    /**
     * Compute minimal levels required to display all pills without overlapping.
     * Side effect: level key is modified in pills.
     *
     * @param {Pill[]} pills
     */
    calculatePillsLevel(pills) {
        const firstPill = pills[0];
        firstPill.level = 0;
        const levels = [
            {
                pills: [firstPill],
                maxCol: this.getLastGridCol(firstPill) - 1,
            },
        ];
        for (const currentPill of pills.slice(1)) {
            const lastCol = this.getLastGridCol(currentPill) - 1;
            for (let l = 0; l < levels.length; l++) {
                const level = levels[l];
                if (this.getFirstGridCol(currentPill) > level.maxCol) {
                    currentPill.level = l;
                    level.pills.push(currentPill);
                    level.maxCol = lastCol;
                    break;
                }
            }
            if (isNaN(currentPill.level)) {
                currentPill.level = levels.length;
                levels.push({
                    pills: [currentPill],
                    maxCol: lastCol,
                });
            }
        }
        return levels.length;
    }

    makeSubColumn(start, delta, cellTime, time) {
        const subCellStart = dateAddFixedOffset(start, { [time]: delta * cellTime });
        const subCellStop = dateAddFixedOffset(start, {
            [time]: (delta + 1) * cellTime,
            seconds: -1,
        });
        return { start: subCellStart, stop: subCellStop };
    }

    computeVisibleColumns() {
        const [firstIndex, lastIndex] = this.virtualGrid.columnsIndexes;
        this.columnsGroups = [];
        this.columns = [];
        this.subColumns = [];
        this.coarseGridCols = {
            1: true,
            [this.columnCount * this.model.metaData.scale.cellPart + 1]: true,
        };

        const { globalStart, globalStop, scale } = this.model.metaData;
        const { cellPart, interval, unit } = scale;

        const now = DateTime.local();

        const nowStart = now.startOf(interval);
        const nowEnd = now.endOf(interval);

        const groupsLeftBound = DateTime.max(
            globalStart,
            localStartOf(globalStart.plus({ [interval]: firstIndex }), unit)
        );
        const groupsRightBound = DateTime.min(
            localEndOf(globalStart.plus({ [interval]: lastIndex }), unit),
            globalStop
        );
        let currentGroup = null;
        for (let j = firstIndex; j <= lastIndex; j++) {
            const columnId = `__column__${j + 1}`;
            const col = j * cellPart + 1;
            const { start, stop } = this.getColumnFromColNumber(col);
            const column = {
                id: columnId,
                grid: { column: [col, col + cellPart] },
                start,
                stop,
            };
            const isToday = nowStart <= start && start <= nowEnd;
            if (isToday) {
                column.isToday = true;
            }
            this.columns.push(column);

            for (let i = 0; i < cellPart; i++) {
                const subColumn = this.getSubColumnFromColNumber(col + i);
                this.subColumns.push({ ...subColumn, isToday, columnId });
                this.coarseGridCols[col + i] = true;
            }

            const groupStart = localStartOf(start, unit);
            if (!currentGroup || !groupStart.equals(currentGroup.start)) {
                const groupId = `__group__${this.columnsGroups.length + 1}`;
                const startingBound = DateTime.max(groupsLeftBound, groupStart);
                const endingBound = DateTime.min(groupsRightBound, localEndOf(groupStart, unit));
                const [groupFirstCol, groupLastCol] = this.getGridColumnFromDates(
                    startingBound,
                    endingBound
                );
                currentGroup = {
                    id: groupId,
                    grid: { column: [groupFirstCol, groupLastCol] },
                    start: groupStart,
                };
                this.columnsGroups.push(currentGroup);
                this.coarseGridCols[groupFirstCol] = true;
                this.coarseGridCols[groupLastCol] = true;
            }
        }
    }

    computeVisibleRows() {
        this.coarseGridRows = {
            1: true,
            [this.getLastGridRow(this.rows[this.rows.length - 1])]: true,
        };
        const [rowStart, rowEnd] = this.virtualGrid.rowsIndexes;
        this.rowsToRender = new Set();
        for (const row of this.rows) {
            const [first, last] = row.grid.row;
            if (last <= rowStart + 1 || first > rowEnd + 1) {
                continue;
            }
            this.addToRowsToRender(row);
        }
    }

    getFirstGridCol({ grid }) {
        const [first] = grid.column;
        return first;
    }

    getLastGridCol({ grid }) {
        const [, last] = grid.column;
        return last;
    }

    getFirstGridRow({ grid }) {
        const [first] = grid.row;
        return first;
    }

    getLastGridRow({ grid }) {
        const [, last] = grid.row;
        return last;
    }

    addToPillsToRender(pill) {
        this.pillsToRender.add(pill);
        this.addCoordinatesToCoarseGrid(pill);
    }

    addToRowsToRender(row) {
        this.rowsToRender.add(row);
        const [first, last] = row.grid.row;
        for (let i = first; i <= last; i++) {
            this.coarseGridRows[i] = true;
        }
    }

    /**
     * give bounds only
     */
    getVisibleCols() {
        const [columnStart, columnEnd] = this.virtualGrid.columnsIndexes;
        const { cellPart } = this.model.metaData.scale;
        const firstVisibleCol = 1 + cellPart * columnStart;
        const lastVisibleCol = 1 + cellPart * (columnEnd + 1);
        return [firstVisibleCol, lastVisibleCol];
    }

    /**
     * give bounds only
     */
    getVisibleRows() {
        const [rowStart, rowEnd] = this.virtualGrid.rowsIndexes;
        const firstVisibleRow = rowStart + 1;
        const lastVisibleRow = rowEnd + 1;
        return [firstVisibleRow, lastVisibleRow];
    }

    computeVisiblePills() {
        this.pillsToRender = new Set();

        const [firstVisibleCol, lastVisibleCol] = this.getVisibleCols();
        const [firstVisibleRow, lastVisibleRow] = this.getVisibleRows();

        const isOut = (pill, filterOnRow = true) =>
            this.getFirstGridCol(pill) > lastVisibleCol ||
            this.getLastGridCol(pill) < firstVisibleCol ||
            (filterOnRow &&
                (this.getFirstGridRow(pill) > lastVisibleRow ||
                    this.getLastGridRow(pill) - 1 < firstVisibleRow));

        const getRowPills = (row, filterOnRow) =>
            (this.rowPills[row.id] || []).filter((pill) => !isOut(pill, filterOnRow));

        for (const row of this.rowsToRender) {
            for (const rowPill of getRowPills(row)) {
                this.addToPillsToRender(rowPill);
            }
            if (!row.isGroup && row.unavailabilities?.length) {
                row.cellColors = this.getRowCellColors(row);
            }
        }

        if (this.stickyPillId) {
            this.addToPillsToRender(this.pills[this.stickyPillId]);
        }

        if (this.totalRow) {
            this.totalRow.pills = getRowPills(this.totalRow, false);
            for (const pill of this.totalRow.pills) {
                this.addCoordinatesToCoarseGrid({ grid: omit(pill.grid, "row") });
            }
        }
    }

    computeVisibleConnectors() {
        const visibleConnectorIds = new Set([NEW_CONNECTOR_ID]);

        for (const pill of this.pillsToRender) {
            const row = this.getRowFromPill(pill);
            if (row.isGroup) {
                continue;
            }
            for (const connectorId of this.mappingPillToConnectors[pill.id] || []) {
                visibleConnectorIds.add(connectorId);
            }
        }

        this.connectorsToRender = [];
        for (const connectorId in this.connectors) {
            if (!visibleConnectorIds.has(connectorId)) {
                continue;
            }
            this.connectorsToRender.push(this.connectors[connectorId]);
            const { sourcePillId, targetPillId } = this.mappingConnectorToPills[connectorId];
            if (sourcePillId) {
                this.addToPillsToRender(this.pills[sourcePillId]);
            }
            if (targetPillId) {
                this.addToPillsToRender(this.pills[targetPillId]);
            }
        }
    }

    getRowFromPill(pill) {
        return this.rowByIds[pill.rowId];
    }

    getColInCoarseGridKeys() {
        return Object.keys({ ...this.coarseGridCols, ...this.stickyGridColumns });
    }

    getRowInCoarseGridKeys() {
        return Object.keys({ ...this.coarseGridRows, ...this.stickyGridRows });
    }

    computeColsTemplate() {
        const colsTemplate = [];
        const colInCoarseGridKeys = this.getColInCoarseGridKeys();
        for (let i = 0; i < colInCoarseGridKeys.length - 1; i++) {
            const x = +colInCoarseGridKeys[i];
            const y = +colInCoarseGridKeys[i + 1];
            const colName = `c${x}`;
            const width = (y - x) * this.cellPartWidth;
            colsTemplate.push(`[${colName}]minmax(${width}px,1fr)`);
        }
        colsTemplate.push(`[c${colInCoarseGridKeys.at(-1)}]`);
        return colsTemplate.join("");
    }

    computeRowsTemplate() {
        const rowsTemplate = [];
        const rowInCoarseGridKeys = this.getRowInCoarseGridKeys();
        for (let i = 0; i < rowInCoarseGridKeys.length - 1; i++) {
            const x = +rowInCoarseGridKeys[i];
            const y = +rowInCoarseGridKeys[i + 1];
            const rowName = `r${x}`;
            const height = this.gridRows.slice(x - 1, y - 1).reduce((a, b) => a + b, 0);
            rowsTemplate.push(`[${rowName}]${height}px`);
        }
        rowsTemplate.push(`[r${rowInCoarseGridKeys.at(-1)}]`);
        return rowsTemplate.join("");
    }

    computeSomeWidths() {
        const { cellPart, minimalColumnWidth } = this.model.metaData.scale;
        this.contentRefWidth = this.props.contentRef.el?.clientWidth ?? document.body.clientWidth;
        const rowHeaderWidthPercentage = this.hasRowHeaders
            ? this.constructor.getRowHeaderWidth(this.contentRefWidth)
            : 0;
        this.rowHeaderWidth = this.hasRowHeaders
            ? Math.round((rowHeaderWidthPercentage * this.contentRefWidth) / 100)
            : 0;
        const cellContainerWidth = this.contentRefWidth - this.rowHeaderWidth;
        const columnWidth = Math.floor(cellContainerWidth / this.columnCount);
        const rectifiedColumnWidth = Math.max(columnWidth, minimalColumnWidth);
        this.cellPartWidth = Math.floor(rectifiedColumnWidth / cellPart);
        this.columnWidth = this.cellPartWidth * cellPart;
        if (columnWidth <= minimalColumnWidth) {
            // overflow
            this.totalWidth = this.rowHeaderWidth + this.columnWidth * this.columnCount;
        } else {
            this.totalWidth = null;
        }
    }

    computeDerivedParams() {
        const { rows: modelRows } = this.model.data;

        if (this.shouldRenderConnectors()) {
            /** @type {Record<number, { masterIds: number[], pills: Record<RowId, Pill> }>} */
            this.mappingRecordToPillsByRow = {};
            /** @type {Record<RowId, Record<number, Pill>>} */
            this.mappingRowToPillsByRecord = {};
            /** @type {Record<ConnectorId, { sourcePillId: PillId, targetPillId: PillId }>} */
            this.mappingConnectorToPills = {};
            /** @type {Record<PillId, ConnectorId>} */
            this.mappingPillToConnectors = {};
        }

        const { globalStart, globalStop, scale, startDate, stopDate } = this.model.metaData;
        this.columnCount = diffColumn(globalStart, globalStop, scale.interval);
        if (
            !this.currentStartDate ||
            diffColumn(this.currentStartDate, startDate, "day") ||
            diffColumn(this.currentStopDate, stopDate, "day") ||
            this.currentScaleId !== scale.id
        ) {
            this.useFocusDate = true;
            this.mappingColToColumn = new Map();
            this.mappingColToSubColumn = new Map();
        }
        this.currentStartDate = startDate;
        this.currentStopDate = stopDate;
        this.currentScaleId = scale.id;

        this.currentGridRow = 1;
        this.gridRows = [];
        this.nextPillId = 1;

        this.pills = {}; // mapping to retrieve pills from pill ids
        this.rows = [];
        this.rowPills = {};
        this.rowByIds = {};

        const prePills = this.getPills();

        let pillsToProcess = [...prePills];
        for (const row of modelRows) {
            const result = this.processRow(row, pillsToProcess);
            this.rows.push(...result.rows);
            pillsToProcess = result.pillsToProcess;
        }

        const { displayTotalRow } = this.model.metaData;
        if (displayTotalRow) {
            this.totalRow = this.getTotalRow(prePills);
        }

        if (this.shouldRenderConnectors()) {
            this.initializeConnectors();
            this.generateConnectors();
        }

        this.shouldComputeSomeWidths = true;
        this.shouldComputeGridColumns = true;
        this.shouldComputeGridRows = true;
    }

    computeDerivedParamsFromHover() {
        const { scale } = this.model.metaData;

        const { connector, hoverable, pill } = this.hovered;

        // Update cell in drag
        const isCellHovered = hoverable?.matches(".o_gantt_cell");
        this.cellForDrag.el = isCellHovered ? hoverable : null;
        this.cellForDrag.part = 0;
        if (isCellHovered && scale.cellPart > 1) {
            const rect = hoverable.getBoundingClientRect();
            const x = Math.floor(rect.x);
            const width = Math.floor(rect.width);
            this.cellForDrag.part = Math.floor(
                (this.cursorPosition.x - x) / (width / scale.cellPart)
            );
            if (localization.direction === "rtl") {
                this.cellForDrag.part = scale.cellPart - 1 - this.cellForDrag.part;
            }
        }

        if (this.isDragging) {
            this.progressBarsReactive.hoveredRowId = null;
            return;
        }

        if (!this.connectorDragState.dragging) {
            // Highlight connector
            const hoveredConnectorId = connector?.dataset.connectorId;
            for (const connectorId in this.connectors) {
                if (connectorId !== hoveredConnectorId) {
                    this.toggleConnectorHighlighting(connectorId, false);
                }
            }
            if (hoveredConnectorId) {
                this.progressBarsReactive.hoveredRowId = null;
                return this.toggleConnectorHighlighting(hoveredConnectorId, true);
            }
        }

        // Highlight pill
        const hoveredPillId = pill?.dataset.pillId;
        for (const pillId in this.pills) {
            if (pillId !== hoveredPillId) {
                this.togglePillHighlighting(pillId, false);
            }
        }
        this.togglePillHighlighting(hoveredPillId, true);

        // Update progress bars
        this.progressBarsReactive.hoveredRowId = hoverable ? hoverable.dataset.rowId : null;
    }

    /**
     * @param {ConnectorId} connectorId
     */
    deleteConnector(connectorId) {
        delete this.connectors[connectorId];
        delete this.mappingConnectorToPills[connectorId];
    }

    /**
     * @param {Object} params
     * @param {Element} params.pill
     * @param {Element} params.cell
     * @param {number} params.diff
     */
    async dragPillDrop({ pill, cell, diff }) {
        const { rowId } = cell.dataset;
        const { dateStartField, dateStopField, scale } = this.model.metaData;
        const { cellTime, time } = scale;
        const { record } = this.pills[pill.dataset.pillId];
        const params = this.getScheduleParams(pill);

        params.start =
            diff && dateAddFixedOffset(record[dateStartField], { [time]: cellTime * diff });
        params.stop =
            diff && dateAddFixedOffset(record[dateStopField], { [time]: cellTime * diff });
        params.rowId = rowId;

        const schedule = this.model.getSchedule(params);

        if (this.interaction.dragAction === "copy") {
            await this.model.copy(record.id, schedule, this.openPlanDialogCallback);
        } else {
            await this.model.reschedule(record.id, schedule, this.openPlanDialogCallback);
        }

        // If the pill lands on a closed group -> open it
        if (cell.classList.contains("o_gantt_group") && this.model.isClosed(rowId)) {
            this.model.toggleRow(rowId);
        }
    }

    /**
     * @param {Partial<Pill>} pill
     * @returns {Pill}
     */
    enrichPill(pill) {
        const { colorField, fields, pillDecorations, progressField } = this.model.metaData;

        pill.displayName = this.getDisplayName(pill);

        const classes = [];

        if (pillDecorations) {
            const pillContext = Object.assign({}, user.context);
            for (const [fieldName, value] of Object.entries(pill.record)) {
                const field = fields[fieldName];
                switch (field.type) {
                    case "date": {
                        pillContext[fieldName] = value ? serializeDate(value) : false;
                        break;
                    }
                    case "datetime": {
                        pillContext[fieldName] = value ? serializeDateTime(value) : false;
                        break;
                    }
                    default: {
                        pillContext[fieldName] = value;
                    }
                }
            }

            for (const decoration in pillDecorations) {
                const expr = pillDecorations[decoration];
                if (evaluateBooleanExpr(expr, pillContext)) {
                    classes.push(decoration);
                }
            }
        }

        if (colorField) {
            pill._color = getColorIndex(pill.record[colorField]);
            classes.push(`o_gantt_color_${pill._color}`);
        }

        if (progressField) {
            pill._progress = pill.record[progressField] || 0;
        }

        pill.className = classes.join(" ");

        return pill;
    }

    focusDate(date, ifInBounds) {
        const { globalStart, globalStop } = this.model.metaData;
        const diff = date.diff(globalStart);
        const totalDiff = globalStop.diff(globalStart);
        const factor = diff / totalDiff;
        if (ifInBounds && (factor < 0 || 1 < factor)) {
            return false;
        }
        const rtlFactor = localization.direction === "rtl" ? -1 : 1;
        const scrollLeft =
            factor * this.cellContainerRef.el.clientWidth +
            this.rowHeaderWidth -
            (this.contentRefWidth + this.rowHeaderWidth) / 2;
        this.props.contentRef.el.scrollLeft = rtlFactor * scrollLeft;
        return true;
    }

    focusFirstPill(rowId) {
        const pill = this.rowPills[rowId][0];
        if (pill) {
            const col = this.getFirstGridCol(pill);
            const { start: date } = this.getColumnFromColNumber(col);
            this.focusDate(date);
        }
    }

    focusToday() {
        return this.focusDate(DateTime.local().startOf("day"), true);
    }

    generateConnectors() {
        this.nextConnectorId = 1;
        this.setConnector({
            id: NEW_CONNECTOR_ID,
            highlighted: true,
            sourcePoint: null,
            targetPoint: null,
        });
        for (const slaveId in this.mappingRecordToPillsByRow) {
            const { masterIds, pills: slavePills } = this.mappingRecordToPillsByRow[slaveId];
            for (const masterId of masterIds) {
                if (!(masterId in this.mappingRecordToPillsByRow)) {
                    continue;
                }
                const { pills: masterPills } = this.mappingRecordToPillsByRow[masterId];
                for (const [slaveRowId, targetPill] of Object.entries(slavePills)) {
                    for (const [masterRowId, sourcePill] of Object.entries(masterPills)) {
                        if (
                            masterRowId === slaveRowId ||
                            !(
                                slaveId in this.mappingRowToPillsByRecord[masterRowId] ||
                                masterId in this.mappingRowToPillsByRecord[slaveRowId]
                            ) ||
                            Object.keys(this.mappingRecordToPillsByRow[slaveId].pills).every(
                                (rowId) =>
                                    rowId !== masterRowId &&
                                    masterId in this.mappingRowToPillsByRecord[rowId]
                            ) ||
                            Object.keys(this.mappingRecordToPillsByRow[masterId].pills).every(
                                (rowId) =>
                                    rowId !== slaveRowId &&
                                    slaveId in this.mappingRowToPillsByRecord[rowId]
                            )
                        ) {
                            const masterRecord = sourcePill.record;
                            const slaveRecord = targetPill.record;
                            this.setConnector(
                                { alert: this.getConnectorAlert(masterRecord, slaveRecord) },
                                sourcePill.id,
                                targetPill.id
                            );
                        }
                    }
                }
            }
        }
    }

    /**
     * @param {Group} group
     * @param {Group} previousGroup
     */
    getAggregateValue(group, previousGroup) {
        // both groups have the same pills by construction
        // here the aggregateValue is the pill count
        return group.aggregateValue;
    }

    /**
     * @param {number} startCol
     * @param {number} stopCol
     * @param {boolean} [roundUpStop=true]
     */
    getColumnStartStop(startCol, stopCol, roundUpStop = true) {
        const { start } = this.getColumnFromColNumber(startCol);
        let { stop } = this.getColumnFromColNumber(stopCol);
        if (roundUpStop) {
            stop = stop.plus({ millisecond: 1 });
        }
        return { start, stop };
    }

    /**
     *
     * @param {number} masterRecord
     * @param {number} slaveRecord
     * @returns {import("./gantt_connector").ConnectorAlert | null}
     */
    getConnectorAlert(masterRecord, slaveRecord) {
        const { dateStartField, dateStopField } = this.model.metaData;
        if (slaveRecord[dateStartField] < masterRecord[dateStopField]) {
            if (slaveRecord[dateStartField] < masterRecord[dateStartField]) {
                return "error";
            } else {
                return "warning";
            }
        }
        return null;
    }

    /**
     * @param {Row} row
     * @param {Column} column
     * @return {Object}
     */
    ganttCellAttClass(row, column) {
        return {
            o_sample_data_disabled: this.isDisabled(row),
            o_gantt_today: column.isToday,
            o_gantt_group: row.isGroup,
            o_gantt_hoverable: this.isHoverable(row),
            o_group_open: !this.model.isClosed(row.id),
        };
    }

    getCurrentFocusDate() {
        const { globalStart, globalStop } = this.model.metaData;
        const rtlFactor = localization.direction === "rtl" ? -1 : 1;
        const cellGridMiddleX =
            rtlFactor * this.props.contentRef.el.scrollLeft +
            (this.contentRefWidth + this.rowHeaderWidth) / 2;
        const factor =
            (cellGridMiddleX - this.rowHeaderWidth) / this.cellContainerRef.el.clientWidth;
        const totalDiff = globalStop.diff(globalStart);
        const diff = factor * totalDiff;
        const focusDate = globalStart.plus(diff);
        return focusDate;
    }

    /**
     * @param {"top"|"bottom"} vertical the vertical alignment of the connector creator
     * @returns {{ vertical: "top"|"bottom", horizontal: "left"|"right" }}
     */
    getConnectorCreatorAlignment(vertical) {
        const alignment = { vertical };
        if (localization.direction === "rtl") {
            alignment.horizontal = vertical === "top" ? "right" : "left";
        } else {
            alignment.horizontal = vertical === "top" ? "left" : "right";
        }
        return alignment;
    }

    /**
     * Get schedule parameters
     *
     * @param {Element} pill
     * @returns {Object} - An object containing parameters needed for scheduling the pill.
     */
    getScheduleParams(pill) {
        return {};
    }

    /**
     * This function will add a 'label' property to each
     * non-consolidated pill included in the pills list.
     * This new property is a string meant to replace
     * the text displayed on a pill.
     *
     * @param {Pill} pill
     */
    getDisplayName(pill) {
        const { computePillDisplayName, dateStartField, dateStopField, scale } =
            this.model.metaData;
        const { id: scaleId } = scale;
        const { record } = pill;

        if (!computePillDisplayName) {
            return record.display_name;
        }

        const startDate = record[dateStartField];
        const stopDate = record[dateStopField];
        const yearlessDateFormat = omit(DateTime.DATE_SHORT, "year");

        const spanMoreThanOneDay = startDate.startOf("day").diff(stopDate.startOf("day"), "days").days < -1;
        const spanAccrossDays =
            spanMoreThanOneDay ||
            (stopDate.startOf("day") > startDate.startOf("day") &&
            startDate.endOf("day").diff(startDate, "hours").toObject().hours >= 3 &&
            stopDate.diff(stopDate.startOf("day"), "hours").toObject().hours >= 3);
        const spanAccrossWeeks = getStartOfLocalWeek(stopDate) > getStartOfLocalWeek(startDate);
        const spanAccrossMonths = stopDate.startOf("month") > startDate.startOf("month");

        /** @type {string[]} */
        const labelElements = [];

        // Start & End Dates
        if (scaleId === "year" && !spanAccrossDays) {
            labelElements.push(startDate.toLocaleString(yearlessDateFormat));
        } else if (
            (scaleId === "day" && spanAccrossDays) ||
            (scaleId === "week" && spanAccrossWeeks) ||
            (scaleId === "month" && spanAccrossMonths) ||
            (scaleId === "year" && spanAccrossDays)
        ) {
            labelElements.push(startDate.toLocaleString(yearlessDateFormat));
            labelElements.push(stopDate.toLocaleString(yearlessDateFormat));
        }

        // Start & End Times
        if (record.allocated_hours && !spanAccrossDays && ["week", "month"].includes(scaleId)) {
            const durationStr = this.getDurationStr(record);
            labelElements.push(startDate.toFormat("t"), `${stopDate.toFormat("t")}${durationStr}`);
        }

        // Original Display Name
        if (scaleId !== "month" || !record.allocated_hours || spanAccrossDays) {
            labelElements.push(record.display_name);
        }

        return labelElements.filter((el) => !!el).join(" - ");
    }

    /**
     * @param {RelationalRecord} record
     */
    getDurationStr(record) {
        const durationStr = formatFloatTime(record.allocated_hours, {
            noLeadingZeroHour: true,
        }).replace(/(:00|:)/g, "h");
        return ` (${durationStr})`;
    }

    /**
     * @param {Pill} pill
     */
    getGroupPillDisplayName(pill) {
        return pill.aggregateValue;
    }

    /**
     * @param {{ column?: [number, number], row?: [number, number] }} position
     */
    getGridPosition(position) {
        const style = [];
        const keys = Object.keys(pick(position, "column", "row"));
        for (const key of keys) {
            const prefix = key.slice(0, 1);
            const [first, last] = position[key];
            style.push(`grid-${key}:${prefix}${first}/${prefix}${last}`);
        }
        return style.join(";");
    }

    setSomeGridStyleProperties() {
        const rowsTemplate = this.computeRowsTemplate();
        const colsTemplate = this.computeColsTemplate();
        this.gridRef.el.style.setProperty("--Gantt__GridRows-grid-template-rows", rowsTemplate);
        this.gridRef.el.style.setProperty(
            "--Gantt__GridColumns-grid-template-columns",
            colsTemplate
        );
    }

    getGridStyle() {
        const rowsTemplate = this.computeRowsTemplate();
        const colsTemplate = this.computeColsTemplate();
        const style = {
            "--Gantt__RowHeader-width": `${this.rowHeaderWidth}px`,
            "--Gantt__Pill-height": "35px",
            "--Gantt__Thumbnail-max-height": "16px",
            "--Gantt__GridRows-grid-template-rows": rowsTemplate,
            "--Gantt__GridColumns-grid-template-columns": colsTemplate,
        };
        if (this.totalWidth !== null) {
            style.width = `${this.totalWidth}px`;
        }
        return Object.entries(style)
            .map((entry) => entry.join(":"))
            .join(";");
    }

    /**
     * @param {RelationalRecord} record
     * @returns {Partial<Pill>}
     */
    getPill(record) {
        const { canEdit, dateStartField, dateStopField, disableDrag, globalStart, globalStop } =
            this.model.metaData;

        const startOutside = record[dateStartField] < globalStart;

        let recordDateStopField = record[dateStopField];
        if (this.model.dateStopFieldIsDate()) {
            recordDateStopField = recordDateStopField.plus({ day: 1 });
        }

        const stopOutside = recordDateStopField > globalStop;

        /** @type {DateTime} */
        const pillStartDate = startOutside ? globalStart : record[dateStartField];
        /** @type {DateTime} */
        const pillStopDate = stopOutside ? globalStop : recordDateStopField;

        const disableStartResize = !canEdit || startOutside;
        const disableStopResize = !canEdit || stopOutside;

        /** @type {Partial<Pill>} */
        const pill = {
            disableDrag: disableDrag || disableStartResize || disableStopResize,
            disableStartResize,
            disableStopResize,
            grid: { column: this.getGridColumnFromDates(pillStartDate, pillStopDate) },
            record,
        };

        return pill;
    }

    getGridColumnFromDates(startDate, stopDate) {
        const { globalStart, scale } = this.model.metaData;
        const { cellPart, interval } = scale;
        const { column: column1, delta: delta1 } = this.getSubColumnFromDate(startDate);
        const { column: column2, delta: delta2 } = this.getSubColumnFromDate(stopDate, false);
        const firstCol = 1 + diffColumn(globalStart, column1, interval) * cellPart + delta1;
        const span = diffColumn(column1, column2, interval) * cellPart + delta2 - delta1;
        return [firstCol, firstCol + span];
    }

    getSubColumnFromDate(date, onLeft = true) {
        const { interval, cellPart, cellTime, time } = this.model.metaData.scale;
        const column = date.startOf(interval);
        let delta;
        if (onLeft) {
            delta = 0;
            for (let i = 1; i < cellPart; i++) {
                const subCellStart = dateAddFixedOffset(column, { [time]: i * cellTime });
                if (subCellStart <= date) {
                    delta += 1;
                } else {
                    break;
                }
            }
        } else {
            delta = cellPart;
            for (let i = cellPart - 1; i >= 0; i--) {
                const subCellStart = dateAddFixedOffset(column, { [time]: i * cellTime });
                if (subCellStart >= date) {
                    delta -= 1;
                } else {
                    break;
                }
            }
        }
        return { column, delta };
    }

    getSubColumnFromColNumber(col) {
        let subColumn = this.mappingColToSubColumn.get(col);
        if (!subColumn) {
            const { globalStart, scale } = this.model.metaData;
            const { interval, cellPart, cellTime, time } = scale;
            const delta = (col - 1) % cellPart;
            const columnIndex = (col - 1 - delta) / cellPart;
            const start = globalStart.plus({ [interval]: columnIndex });
            subColumn = this.makeSubColumn(start, delta, cellTime, time);
            this.mappingColToSubColumn.set(col, subColumn);
        }
        return subColumn;
    }

    getColumnFromColNumber(col) {
        let column = this.mappingColToColumn.get(col);
        if (!column) {
            const { globalStart, scale } = this.model.metaData;
            const { interval, cellPart } = scale;
            const delta = (col - 1) % cellPart;
            const columnIndex = (col - 1 - delta) / cellPart;
            const start = globalStart.plus({ [interval]: columnIndex });
            const stop = start.endOf(interval);
            column = { start, stop };
            this.mappingColToColumn.set(col, column);
        }
        return column;
    }

    /**
     * @param {PillId} pillId
     */
    getPillEl(pillId) {
        return this.getPillWrapperEl(pillId).querySelector(".o_gantt_pill");
    }

    /**
     * @param {Object} group
     * @param {number} maxAggregateValue
     * @param {boolean} consolidate
     */
    getPillFromGroup(group, maxAggregateValue, consolidate) {
        const { excludeField, field, maxValue } = this.model.metaData.consolidationParams;

        const minColor = 215;
        const maxColor = 100;

        const newPill = {
            id: `__pill__${this.nextPillId++}`,
            level: 0,
            aggregateValue: group.aggregateValue,
            grid: group.grid,
        };

        // Enrich the aggregates with consolidation data
        if (consolidate && field) {
            newPill.consolidationValue = 0;
            for (const pill of group.pills) {
                if (!pill.record[excludeField]) {
                    newPill.consolidationValue += pill.record[field];
                }
            }
            newPill.consolidationMaxValue = maxValue;
            newPill.consolidationExceeded =
                newPill.consolidationValue > newPill.consolidationMaxValue;
        }

        if (consolidate && maxValue) {
            const status = newPill.consolidationExceeded ? "danger" : "success";
            newPill.className = `bg-${status} border-${status}`;
            newPill.displayName = newPill.consolidationValue;
        } else {
            const color =
                minColor -
                Math.round((newPill.aggregateValue - 1) / maxAggregateValue) *
                    (minColor - maxColor);
            newPill.style = `background-color:rgba(${color},${color},${color},0.6)`;
            newPill.displayName = this.getGroupPillDisplayName(newPill);
        }

        return newPill;
    }

    /**
     * There are two forms of pills: pills comming from fetched records
     * and pills that are some kind of aggregation of the previous.
     *
     * Here we create the pills of the firs type.
     *
     * The basic properties (independent of rows,...) of the pills of
     * the first type should be computed here.
     *
     * @returns {Partial<Pill>[]}
     */
    getPills() {
        const { records } = this.model.data;
        const { dateStartField } = this.model.metaData;
        const pills = [];
        for (const record of records) {
            const pill = this.getPill(record);
            pills.push(this.enrichPill(pill));
        }
        return pills.sort(
            (p1, p2) =>
                p1.grid.column[0] - p2.grid.column[0] ||
                p1.record[dateStartField] - p2.record[dateStartField]
        );
    }

    /**
     * @param {PillId} pillId
     */
    getPillWrapperEl(pillId) {
        const pillSelector = `:scope > [data-pill-id="${pillId}"]`;
        return this.cellContainerRef.el?.querySelector(pillSelector);
    }

    /**
     * Get domain of records for plan dialog in the gantt view.
     *
     * @param {Object} state
     * @returns {any[][]}
     */
    getPlanDialogDomain() {
        const { dateStartField, dateStopField } = this.model.metaData;
        const newDomain = Domain.removeDomainLeaves(this.env.searchModel.globalDomain, [
            dateStartField,
            dateStopField,
        ]);
        return Domain.and([
            newDomain,
            ["|", [dateStartField, "=", false], [dateStopField, "=", false]],
        ]).toList({});
    }

    /**
     * @param {PillId} pillId
     * @param {boolean} onRight
     */
    getPoint(pillId, onRight) {
        if (localization.direction === "rtl") {
            onRight = !onRight;
        }
        const pillEl = this.getPillEl(pillId);
        const pillRect = pillEl.getBoundingClientRect();
        return {
            left: pillRect.left + (onRight ? pillRect.width : 0),
            top: pillRect.top + pillRect.height / 2,
        };
    }

    /**
     * @param {Pill} pill
     */
    getPopoverProps(pill) {
        const { record } = pill;
        const { id: resId, display_name: displayName } = record;
        const { canEdit, dateStartField, dateStopField, popoverArchParams, resModel } =
            this.model.metaData;
        const context = popoverArchParams.bodyTemplate
            ? { ...record }
            : /* Default context */ {
                  name: displayName,
                  start: record[dateStartField].toFormat("f"),
                  stop: record[dateStopField].toFormat("f"),
              };

        return {
            ...popoverArchParams,
            title: displayName,
            context,
            resId,
            resModel,
            reload: () => this.model.fetchData(),
            buttons: [
                {
                    id: "open_view_edit_dialog",
                    text: canEdit ? _t("Edit") : _t("View"),
                    class: "btn btn-sm btn-primary",
                    // Sync with the mutex to wait for potential changes on the view
                    onClick: () =>
                        this.model.mutex.exec(
                            () => this.props.openDialog({ resId }) // (canEdit is also considered in openDialog)
                        ),
                },
            ],
        };
    }

    /**
     * @param {Row} row
     */
    getProgressBarProps(row) {
        return {
            progressBar: row.progressBar,
            reactive: this.progressBarsReactive,
            rowId: row.id,
        };
    }

    /**
     * @param {Row} row
     */
    getRowCellColors(row) {
        const { unavailabilities } = row;
        const { cellPart } = this.model.metaData.scale;
        // We assume that the unavailabilities have been normalized
        // (i.e. are naturally ordered and are pairwise disjoint).
        // A subCell is considered unavailable (and greyed) when totally covered by
        // an unavailability.
        let index = 0;
        let j = 0;
        /** @type {Record<string, string>} */
        const cellColors = {};
        const subSlotUnavailabilities = [];
        for (const subColumn of this.subColumns) {
            const { isToday, start, stop, columnId } = subColumn;
            if (index < unavailabilities.length) {
                let subSlotUnavailable = 0;
                for (let i = index; i < unavailabilities.length; i++) {
                    const u = unavailabilities[i];
                    if (stop > u.stop) {
                        index++;
                        continue;
                    } else if (u.start <= start) {
                        subSlotUnavailable = 1;
                    }
                    break;
                }
                subSlotUnavailabilities.push(subSlotUnavailable);
                if ((j + 1) % cellPart === 0) {
                    const style = getCellColor(cellPart, subSlotUnavailabilities, isToday);
                    subSlotUnavailabilities.splice(0, cellPart);
                    if (style) {
                        cellColors[columnId] = style;
                    }
                }
                j++;
            }
        }
        return cellColors;
    }

    getFromData(groupedByField, resId, key, defaultVal) {
        const values = this.model.data[key];
        if (groupedByField) {
            return values[groupedByField]?.[resId ?? false] || defaultVal;
        }
        return values.__default?.false || defaultVal;
    }

    /**
     * @param {string} [groupedByField]
     * @param {false|number} [resId]
     * @returns {Object}
     */
    getRowProgressBar(groupedByField, resId) {
        return this.getFromData(groupedByField, resId, "progressBars", null);
    }

    /**
     * @param {string} [groupedByField]
     * @param {false|number} [resId]
     * @returns {{ start: DateTime, stop: DateTime }[]}
     */
    getRowUnavailabilities(groupedByField, resId) {
        return this.getFromData(groupedByField, resId, "unavailabilities", []);
    }

    /**
     * @param {"t0" | "t1" | "t2"} type
     * @returns {number}
     */
    getRowTypeHeight(type) {
        return {
            t0: 24,
            t1: 36,
            t2: 16,
        }[type];
    }

    getRowTitleStyle(row) {
        return `grid-column: ${row.groupLevel + 2} / -1`;
    }

    openPlanDialogCallback() {}

    getSelectCreateDialogProps(params) {
        const domain = this.getPlanDialogDomain();
        const schedule = this.model.getDialogContext(params);
        return {
            title: _t("Plan"),
            resModel: this.model.metaData.resModel,
            context: schedule,
            domain,
            noCreate: !this.model.metaData.canCellCreate,
            onSelected: (resIds) => {
                if (resIds.length) {
                    this.model.reschedule(resIds, schedule, this.openPlanDialogCallback.bind(this));
                }
            },
        };
    }

    /**
     * @param {Pill[]} pills
     */
    getTotalRow(pills) {
        const preRow = {
            groupLevel: 0,
            id: "[]",
            rows: [],
            name: _t("Total"),
            recordIds: pills.map(({ record }) => record.id),
        };

        this.currentGridRow = 1;
        const result = this.processRow(preRow, pills);
        const [totalRow] = result.rows;
        const allPills = this.rowPills[totalRow.id] || [];
        const maxAggregateValue = Math.max(...allPills.map((p) => p.aggregateValue));

        totalRow.factor = maxAggregateValue ? 90 / maxAggregateValue : 0;

        return totalRow;
    }

    highlightPill(pillId, highlighted) {
        const pill = this.pills[pillId];
        if (!pill) {
            return;
        }
        pill.highlighted = highlighted;
        const pillWrapper = this.getPillWrapperEl(pillId);
        pillWrapper?.classList.toggle("highlight", highlighted);
        pillWrapper?.classList.toggle(
            "o_connector_creator_highlight",
            highlighted && this.connectorDragState.dragging
        );
    }

    initializeConnectors() {
        for (const connectorId in this.connectors) {
            this.deleteConnector(connectorId);
        }
    }

    isPillSmall(pill) {
        return this.cellPartWidth * pill.grid.column[1] < pill.displayName.length * 10;
    }

    /**
     * @param {Row} row
     */
    isDisabled(row = null) {
        return this.model.useSampleModel;
    }

    /**
     * @param {Row} row
     */
    isHoverable(row) {
        return !this.model.useSampleModel;
    }

    /**
     * @param {Group[]} groups
     * @returns {Group[]}
     */
    mergeGroups(groups) {
        if (groups.length <= 1) {
            return groups;
        }
        const index = Math.floor(groups.length / 2);
        const left = this.mergeGroups(groups.slice(0, index));
        const right = this.mergeGroups(groups.slice(index));
        const group = right[0];
        if (!group.break) {
            const previousGroup = left.pop();
            group.break = previousGroup.break;
            group.grid.column[0] = previousGroup.grid.column[0];
            group.aggregateValue = this.getAggregateValue(group, previousGroup);
        }
        return [...left, ...right];
    }

    onWillRender() {
        if (this.noDisplayedConnectors && this.shouldRenderConnectors()) {
            delete this.noDisplayedConnectors;
            this.computeDerivedParams();
        }

        if (this.shouldComputeSomeWidths) {
            this.computeSomeWidths();
        }

        if (this.shouldComputeSomeWidths || this.shouldComputeGridColumns) {
            this.virtualGrid.setColumnsWidths(new Array(this.columnCount).fill(this.columnWidth));
            this.computeVisibleColumns();
        }

        if (this.shouldComputeGridRows) {
            this.virtualGrid.setRowsHeights(this.gridRows);
            this.computeVisibleRows();
        }

        if (
            this.shouldComputeSomeWidths ||
            this.shouldComputeGridColumns ||
            this.shouldComputeGridRows
        ) {
            delete this.shouldComputeSomeWidths;
            delete this.shouldComputeGridColumns;
            delete this.shouldComputeGridRows;
            this.computeVisiblePills();
            if (this.shouldRenderConnectors()) {
                this.computeVisibleConnectors();
            } else {
                this.noDisplayedConnectors = true;
            }
        }

        delete this.shouldComputeSomeWidths;
        delete this.shouldComputeGridColumns;
        delete this.shouldComputeGridRows;
    }

    pushGridRows(gridRows) {
        for (const key of ["t0", "t1", "t2"]) {
            if (key in gridRows) {
                const types = new Array(gridRows[key]).fill(this.getRowTypeHeight(key));
                this.gridRows.push(...types);
            }
        }
    }

    processPillsAsRows(row, pills) {
        const rows = [];
        const parsedId = JSON.parse(row.id);
        if (pills.length) {
            for (const pill of pills) {
                const { id: resId, display_name: name } = pill.record;
                const subRow = {
                    id: JSON.stringify([...parsedId, { id: resId }]),
                    resId,
                    name,
                    groupLevel: row.groupLevel + 1,
                    recordIds: [resId],
                    fromServer: row.fromServer,
                    parentResId: row.resId ?? row.parentResId,
                    parentGroupedField: row.groupedByField || row.parentGroupedField,
                };
                const res = this.processRow(subRow, [pill], false);
                rows.push(...res.rows);
            }
        } else {
            const subRow = {
                id: JSON.stringify([...parsedId, {}]),
                resId: false,
                name: "",
                groupLevel: row.groupLevel + 1,
                recordIds: [],
                fromServer: row.fromServer,
                parentResId: row.resId ?? row.parentResId,
                parentGroupedField: row.groupedByField || row.parentGroupedField,
            };
            const res = this.processRow(subRow, [], false);
            rows.push(...res.rows);
        }

        return rows;
    }

    /**
     * @param {Row} row
     * @param {Pill[]} pills
     * @param {boolean} [processAsGroup=false]
     */
    processRow(row, pills, processAsGroup = true) {
        const { dependencyField, displayUnavailability, fields } = this.model.metaData;
        const { displayMode } = this.model.displayParams;
        const {
            consolidate,
            fromServer,
            groupedByField,
            groupLevel,
            id,
            name,
            parentResId,
            parentGroupedField,
            resId,
            rows,
            recordIds,
            __extra__,
        } = row;

        // compute the subset pills at row level
        const remainingPills = [];
        let rowPills = [];
        const groupPills = [];
        const isMany2many = groupedByField && fields[groupedByField].type === "many2many";
        for (const pill of pills) {
            const { record } = pill;
            const pushPill = recordIds.includes(record.id);
            let keepPill = false;
            if (pushPill && isMany2many) {
                const value = record[groupedByField];
                if (Array.isArray(value) && value.length > 1) {
                    keepPill = true;
                }
            }
            if (pushPill) {
                const rowPill = { ...pill };
                rowPills.push(rowPill);
                groupPills.push(pill);
            }
            if (!pushPill || keepPill) {
                remainingPills.push(pill);
            }
        }

        if (displayMode === "sparse" && __extra__) {
            const rows = this.processPillsAsRows(row, groupPills);
            return { rows, pillsToProcess: remainingPills };
        }

        const isGroup = displayMode === "sparse" ? processAsGroup : Boolean(rows);

        const gridRowTypes = isGroup ? { t0: 1 } : { t1: 1 };
        if (rowPills.length) {
            if (isGroup) {
                if (this.shouldComputeAggregateValues(row)) {
                    const groups = this.aggregatePills(rowPills, row);
                    const maxAggregateValue = Math.max(
                        ...groups.map((group) => group.aggregateValue)
                    );
                    rowPills = groups.map((group) =>
                        this.getPillFromGroup(group, maxAggregateValue, consolidate)
                    );
                } else {
                    rowPills = [];
                }
            } else {
                const level = this.calculatePillsLevel(rowPills);
                gridRowTypes.t1 = level;
                if (!this.isTouchDevice) {
                    gridRowTypes.t2 = 1;
                }
            }
        }

        const progressBar = this.getRowProgressBar(groupedByField, resId);
        if (progressBar && this.isTouchDevice && (!gridRowTypes.t1 || gridRowTypes.t1 === 1)) {
            // In mobile: rows span over 2 rows to alllow progressbars to properly display
            gridRowTypes.t1 = (gridRowTypes.t1 || 0) + 1;
        }
        if (row.id !== "[]") {
            this.pushGridRows(gridRowTypes);
        }

        for (const rowPill of rowPills) {
            rowPill.id = `__pill__${this.nextPillId++}`;
            const pillFirstRow = this.currentGridRow + rowPill.level;
            rowPill.grid = {
                ...rowPill.grid, // rowPill is a shallow copy of a prePill (possibly copied several times)
                row: [pillFirstRow, pillFirstRow + 1],
            };
            if (!isGroup) {
                const { record } = rowPill;
                if (this.shouldRenderRecordConnectors(record)) {
                    if (!this.mappingRecordToPillsByRow[record.id]) {
                        this.mappingRecordToPillsByRow[record.id] = {
                            masterIds: record[dependencyField],
                            pills: {},
                        };
                    }
                    this.mappingRecordToPillsByRow[record.id].pills[id] = rowPill;
                    if (!this.mappingRowToPillsByRecord[id]) {
                        this.mappingRowToPillsByRecord[id] = {};
                    }
                    this.mappingRowToPillsByRecord[id][record.id] = rowPill;
                }
            }
            rowPill.rowId = id;
            this.pills[rowPill.id] = rowPill;
        }

        this.rowPills[id] = rowPills; // all row pills

        const subRowsCount = Object.values(gridRowTypes).reduce((acc, val) => acc + val, 0);
        /** @type {Row} */
        const processedRow = {
            cellColors: {},
            fromServer,
            groupedByField,
            groupLevel,
            id,
            isGroup,
            name,
            progressBar,
            resId,
            grid: {
                row: [this.currentGridRow, this.currentGridRow + subRowsCount],
            },
        };
        if (displayUnavailability && !isGroup) {
            processedRow.unavailabilities = this.getRowUnavailabilities(
                parentGroupedField || groupedByField,
                parentResId ?? resId
            );
        }

        this.rowByIds[id] = processedRow;

        this.currentGridRow += subRowsCount;

        const field = this.model.metaData.thumbnails[groupedByField];
        if (field) {
            const model = this.model.metaData.fields[groupedByField].relation;
            processedRow.thumbnailUrl = url("/web/image", {
                model,
                id: resId,
                field,
            });
        }

        const result = { rows: [processedRow], pillsToProcess: remainingPills };

        if (!this.model.isClosed(id)) {
            if (rows) {
                let pillsToProcess = groupPills;
                for (const subRow of rows) {
                    const res = this.processRow(subRow, pillsToProcess);
                    result.rows.push(...res.rows);
                    pillsToProcess = res.pillsToProcess;
                }
            } else if (displayMode === "sparse" && processAsGroup) {
                const rows = this.processPillsAsRows(row, groupPills);
                result.rows.push(...rows);
            }
        }

        return result;
    }

    /**
     * @param {string} [groupedByField]
     * @param {false|number} [resId]
     * @returns {{ start: DateTime, stop: DateTime }[]}
     */
    _getRowUnavailabilities(groupedByField, resId) {
        const { unavailabilities } = this.model.data;
        if (groupedByField) {
            return unavailabilities[groupedByField]?.[resId ?? false] || [];
        }
        return unavailabilities.__default?.false || [];
    }

    /**
     * @param {Object} params
     * @param {Element} params.pill
     * @param {number} params.diff
     * @param {"start" | "end"} params.direction
     */
    async resizePillDrop({ pill, diff, direction }) {
        const { dateStartField, dateStopField, scale } = this.model.metaData;
        const { cellTime, time } = scale;
        const { record } = this.pills[pill.dataset.pillId];
        const params = this.getScheduleParams(pill);

        if (direction === "start") {
            params.start = dateAddFixedOffset(record[dateStartField], { [time]: cellTime * diff });
            if (params.start > record[dateStopField]) {
                return this.notificationService.add(
                    _t("Starting date cannot be after the ending date"),
                    {
                        type: "warning",
                    }
                );
            }
        } else {
            params.stop = dateAddFixedOffset(record[dateStopField], { [time]: cellTime * diff });
            if (params.stop < record[dateStartField]) {
                return this.notificationService.add(
                    _t("Ending date cannot be before the starting date"),
                    {
                        type: "warning",
                    }
                );
            }
        }
        const schedule = this.model.getSchedule(params);

        await this.model.reschedule(record.id, schedule, this.openPlanDialogCallback);
    }

    /**
     * @param {Partial<ConnectorProps>} params
     * @param {PillId | null} [sourceId=null]
     * @param {PillId | null} [targetId=null]
     */
    setConnector(params, sourceId = null, targetId = null) {
        const connectorParams = { ...params };
        const connectorId = params.id || `__connector__${this.nextConnectorId++}`;

        if (sourceId) {
            connectorParams.sourcePoint = () => this.getPoint(sourceId, true);
        }

        if (targetId) {
            connectorParams.targetPoint = () => this.getPoint(targetId, false);
        }

        if (this.connectors[connectorId]) {
            Object.assign(this.connectors[connectorId], connectorParams);
        } else {
            this.connectors[connectorId] = {
                id: connectorId,
                highlighted: false,
                displayButtons: false,
                ...connectorParams,
            };
            this.mappingConnectorToPills[connectorId] = {
                sourcePillId: sourceId,
                targetPillId: targetId,
            };
        }

        if (sourceId) {
            if (!this.mappingPillToConnectors[sourceId]) {
                this.mappingPillToConnectors[sourceId] = [];
            }
            this.mappingPillToConnectors[sourceId].push(connectorId);
        }

        if (targetId) {
            if (!this.mappingPillToConnectors[targetId]) {
                this.mappingPillToConnectors[targetId] = [];
            }
            this.mappingPillToConnectors[targetId].push(connectorId);
        }
    }

    /**
     * @param {HTMLElement} [pillEl]
     */
    setStickyPill(pillEl) {
        this.stickyPillId = pillEl ? pillEl.dataset.pillId : null;
    }

    /**
     * @param {Row} row
     */
    shouldComputeAggregateValues(row) {
        return true;
    }

    shouldMergeGroups() {
        return true;
    }

    /**
     * Returns whether connectors should be rendered or not.
     * The connectors won't be rendered on sampleData as we can't be sure that data are coherent.
     * The connectors won't be rendered on mobile as the usability is not guarantied.
     *
     * @return {boolean}
     */
    shouldRenderConnectors() {
        return (
            this.model.metaData.dependencyField && !this.model.useSampleModel && !this.env.isSmall
        );
    }

    /**
     * Returns whether connectors should be rendered on particular records or not.
     * This method is intended to be overridden in particular modules in order to set particular record's condition.
     *
     * @param {RelationalRecord} record
     * @return {boolean}
     */
    shouldRenderRecordConnectors(record) {
        return this.shouldRenderConnectors();
    }

    /**
     * @param {ConnectorId | null} connectorId
     * @param {boolean} highlighted
     */
    toggleConnectorHighlighting(connectorId, highlighted) {
        const connector = this.connectors[connectorId];
        if (!connector || (!connector.highlighted && !highlighted)) {
            return;
        }

        connector.highlighted = highlighted;
        connector.displayButtons = highlighted;

        const { sourcePillId, targetPillId } = this.mappingConnectorToPills[connectorId];

        this.highlightPill(sourcePillId, highlighted);
        this.highlightPill(targetPillId, highlighted);
    }

    /**
     * @param {PillId} pillId
     * @param {boolean} highlighted
     */
    togglePillHighlighting(pillId, highlighted) {
        const pill = this.pills[pillId];
        if (!pill || pill.highlighted === highlighted) {
            return;
        }

        const { record } = pill;
        const pillIdsToHighlight = new Set([pillId]);

        if (record && this.shouldRenderRecordConnectors(record)) {
            // Find other related pills
            const { pills: relatedPills } = this.mappingRecordToPillsByRow[record.id];
            for (const pill of Object.values(relatedPills)) {
                pillIdsToHighlight.add(pill.id);
            }

            // Highlight related connectors
            for (const [connectorId, connector] of Object.entries(this.connectors)) {
                const ids = Object.values(this.getRecordIds(connectorId));
                if (ids.includes(record.id)) {
                    connector.highlighted = highlighted;
                    connector.displayButtons = false;
                }
            }
        }

        // Highlight pills from found IDs
        for (const id of pillIdsToHighlight) {
            this.highlightPill(id, highlighted);
        }
    }

    //-------------------------------------------------------------------------
    // Handlers
    //-------------------------------------------------------------------------

    onCellClicked(rowId, col) {
        if (!this.preventClick) {
            this.preventClick = true;
            setTimeout(() => (this.preventClick = false), 1000);
            const { canCellCreate, canPlan } = this.model.metaData;
            if (canPlan) {
                this.onPlan(rowId, col, col);
            } else if (canCellCreate) {
                this.onCreate(rowId, col, col);
            }
        }
    }

    onCreate(rowId, startCol, stopCol) {
        const { start, stop } = this.getColumnStartStop(startCol, stopCol);
        const context = this.model.getDialogContext({
            rowId,
            start,
            stop,
            withDefault: true,
        });
        this.props.create(context);
    }

    onInteractionChange() {
        let { dragAction, mode } = this.interaction;
        if (mode === "drag") {
            mode = dragAction;
        }
        if (this.gridRef.el) {
            for (const [action, className] of INTERACTION_CLASSNAMES) {
                this.gridRef.el.classList.toggle(className, mode === action);
            }
        }
    }

    onPointerLeave() {
        this.throttledComputeHoverParams.cancel();

        if (!this.isDragging) {
            const hoveredConnectorId = this.hovered.connector?.dataset.connectorId;
            this.toggleConnectorHighlighting(hoveredConnectorId, false);

            const hoveredPillId = this.hovered.pill?.dataset.pillId;
            this.togglePillHighlighting(hoveredPillId, false);
        }

        this.hovered.connector = null;
        this.hovered.pill = null;
        this.hovered.hoverable = null;

        this.computeDerivedParamsFromHover();
    }

    /**
     * Updates all hovered elements, then calls "computeDerivedParamsFromHover".
     *
     * @see computeDerivedParamsFromHover
     * @param {Event} ev
     */
    computeHoverParams(ev) {
        // Lazily compute elements from point as it is a costly operation
        let els = null;
        let position = {};
        if (ev.type === "scroll") {
            position = this.cursorPosition;
        } else {
            position.x = ev.clientX;
            position.y = ev.clientY;
            this.cursorPosition = position;
        }
        const pointedEls = () => els || (els = document.elementsFromPoint(position.x, position.y));

        // To find hovered elements, also from pointed elements
        const find = (selector) =>
            ev.target.closest?.(selector) ||
            pointedEls().find((el) => el.matches(selector)) ||
            null;

        this.hovered.connector = find(".o_gantt_connector");
        this.hovered.hoverable = find(".o_gantt_hoverable");
        this.hovered.pill = find(".o_gantt_pill_wrapper");

        this.computeDerivedParamsFromHover();
    }

    /**
     * @param {PointerEvent} ev
     * @param {Pill} pill
     */
    onPillClicked(ev, pill) {
        if (this.popover.isOpen) {
            return;
        }
        this.popover.target = ev.target.closest(".o_gantt_pill_wrapper");
        this.popover.open(this.popover.target, this.getPopoverProps(pill));
    }

    onPlan(rowId, startCol, stopCol) {
        const { start, stop } = this.getColumnStartStop(startCol, stopCol);
        this.dialogService.add(
            SelectCreateDialog,
            this.getSelectCreateDialogProps({ rowId, start, stop, withDefault: true })
        );
    }

    getRecordIds(connectorId) {
        const { sourcePillId, targetPillId } = this.mappingConnectorToPills[connectorId];
        return {
            masterId: this.pills[sourcePillId]?.record.id,
            slaveId: this.pills[targetPillId]?.record.id,
        };
    }

    /**
     *
     * @param {Object} params
     * @param {ConnectorId} connectorId
     */
    onRemoveButtonClick(connectorId) {
        const { masterId, slaveId } = this.getRecordIds(connectorId);
        this.model.removeDependency(masterId, slaveId);
    }
    rescheduleAccordingToDependencyCallback(result) {
        const isWarning = result.type === "warning";
        if (!isWarning && "old_vals_per_pill_id" in result) {
            this.model.toggleHighlightPlannedFilter(
                Object.keys(result["old_vals_per_pill_id"]).map(Number)
            );
        }
        this.notificationFn?.();
        const icon = isWarning ? "fa-warning" : "fa-check";
        this.notificationFn = this.notificationService.add(
            markup(
                `<i class="fa ${icon}"></i><span class="ms-1">${escape(result["message"])}</span>`
            ),
            {
                type: result["type"],
                sticky: true,
                buttons:
                    isWarning || !result.old_vals_per_pill_id
                        ? []
                        : [
                              {
                                  name: "Undo",
                                  icon: "fa-undo",
                                  onClick: async () => {
                                      const ids = Object.keys(result["old_vals_per_pill_id"]).map(
                                          Number
                                      );
                                      await this.orm.call(
                                          this.model.metaData.resModel,
                                          "action_rollback_scheduling",
                                          [ids, result["old_vals_per_pill_id"]]
                                      );
                                      this.notificationFn();
                                      await this.model.fetchData();
                                  },
                              },
                          ],
            }
        );
    }

    /**
     *
     * @param {"forward" | "backward"} direction
     * @param {ConnectorId} connectorId
     */
    async onRescheduleButtonClick(direction, connectorId) {
        const { masterId, slaveId } = this.getRecordIds(connectorId);
        await this.model.rescheduleAccordingToDependency(
            direction,
            masterId,
            slaveId,
            this.rescheduleAccordingToDependencyCallback.bind(this)
        );
    }

    /**
     * @param {KeyboardEvent} ev
     */
    onWindowKeyDown(ev) {
        if (ev.key === "Control") {
            this.prevDragAction =
                this.interaction.dragAction === "copy" ? "reschedule" : this.interaction.dragAction;
            this.interaction.dragAction = "copy";
        }
    }

    /**
     * @param {KeyboardEvent} ev
     */
    onWindowKeyUp(ev) {
        if (ev.key === "Control") {
            this.interaction.dragAction = this.prevDragAction || "reschedule";
        }
    }
}

return __exports;
});
;

/***************************************************************
*  Filepath: /web_gantt/static/src/gantt_renderer_controls.js  *
*  Lines: 232                                                  *
***************************************************************/
odoo.define('@web_gantt/gantt_renderer_controls', ['@odoo/owl', '@web/core/datetime/datetime_hook', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_hooks', '@web/core/dropdown/dropdown_item', '@web/core/l10n/dates', '@web/core/l10n/translation', '@web/core/utils/objects', '@web/core/utils/timing', '@web_gantt/gantt_helpers'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { useDateTimePicker } = require("@web/core/datetime/datetime_hook");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { useDropdownState } = require("@web/core/dropdown/dropdown_hooks");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { formatDate } = require("@web/core/l10n/dates");
const { _t } = require("@web/core/l10n/translation");
const { pick } = require("@web/core/utils/objects");
const { debounce } = require("@web/core/utils/timing");
const {
    diffColumn,
    getRangeFromDate,
    localStartOf,
    useGanttResponsivePopover,
} = require("@web_gantt/gantt_helpers");

const { DateTime } = luxon;

const KEYS = ["startDate", "stopDate", "rangeId", "focusDate"];

const GanttRendererControls = __exports.GanttRendererControls = class GanttRendererControls extends Component {
    static template = "web_gantt.GanttRendererControls";
    static components = {
        Dropdown,
        DropdownItem,
    };
    static props = ["model", "displayExpandCollapseButtons", "focusToday", "getCurrentFocusDate"];
    static toolbarContentTemplate = "web_gantt.GanttRendererControls.ToolbarContent";
    static rangeMenuTemplate = "web_gantt.GanttRendererControls.RangeMenu";

    setup() {
        this.model = this.props.model;
        this.updateMetaData = debounce(() => this.model.fetchData(this.makeParams()), 500);

        const { metaData } = this.model;
        this.state = useState({
            scaleIndex: this.getScaleIndex(metaData.scale.id),
            ...pick(metaData, ...KEYS),
        });
        this.pickerValues = useState({
            startDate: metaData.startDate,
            stopDate: metaData.stopDate,
        });
        this.scalesRange = { min: 0, max: Object.keys(metaData.scales).length - 1 };

        const getPickerProps = (key) => ({ type: "date", value: this.pickerValues[key] });
        this.startPicker = useDateTimePicker({
            target: "start-picker",
            onApply: (date) => {
                this.pickerValues.startDate = date;
                if (this.pickerValues.stopDate < date) {
                    this.pickerValues.stopDate = date;
                } else if (date.plus({ year: 10, day: -1 }) < this.pickerValues.stopDate) {
                    this.pickerValues.stopDate = date.plus({ year: 10, day: -1 });
                }
            },
            get pickerProps() {
                return getPickerProps("startDate");
            },
            createPopover: (...args) => useGanttResponsivePopover(_t("Gantt start date"), ...args),
            ensureVisibility: () => false,
        });
        this.stopPicker = useDateTimePicker({
            target: "stop-picker",
            onApply: (date) => {
                this.pickerValues.stopDate = date;
                if (date < this.pickerValues.startDate) {
                    this.pickerValues.startDate = date;
                } else if (this.pickerValues.startDate.plus({ year: 10, day: -1 }) < date) {
                    this.pickerValues.startDate = date.minus({ year: 10, day: -1 });
                }
            },
            get pickerProps() {
                return getPickerProps("stopDate");
            },
            createPopover: (...args) => useGanttResponsivePopover(_t("Gantt stop date"), ...args),
            ensureVisibility: () => false,
        });

        this.dropdownState = useDropdownState();
    }

    get dateDescription() {
        const { focusDate, rangeId } = this.state;
        switch (rangeId) {
            case "quarter":
                return focusDate.toFormat(`Qq yyyy`);
            case "day":
                return formatDate(focusDate);
            default:
                return this.model.metaData.ranges[rangeId].groupHeaderFormatter(
                    focusDate,
                    this.env
                );
        }
    }

    get formattedDateRange() {
        return _t("From: %(from_date)s to: %(to_date)s", {
            from_date: formatDate(this.state.startDate),
            to_date: formatDate(this.state.stopDate),
        });
    }

    getFormattedDate(date) {
        return formatDate(date);
    }

    getScaleIdFromIndex(index) {
        const keys = Object.keys(this.model.metaData.scales);
        return keys[keys.length - 1 - index];
    }

    getScaleIndex(scaleId) {
        const keys = Object.keys(this.model.metaData.scales);
        return keys.length - 1 - keys.findIndex((id) => id === scaleId);
    }

    getScaleIndexFromRangeId(rangeId) {
        const { ranges } = this.model.metaData;
        const scaleId = ranges[rangeId].scaleId;
        return this.getScaleIndex(scaleId);
    }

    /**
     * @param {1|-1} inc
     */
    incrementScale(inc) {
        if (
            inc === 1
                ? this.state.scaleIndex < this.scalesRange.max
                : this.scalesRange.min < this.state.scaleIndex
        ) {
            this.state.scaleIndex += inc;
            this.updateMetaData();
        }
    }

    isSelected(rangeId) {
        if (rangeId === "custom") {
            return (
                this.state.rangeId === rangeId ||
                !localStartOf(this.state.focusDate, this.state.rangeId).equals(
                    localStartOf(DateTime.now(), this.state.rangeId)
                )
            );
        }
        return (
            this.state.rangeId === rangeId &&
            localStartOf(this.state.focusDate, rangeId).equals(
                localStartOf(DateTime.now(), rangeId)
            )
        );
    }

    makeParams() {
        return {
            currentFocusDate: this.props.getCurrentFocusDate(),
            scaleId: this.getScaleIdFromIndex(this.state.scaleIndex),
            ...pick(this.state, ...KEYS),
        };
    }

    onApply() {
        this.state.startDate = this.pickerValues.startDate;
        this.state.stopDate = this.pickerValues.stopDate;
        this.state.rangeId = "custom";
        this.updateMetaData();
        this.dropdownState.close();
    }

    onTodayClicked() {
        const success = this.props.focusToday();
        if (success) {
            return;
        }
        this.state.focusDate = DateTime.local().startOf("day");
        if (this.state.rangeId === "custom") {
            const diff = diffColumn(this.state.startDate, this.state.stopDate, "day");
            const n = Math.floor(diff / 2);
            const m = diff - n;
            this.state.startDate = this.state.focusDate.minus({ day: n });
            this.state.stopDate = this.state.focusDate.plus({ day: m - 1 });
        } else {
            this.state.startDate = this.state.focusDate.startOf(this.state.rangeId);
            this.state.stopDate = this.state.focusDate.endOf(this.state.rangeId).startOf("day");
        }
        this.updatePickerValues();
        this.updateMetaData();
    }

    selectRange(direction) {
        const sign = direction === "next" ? 1 : -1;
        const { focusDate, rangeId, startDate, stopDate } = this.state;
        if (rangeId === "custom") {
            const diff = diffColumn(startDate, stopDate, "day") + 1;
            this.state.focusDate = focusDate.plus({ day: sign * diff });
            this.state.startDate = startDate.plus({ day: sign * diff });
            this.state.stopDate = stopDate.plus({ day: sign * diff });
        } else {
            Object.assign(
                this.state,
                getRangeFromDate(rangeId, focusDate.plus({ [rangeId]: sign }))
            );
        }
        this.updatePickerValues();
        this.updateMetaData();
    }

    selectRangeId(rangeId) {
        Object.assign(this.state, getRangeFromDate(rangeId, DateTime.now().startOf("day")));
        this.state.scaleIndex = this.getScaleIndexFromRangeId(rangeId);
        this.updatePickerValues();
        this.updateMetaData();
    }

    selectScale(index) {
        this.state.scaleIndex = Number(index);
        this.updateMetaData();
    }

    updatePickerValues() {
        this.pickerValues.startDate = this.state.startDate;
        this.pickerValues.stopDate = this.state.stopDate;
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_gantt/static/src/gantt_resize_badge.js  *
*  Lines: 50                                              *
**********************************************************/
odoo.define('@web_gantt/gantt_resize_badge', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");

const GanttResizeBadge = __exports.GanttResizeBadge = class GanttResizeBadge extends Component {
    static props = {
        reactive: {
            type: Object,
            shape: {
                position: {
                    type: Object,
                    shape: {
                        top: Number,
                        right: { type: Number, optional: true },
                        left: { type: Number, optional: true },
                    },
                    optional: true,
                },
                diff: { type: Number, optional: true },
                scale: { type: String, optional: true },
            },
        },
    };
    static template = "web_gantt.GanttResizeBadge";

    get diff() {
        return this.props.reactive.diff || 0;
    }

    get diffText() {
        const { diff, props } = this;
        const prefix = this.diff > 0 ? "+" : "";
        return `${prefix}${diff} ${props.reactive.scale}`;
    }

    get positionStyle() {
        const { position } = this.props.reactive;
        const style = [`top:${position.top}px`];
        if ("left" in position) {
            style.push(`left:${position.left}px`);
        } else {
            style.push(`right:${position.right}px`);
        }
        return style.join(";");
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web_gantt/static/src/gantt_row_progress_bar.js  *
*  Lines: 42                                                  *
**************************************************************/
odoo.define('@web_gantt/gantt_row_progress_bar', ['@odoo/owl', '@web/core/browser/feature_detection'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { hasTouch, isMobileOS } = require("@web/core/browser/feature_detection");

const GanttRowProgressBar = __exports.GanttRowProgressBar = class GanttRowProgressBar extends Component {
    static props = {
        reactive: {
            type: Object,
            shape: {
                hoveredRowId: [String, { value: null }],
            },
        },
        rowId: String,
        progressBar: {
            type: Object,
            shape: {
                max_value: Number,
                max_value_formatted: String,
                ratio: Number,
                value_formatted: String,
                warning: { type: String, optional: true },
                "*": true,
            },
        },
    };
    static template = "web_gantt.GanttRowProgressBar";

    get show() {
        const { reactive, rowId } = this.props;
        return reactive.hoveredRowId === rowId || isMobileOS() || hasTouch();
    }

    get status() {
        const { ratio } = this.props.progressBar;
        return ratio > 100 ? "danger" : ratio > 0 ? "success" : null;
    }
}

return __exports;
});
;

/***********************************************************
*  Filepath: /web_gantt/static/src/gantt_sample_server.js  *
*  Lines: 49                                               *
***********************************************************/
odoo.define('@web_gantt/gantt_sample_server', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

function _mockGetGanttData(params) {
    const lazy = !params.limit && !params.offset && params.groupby.length === 1;
    let { groups, length } = this._mockWebReadGroup({
        ...params,
        lazy,
        fields: ["__record_ids:array_agg(id)"],
    });
    if (params.limit) {
        // we don't care about pager feature in sample mode
        // but we want to present something coherent
        groups = groups.slice(0, params.limit);
        length = groups.length;
    }
    groups.forEach((g) => (g.__record_ids = g.id)); // the sample server does not use the key __record_ids

    const recordIds = [];
    for (const group of groups) {
        recordIds.push(...(group.__record_ids || []));
    }

    const { records } = this._mockWebSearchReadUnity({
        model: params.model,
        domain: [["id", "in", recordIds]],
        context: params.context,
        specification: params.read_specification,
    });

    const unavailabilities = {};
    for (const fieldName of params.unavailability_fields || []) {
        unavailabilities[fieldName] = {};
    }

    const progress_bars = {};
    for (const fieldName of params.progress_bar_fields || []) {
        progress_bars[fieldName] = {};
    }

    return { groups, length, records, unavailabilities, progress_bars };
}

registry.category("sample_server").add("get_gantt_data", _mockGetGanttData);

return __exports;
});
;

/**************************************************
*  Filepath: /web_gantt/static/src/gantt_view.js  *
*  Lines: 68                                      *
**************************************************/
odoo.define('@web_gantt/gantt_view', ['@web/core/registry', '@web/search/action_hook', '@web_gantt/gantt_arch_parser', '@web_gantt/gantt_controller', '@web_gantt/gantt_model', '@web_gantt/gantt_renderer', '@web/core/utils/objects'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { scrollSymbol } = require("@web/search/action_hook");
const { GanttArchParser } = require("@web_gantt/gantt_arch_parser");
const { GanttController } = require("@web_gantt/gantt_controller");
const { GanttModel } = require("@web_gantt/gantt_model");
const { GanttRenderer } = require("@web_gantt/gantt_renderer");
const { omit } = require("@web/core/utils/objects");

const viewRegistry = registry.category("views");

const ganttView = __exports.ganttView = {
    type: "gantt",
    Controller: GanttController,
    Renderer: GanttRenderer,
    Model: GanttModel,
    ArchParser: GanttArchParser,
    searchMenuTypes: ["filter", "groupBy", "favorite"],
    buttonTemplate: "web_gantt.GanttView.Buttons",

    props: (genericProps, view, config) => {
        const modelParams = {};
        let scrollPosition;
        if (genericProps.state) {
            scrollPosition = genericProps.state[scrollSymbol];
            modelParams.metaData = genericProps.state.metaData;
            modelParams.displayParams = genericProps.state.displayParams;
        } else {
            const { arch, fields, resModel } = genericProps;
            const parser = new view.ArchParser();
            const archInfo = parser.parse(arch);

            let formViewId = archInfo.formViewId;
            if (!formViewId) {
                const formView = config.views.find((v) => v[1] === "form");
                if (formView) {
                    formViewId = formView[0];
                }
            }

            modelParams.metaData = {
                ...omit(archInfo, "displayMode"),
                fields,
                resModel,
                formViewId,
            };
            modelParams.displayParams = {
                displayMode: archInfo.displayMode,
            };
        }

        return {
            ...genericProps,
            modelParams,
            Model: view.Model,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
            scrollPosition,
        };
    },
};

viewRegistry.add("gantt", ganttView);

return __exports;
});
;

/***********************************************************
*  Filepath: /web_cohort/static/src/cohort_arch_parser.js  *
*  Lines: 104                                              *
***********************************************************/
odoo.define('@web_cohort/cohort_arch_parser', ['@web/core/l10n/translation', '@web/core/utils/strings', '@web/core/utils/xml', '@web_cohort/cohort_model'], function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { _t } = require("@web/core/l10n/translation");
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");
const { INTERVALS, MODES, TIMELINES } = require("@web_cohort/cohort_model");

const CohortArchParser = __exports.CohortArchParser = class CohortArchParser {
    parse(arch, fields) {
        const archInfo = {
            fieldAttrs: {},
            widgets: {},
        };
        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "cohort": {
                    if (node.hasAttribute("disable_linking")) {
                        archInfo.disableLinking = exprToBoolean(
                            node.getAttribute("disable_linking")
                        );
                    }
                    const title = node.getAttribute("string");
                    if (title) {
                        archInfo.title = title;
                    }
                    const dateStart = node.getAttribute("date_start");
                    if (dateStart) {
                        archInfo.dateStart = dateStart;
                        archInfo.dateStartString = fields[dateStart].string;
                    } else {
                        throw new Error(_t('Cohort view has not defined "date_start" attribute.'));
                    }
                    const dateStop = node.getAttribute("date_stop");
                    if (dateStop) {
                        archInfo.dateStop = dateStop;
                        archInfo.dateStopString = fields[dateStop].string;
                    } else {
                        throw new Error(_t('Cohort view has not defined "date_stop" attribute.'));
                    }
                    const mode = node.getAttribute("mode") || "retention";
                    if (mode && MODES.includes(mode)) {
                        archInfo.mode = mode;
                    } else {
                        throw new Error(
                            _t(
                                "The argument %(mode)s is not a valid mode. Here are the modes: %(modes)s",
                                { mode, modes: MODES }
                            )
                        );
                    }
                    const timeline = node.getAttribute("timeline") || "forward";
                    if (timeline && TIMELINES.includes(timeline)) {
                        archInfo.timeline = timeline;
                    } else {
                        throw new Error(
                            _t(
                                "The argument %(timeline)s is not a valid timeline. Here are the timelines: %(timelines)s",
                                { timeline, timelines: TIMELINES }
                            )
                        );
                    }
                    archInfo.measure = node.getAttribute("measure") || "__count";
                    const interval = node.getAttribute("interval") || "day";
                    if (interval && interval in INTERVALS) {
                        archInfo.interval = interval;
                    } else {
                        throw new Error(
                            _t(
                                "The argument %(interval)s is not a valid interval. Here are the intervals: %(intervals)s",
                                { interval, intervals: INTERVALS }
                            )
                        );
                    }
                    break;
                }
                case "field": {
                    const fieldName = node.getAttribute("name"); // exists (rng validation)

                    archInfo.fieldAttrs[fieldName] = {};
                    if (node.hasAttribute("string")) {
                        archInfo.fieldAttrs[fieldName].string = node.getAttribute("string");
                    }
                    if (
                        node.getAttribute("invisible") === "True" ||
                        node.getAttribute("invisible") === "1"
                    ) {
                        archInfo.fieldAttrs[fieldName].isInvisible = true;
                        break;
                    }
                    if (node.hasAttribute("widget")) {
                        archInfo.widgets[fieldName] = node.getAttribute("widget");
                    }
                }
            }
        });
        return archInfo;
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_cohort/static/src/cohort_controller.js  *
*  Lines: 77                                              *
**********************************************************/
odoo.define('@web_cohort/cohort_controller', ['@web/core/utils/hooks', '@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/search_bar/search_bar', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { useService } = require("@web/core/utils/hooks");
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, toRaw, useRef } = require("@odoo/owl");

const CohortController = __exports.CohortController = class CohortController extends Component {
    static template = "web_cohort.CohortView";
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.actionService = useService("action");
        this.model = useModelWithSampleData(this.props.Model, toRaw(this.props.modelParams));

        useSetupAction({
            rootRef: useRef("root"),
            getLocalState: () => {
                return { metaData: this.model.metaData };
            },
            getContext: () => this.getContext(),
        });
    }

    getContext() {
        const { measure, interval } = this.model.metaData;
        return { cohort_measure: measure, cohort_interval: interval };
    }

    /**
     * @param {Object} row
     */
    onRowClicked(row) {
        if (row.value === undefined || this.model.metaData.disableLinking) {
            return;
        }

        const context = Object.assign({}, this.model.searchParams.context);
        const domain = row.domain;
        const views = {};
        for (const [viewId, viewType] of this.env.config.views || []) {
            views[viewType] = viewId;
        }
        function getView(viewType) {
            return [context[`${viewType}_view_id`] || views[viewType] || false, viewType];
        }
        const actionViews = [getView("list"), getView("form")];
        this.actionService.doAction({
            type: "ir.actions.act_window",
            name: this.model.metaData.title,
            res_model: this.model.metaData.resModel,
            views: actionViews,
            view_mode: "list",
            target: "current",
            context: context,
            domain: domain,
        });
    }
}

return __exports;
});
;

/*****************************************************
*  Filepath: /web_cohort/static/src/cohort_model.js  *
*  Lines: 135                                        *
*****************************************************/
odoo.define('@web_cohort/cohort_model', ['@web/core/l10n/translation', '@web/core/utils/concurrency', '@web/model/model', '@web/views/utils', '@web/core/browser/browser'], function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { _t } = require("@web/core/l10n/translation");
const { KeepLast, Race } = require("@web/core/utils/concurrency");
const { Model } = require("@web/model/model");
const { computeReportMeasures, processMeasure } = require("@web/views/utils");
const { browser } = require("@web/core/browser/browser");

const MODES = __exports.MODES = ["retention", "churn"];
const TIMELINES = __exports.TIMELINES = ["forward", "backward"];
const INTERVALS = __exports.INTERVALS = {
    day: _t("Day"),
    week: _t("Week"),
    month: _t("Month"),
    year: _t("Year"),
};

/**
 * @typedef {import("@web/search/search_model").SearchParams} SearchParams
 */

const CohortModel = __exports.CohortModel = class CohortModel extends Model {
    /**
     * @override
     */
    setup(params) {
        // concurrency management
        this.keepLast = new KeepLast();
        this.race = new Race();
        const _load = this._load.bind(this);
        this._load = (...args) => {
            return this.race.add(_load(...args));
        };

        this.metaData = params;
        this.data = null;
        this.searchParams = null;
        this.intervals = INTERVALS;

        const activeInterval = browser.localStorage.getItem(this.storageKey) || params.interval;
        if (Object.keys(this.intervals).includes(activeInterval)) {
            this.metaData.interval = activeInterval;
        }
    }

    /**
     * @param {SearchParams} searchParams
     */
    load(searchParams) {
        const { comparison, context, domain } = searchParams;
        this.searchParams = { context };
        if (comparison) {
            this.searchParams.domains = comparison.domains;
        } else {
            this.searchParams.domains = [{ arrayRepr: domain, description: null }];
        }
        const { cohort_interval, cohort_measure } = searchParams.context;
        this.metaData.interval = cohort_interval || this.metaData.interval;

        this.metaData.measure = processMeasure(cohort_measure) || this.metaData.measure;
        this.metaData.measures = computeReportMeasures(
            this.metaData.fields,
            this.metaData.fieldAttrs,
            [this.metaData.measure],
            { sumAggregatorOnly: true }
        );
        return this._load(this.metaData);
    }

    get storageKey() {
        return `scaleOf-viewId-${this.env.config.viewId}`;
    }

    /**
     * @override
     */
    hasData() {
        return this.data.some((data) => data.rows.length > 0);
    }

    /**
     * @param {Object} params
     */
    async updateMetaData(params) {
        Object.assign(this.metaData, params);
        browser.localStorage.setItem(this.storageKey, this.metaData.interval);
        await this._load(this.metaData);
        this.notify();
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    /**
     * @protected
     * @param {Object} metaData
     */
    async _load(metaData) {
        this.data = await this.keepLast.add(this._fetchData(metaData));
        for (const i in this.data) {
            this.data[i].title = this.searchParams.domains[i].description;
            this.data[i].rows.forEach((row) => {
                row.columns = row.columns.filter((col) => col.percentage !== "");
            });
        }
    }

    /**
     * @protected
     * @param {Object} metaData
     */
    async _fetchData(metaData) {
        return Promise.all(
            this.searchParams.domains.map(({ arrayRepr: domain }) => {
                return this.orm.call(metaData.resModel, "get_cohort_data", [], {
                    date_start: metaData.dateStart,
                    date_stop: metaData.dateStop,
                    measure: metaData.measure,
                    interval: metaData.interval,
                    domain: domain,
                    mode: metaData.mode,
                    timeline: metaData.timeline,
                    context: this.searchParams.context,
                });
            })
        );
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web_cohort/static/src/cohort_renderer.js  *
*  Lines: 117                                           *
********************************************************/
odoo.define('@web_cohort/cohort_renderer', ['@web/core/l10n/translation', '@web/views/fields/formatters', '@web/core/registry', '@odoo/owl', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/views/view_components/view_scale_selector', '@web/core/network/download', '@web/views/view_components/report_view_measures'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { formatPercentage } = require("@web/views/fields/formatters");
const { registry } = require("@web/core/registry");

const { Component } = require("@odoo/owl");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { ViewScaleSelector } = require("@web/views/view_components/view_scale_selector");
const { download } = require("@web/core/network/download");
const { ReportViewMeasures } = require("@web/views/view_components/report_view_measures");

const formatters = registry.category("formatters");

const CohortRenderer = __exports.CohortRenderer = class CohortRenderer extends Component {
    static components = { Dropdown, DropdownItem, ViewScaleSelector, ReportViewMeasures };
    static template = "web_cohort.CohortRenderer";
    static props = ["class", "model", "onRowClicked"];

    setup() {
        this.model = this.props.model;
    }

    range(n) {
        return Array.from({ length: n }, (_, i) => i);
    }

    getFormattedValue(value) {
        const fieldName = this.model.metaData.measure;
        const field = this.model.metaData.measures[fieldName];
        let formatType = this.model.metaData.widgets[fieldName];
        if (!formatType) {
            const fieldType = field.type;
            formatType = ["many2one", "reference"].includes(fieldType) ? "integer" : fieldType;
        }
        const formatter = formatters.get(formatType);
        return formatter(value, field);
    }

    formatPercentage(value) {
        return formatPercentage(value, { digits: [false, 1] });
    }

    getCellTitle(period, measure, count) {
        return _t("Period: %(period)s\n%(measure)s: %(count)s", { period, measure, count });
    }

    get scales() {
        return Object.fromEntries(
            Object.entries(this.model.intervals).map(([s, d]) => [s, { description: d }])
        );
    }

    /**
     * @param {String} scale
     */
    setScale(scale) {
        this.model.updateMetaData({
            interval: scale,
        });
    }

    /**
     * @param {Object} param0
     * @param {string} param0.measure
     */
    onMeasureSelected({ measure }) {
        this.model.updateMetaData({ measure });
    }

    /**
     * Export cohort data in Excel file
     */
    async downloadExcel() {
        const {
            title,
            resModel,
            interval,
            measure,
            measures,
            dateStartString,
            dateStopString,
            timeline,
        } = this.model.metaData;
        const { domains } = this.model.searchParams;
        const data = {
            title: title,
            model: resModel,
            interval_string: this.model.intervals[interval].toString(), // intervals are lazy-translated
            measure_string: measures[measure].string,
            date_start_string: dateStartString,
            date_stop_string: dateStopString,
            timeline: timeline,
            rangeDescription: domains[0].description,
            report: this.model.data[0],
            comparisonRangeDescription: domains[1] && domains[1].description,
            comparisonReport: this.model.data[1],
        };
        this.env.services.ui.block();
        try {
            // FIXME: [SAD/JPP] some data seems to be missing from the export in master. (check the python)
            await download({
                url: "/web/cohort/export",
                data: { data: new Blob([JSON.stringify(data)], { type: "application/json" }) },
            });
        } finally {
            this.env.services.ui.unblock();
        }
    }
}

return __exports;
});
;

/****************************************************
*  Filepath: /web_cohort/static/src/cohort_view.js  *
*  Lines: 60                                        *
****************************************************/
odoo.define('@web_cohort/cohort_view', ['@web/core/registry', '@web_cohort/cohort_controller', '@web_cohort/cohort_renderer', '@web_cohort/cohort_arch_parser', '@web_cohort/cohort_model'], function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { registry } = require("@web/core/registry");
const { CohortController } = require("@web_cohort/cohort_controller");
const { CohortRenderer } = require("@web_cohort/cohort_renderer");
const { CohortArchParser } = require("@web_cohort/cohort_arch_parser");
const { CohortModel } = require("@web_cohort/cohort_model");

const cohortView = __exports.cohortView = {
    type: "cohort",
    buttonTemplate: "web_cohort.CohortView.Buttons",
    searchMenuTypes: ["filter", "comparison", "favorite"],
    Model: CohortModel,
    ArchParser: CohortArchParser,
    Controller: CohortController,
    Renderer: CohortRenderer,

    props: (genericProps, view) => {
        let modelParams;
        if (genericProps.state) {
            modelParams = genericProps.state.metaData;
        } else {
            const { arch, fields, resModel } = genericProps;
            const { ArchParser } = view;
            const archInfo = new ArchParser().parse(arch, fields);
            modelParams = {
                dateStart: archInfo.dateStart,
                dateStartString: archInfo.dateStartString,
                dateStop: archInfo.dateStop,
                dateStopString: archInfo.dateStopString,
                fieldAttrs: archInfo.fieldAttrs,
                fields: fields,
                interval: archInfo.interval,
                measure: archInfo.measure,
                mode: archInfo.mode,
                resModel: resModel,
                timeline: archInfo.timeline,
                title: archInfo.title,
                disableLinking: Boolean(archInfo.disableLinking),
                widgets: archInfo.widgets,
            };
        }

        return {
            ...genericProps,
            modelParams,
            Model: view.Model,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

registry.category("views").add("cohort", cohortView);

return __exports;
});
;

/******************************************************************
*  Filepath: /web_cohort/static/src/cohort_view_sample_server.js  *
*  Lines: 103                                                     *
******************************************************************/
odoo.define('@web_cohort/cohort_view_sample_server', ['@web/core/l10n/dates', '@web/core/registry', '@web/model/sample_server'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { parseDate } = require("@web/core/l10n/dates");
const { registry } = require("@web/core/registry");
const { SampleServer } = require("@web/model/sample_server");

/**
 * This function mocks calls to the 'get_cohort_data' method. It is
 * registered to the SampleServer's mockRegistry, so it is called with a
 * SampleServer instance as "this".
 * @private
 * @param {Object} params
 * @param {string} params.model
 * @param {Object} params.kwargs
 * @returns {Object}
 */
function _mockGetCohortData(params) {
    const { model, date_start, interval, measure, mode, timeline } = params;

    const columns_avg = {};
    const rows = [];
    let initialChurnValue = 0;

    const groups = this._mockReadGroup({
        model,
        fields: [date_start],
        groupBy: [date_start + ":" + interval],
    });
    const totalCount = groups.length;
    let totalValue = 0;
    for (const group of groups) {
        const format = SampleServer.FORMATS[interval];
        const displayFormat = SampleServer.DISPLAY_FORMATS[interval];
        const date = parseDate(group[date_start + ":" + interval], { format });
        const now = luxon.DateTime.local();
        let colStartDate = date;
        if (timeline === "backward") {
            colStartDate = colStartDate.plus({ [`${interval}s`]: -15 });
        }

        let value =
            measure === "__count"
                ? this._getRandomInt(SampleServer.MAX_INTEGER)
                : this._generateFieldValue(model, measure);
        value = value || 25;
        totalValue += value;
        let initialValue = value;
        let max = value;

        const columns = [];
        for (let column = 0; column <= 15; column++) {
            if (!columns_avg[column]) {
                columns_avg[column] = { percentage: 0, count: 0 };
            }
            if (colStartDate.plus({ [`${interval}s`]: column }) > now) {
                columns.push({ value: "-", churn_value: "-", percentage: "" });
                continue;
            }
            let colValue = 0;
            if (max > 0) {
                colValue = Math.min(Math.round(Math.random() * max), max);
                max -= colValue;
            }
            if (timeline === "backward" && column === 0) {
                initialValue = Math.min(Math.round(Math.random() * value), value);
                initialChurnValue = value - initialValue;
            }
            const previousValue = column === 0 ? initialValue : columns[column - 1].value;
            const remainingValue = previousValue - colValue;
            const previousChurnValue =
                column === 0 ? initialChurnValue : columns[column - 1].churn_value;
            const churn_value = colValue + previousChurnValue;
            let percentage = value ? parseFloat(remainingValue / value) : 0;
            if (mode === "churn") {
                percentage = 1 - percentage;
            }
            percentage = Number((100 * percentage).toFixed(1));
            columns_avg[column].percentage += percentage;
            columns_avg[column].count += 1;
            columns.push({
                value: remainingValue,
                churn_value,
                percentage,
                period: column, // used as a t-key but we don't care about value itself
            });
        }
        const keepRow = columns.some((c) => c.percentage !== "");
        if (keepRow) {
            rows.push({ date: date.toFormat(displayFormat), value, columns });
        }
    }
    const avg_value = totalCount ? totalValue / totalCount : 0;
    const avg = { avg_value, columns_avg };
    return { rows, avg };
}

registry.category("sample_server").add("get_cohort_data", _mockGetCohortData);

return __exports;
});
;

/************************************************************************
*  Filepath: /web_grid/static/src/components/float_factor_grid_cell.js  *
*  Lines: 46                                                            *
************************************************************************/
odoo.define('@web_grid/components/float_factor_grid_cell', ['@web/core/registry', '@web/views/fields/formatters', '@web_grid/components/grid_cell'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { formatFloatFactor } = require("@web/views/fields/formatters");
const { GridCell } = require("@web_grid/components/grid_cell");

function formatter(value, options = {}) {
    return formatFloatFactor(value, options);
}

const FloatFactorGridCell = __exports.FloatFactorGridCell = class FloatFactorGridCell extends GridCell {
    static props = {
        ...GridCell.props,
        factor: { type: Number, optional: true },
    };

    parse(value) {
        const factorValue = value / this.factor;
        return super.parse(factorValue.toString());
    }

    get factor() {
        return this.props.factor || this.props.fieldInfo.options?.factor || 1;
    }

    get value() {
        return super.value * this.factor;
    }

    get formattedValue() {
        return formatter(this.value);
    }
}

const floatFactorGridCell = __exports.floatFactorGridCell = {
    component: FloatFactorGridCell,
    formatter,
};

registry.category("grid_components").add("float_factor", floatFactorGridCell);

return __exports;
});
;

/**********************************************************************
*  Filepath: /web_grid/static/src/components/float_time_grid_cell.js  *
*  Lines: 37                                                          *
**********************************************************************/
odoo.define('@web_grid/components/float_time_grid_cell', ['@web/core/registry', '@web/views/fields/parsers', '@web/views/fields/formatters', '@web_grid/components/grid_cell'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { parseFloatTime } = require("@web/views/fields/parsers");
const { formatFloatTime } = require("@web/views/fields/formatters");
const { GridCell } = require("@web_grid/components/grid_cell");

function formatter(value, options = {}) {
    return formatFloatTime(value, { ...options, noLeadingZeroHour: true });
}

const FloatTimeGridCell = __exports.FloatTimeGridCell = class FloatTimeGridCell extends GridCell {
    get formattedValue() {
        return formatter(this.value);
    }

    get inputMode() {
        return "text";
    }

    parse(value) {
        return parseFloatTime(value);
    }
}

const floatTimeGridCell = __exports.floatTimeGridCell = {
    component: FloatTimeGridCell,
    formatter,
};

registry.category("grid_components").add("float_time", floatTimeGridCell);

return __exports;
});
;

/************************************************************************
*  Filepath: /web_grid/static/src/components/float_toggle_grid_cell.js  *
*  Lines: 103                                                           *
************************************************************************/
odoo.define('@web_grid/components/float_toggle_grid_cell', ['@web/core/registry', '@web/views/fields/formatters', '@web_grid/hooks/grid_cell_hook', '@web_grid/components/grid_cell', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { formatFloatFactor } = require("@web/views/fields/formatters");
const { useGridCell, useMagnifierGlass } = require("@web_grid/hooks/grid_cell_hook");
const { standardGridCellProps } = require("@web_grid/components/grid_cell");

const { Component, useRef, useState, useEffect } = require("@odoo/owl");

function formatter(value, options = {}) {
    return formatFloatFactor(value, options);
}

const FloatToggleGridCell = __exports.FloatToggleGridCell = class FloatToggleGridCell extends Component {
    static props = {
        ...standardGridCellProps,
        factor: { type: Number, optional: true },
    };
    static template = "web_grid.FloatToggleGridCell";

    setup() {
        this.rootRef = useRef("root");
        this.buttonRef = useRef("toggleButton");
        this.magnifierGlassHook = useMagnifierGlass();
        this.state = useState({
            edit: this.props.editMode,
            invalid: false,
            cell: null,
        });
        useGridCell();

        useEffect(
            (buttonEl) => {
                if (buttonEl) {
                    buttonEl.focus();
                }
            },
            () => [this.buttonRef.el]
        );
    }

    get factor() {
        return this.props.factor || this.props.fieldInfo.options?.factor || 1;
    }

    get range() {
        return this.props.fieldInfo.options?.range || [0.0, 0.5, 1.0];
    }

    get value() {
        return (this.state.cell.value || 0) * this.factor;
    }

    get formattedValue() {
        return formatter(this.state.cell.value || 0, {
            digits: this.props.fieldInfo.attrs?.digits || 2,
            factor: this.factor,
        });
    }

    isEditable(props = this.props) {
        return (
            !props.readonly && this.state.cell?.readonly === false && !this.state.cell.row.isSection
        );
    }

    onChange() {
        let currentIndex = this.range.indexOf(this.value);
        currentIndex++;
        if (currentIndex > this.range.length - 1) {
            currentIndex = 0;
        }
        this.update(this.range[currentIndex] / this.factor);
    }

    update(value) {
        this.state.cell.update(value);
    }

    onCellClick(ev) {
        if (this.isEditable() && !this.state.edit && !ev.target.closest(".o_grid_search_btn")) {
            this.onChange();
            this.props.onEdit(true);
        }
    }

    onKeyDown(ev) {
        this.props.onKeyDown(ev, this.state.cell);
    }
}

const floatToggleGridCell = __exports.floatToggleGridCell = {
    component: FloatToggleGridCell,
    formatter,
};

registry.category("grid_components").add("float_toggle", floatToggleGridCell);

return __exports;
});
;

/***********************************************************
*  Filepath: /web_grid/static/src/components/grid_cell.js  *
*  Lines: 178                                              *
***********************************************************/
odoo.define('@web_grid/components/grid_cell', ['@web/core/registry', '@web/views/fields/numpad_decimal_hook', '@web/views/fields/formatters', '@web/core/utils/numbers', '@web/views/fields/parsers', '@web_grid/hooks/input_hook', '@odoo/owl', '@web_grid/hooks/grid_cell_hook'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");

const { useNumpadDecimal } = require("@web/views/fields/numpad_decimal_hook");
const { formatInteger } = require("@web/views/fields/formatters");
const { formatFloat } = require("@web/core/utils/numbers");
const { parseInteger, parseFloat } = require("@web/views/fields/parsers");
const { useInputHook } = require("@web_grid/hooks/input_hook");

const { Component, useEffect, useRef, useState } = require("@odoo/owl");
const { useGridCell, useMagnifierGlass } = require("@web_grid/hooks/grid_cell_hook");

const standardGridCellProps = __exports.standardGridCellProps = {
    name: String,
    classNames: String,
    fieldInfo: Object,
    readonly: { type: Boolean, optional: true },
    editMode: { type: Boolean, optional: true },
    reactive: {
        type: Object,
        shape: {
            cell: [HTMLElement, { value: null }],
        },
    },
    openRecords: Function,
    onEdit: Function,
    getCell: Function,
    onKeyDown: { type: Function, optional: true },
};

const GridCell = __exports.GridCell = class GridCell extends Component {
    static template = "web_grid.Cell";
    static props = standardGridCellProps;
    static defaultProps = {
        readonly: true,
        editMode: false,
    };

    setup() {
        this.rootRef = useRef("root");
        this.state = useState({
            edit: this.props.editMode,
            invalid: false,
            cell: null,
        });
        this.discardChanges = false;
        this.magnifierGlassHook = useMagnifierGlass();
        this.inputRef = useInputHook({
            getValue: () => this.formattedValue,
            refName: "numpadDecimal",
            parse: this.parse.bind(this),
            notifyChange: this.onChange.bind(this),
            commitChanges: this.saveEdition.bind(this),
            onKeyDown: (ev) => this.props.onKeyDown(ev, this.state.cell),
            discard: this.discard.bind(this),
            setInvalid: () => {
                this.state.invalid = true;
            },
            setDirty: () => {
                this.state.invalid = false;
            },
            isInvalid: () => this.state.invalid,
        });
        useNumpadDecimal();

        useGridCell();
        useEffect(
            (edit, inputEl, cellEl) => {
                if (inputEl) {
                    inputEl.value = this.formattedValue;
                }
                if (edit && inputEl) {
                    inputEl.focus();
                    if (inputEl.type === "text") {
                        if (inputEl.selectionStart === null) {
                            return;
                        }
                        if (inputEl.selectionStart === inputEl.selectionEnd) {
                            inputEl.selectionStart = 0;
                            inputEl.selectionEnd = inputEl.value.length;
                        }
                    }
                }
                this.discardChanges = false;
            },
            () => [this.state.edit, this.inputRef.el, this.props.reactive.cell]
        );
    }

    get value() {
        return this.state.cell?.value || 0;
    }

    get section() {
        return this.row.getSection();
    }

    get row() {
        return this.state.cell?.row;
    }

    get formattedValue() {
        const { type, digits } = this.props.fieldInfo;
        if (type === "integer") {
            return formatInteger(this.value);
        }
        return formatFloat(this.value, { digits: digits || 2 });
    }

    get inputMode() {
        return "numeric";
    }

    isEditable(props = this.props) {
        return (
            !props.readonly && this.state.cell?.readonly === false && !this.state.cell.row.isSection
        );
    }

    parse(value) {
        if (this.props.fieldInfo.type === "integer") {
            return parseInteger(value);
        }
        return parseFloat(value);
    }

    onChange(value) {
        if (!this.discardChanges) {
            this.update(value);
        }
    }

    update(value) {
        this.state.cell.update(value);
    }

    saveEdition(value) {
        const changesCommitted = (value || false) !== (this.state.cell.value || false);
        if ((value || false) !== (this.state.cell?.value || false)) {
            this.update(value);
        }
        this.props.onEdit(false);
        return changesCommitted;
    }

    discard() {
        this.discardChanges = true;
        this.props.onEdit(false);
    }

    onCellClick(ev) {
        if (this.isEditable() && !this.state.edit) {
            this.discardChanges = false;
            this.props.onEdit(true);
        }
    }
}

const integerGridCell = __exports.integerGridCell = {
    component: GridCell,
    formatter: formatInteger,
};

registry.category("grid_components").add("integer", integerGridCell);

const floatGridCell = __exports.floatGridCell = {
    component: GridCell,
    formatter: formatFloat,
};

registry.category("grid_components").add("float", floatGridCell);

return __exports;
});
;

/*******************************************************************************
*  Filepath: /web_grid/static/src/components/grid_component/grid_component.js  *
*  Lines: 44                                                                   *
*******************************************************************************/
odoo.define('@web_grid/components/grid_component/grid_component', ['@odoo/owl', '@web/core/registry', '@web_grid/components/grid_cell', '@web_grid/components/grid_row/grid_row'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { registry } = require("@web/core/registry");

const { GridCell } = require("@web_grid/components/grid_cell");
const { GridRow } = require("@web_grid/components/grid_row/grid_row");

const gridComponentRegistry = registry.category("grid_components");

const GridComponent = __exports.GridComponent = class GridComponent extends Component {
    static props = ["name", "type", "isMeasure?", "component?", "*"];
    static template = "web_grid.GridComponent"

    get gridComponent() {
        if (this.props.component) {
            return this.props.component;
        }
        if (gridComponentRegistry.contains(this.props.type)) {
            return gridComponentRegistry.get(this.props.type).component;
        }
        if (this.props.isMeasure) {
            console.warn(`Missing widget: ${this.props.type} for grid component`);
            return GridCell;
        }
        return GridRow;
    }

    get gridComponentProps() {
        const gridComponentProps = Object.fromEntries(
            Object.entries(this.props).filter(
                ([key,]) => key in this.gridComponent.props
            )
        );
        gridComponentProps.classNames = `o_grid_component o_grid_component_${this.props.type} ${gridComponentProps.classNames || ""}`;
        return gridComponentProps;
    }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /web_grid/static/src/components/grid_row/grid_row.js  *
*  Lines: 47                                                       *
*******************************************************************/
odoo.define('@web_grid/components/grid_row/grid_row', ['@odoo/owl', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");

const { registry } = require("@web/core/registry");

const GridRow = __exports.GridRow = class GridRow extends Component {
    static template = "web_grid.GridRow";
    static props = {
        name: String,
        model: Object,
        row: Object,
        classNames: { type: String, optional: true },
        context: { type: Object, optional: true },
        style: { type: String, optional: true },
        value: { optional: true },
    };
    static defaultProps = {
        classNames: "",
        context: {},
        style: "",
    };

    get value() {
        let value = 'value' in this.props ? this.props.value : this.props.row.initialRecordValues[this.props.name];
        const fieldInfo = this.props.model.fieldsInfo[this.props.name];
        if (fieldInfo.type === "selection") {
            value = fieldInfo.selection.find(([key,]) => key === value)?.[1];
        }
        return value;
    }
}

const gridRow = __exports.gridRow = {
    component: GridRow,
};

registry
    .category("grid_components")
    .add("selection", gridRow)
    .add("char", gridRow);

return __exports;
});
;

/*************************************************************************************
*  Filepath: /web_grid/static/src/components/many2one_grid_row/many2one_grid_row.js  *
*  Lines: 78                                                                         *
*************************************************************************************/
odoo.define('@web_grid/components/many2one_grid_row/many2one_grid_row', ['@web/core/registry', '@web/core/utils/hooks', '@web_grid/components/grid_row/grid_row'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { useService } = require("@web/core/utils/hooks");
const { GridRow, gridRow } = require("@web_grid/components/grid_row/grid_row");

const Many2OneGridRow = __exports.Many2OneGridRow = class Many2OneGridRow extends GridRow {
    static template = "web_grid.Many2OneGridRow";
    static props = {
        ...GridRow.props,
        relation: { type: String, optional: true },
        canOpen: { type: Boolean, optional: true },
    }
    static defaultProps = {
        ...GridRow.defaultProps,
        canOpen: true,
    };

    setup() {
        this.orm = useService("orm");
        this.actionService = useService("action");
    }

    get relation() {
        return this.props.relation || this.props.model.fieldsInfo[this.props.name].relation;
    }

    get urlRelation() {
        if (!this.relation.includes(".")) {
            return "m-" + this.relation;
        }
        return this.relation;
    }

    get displayName() {
        return this.value && this.value[1].split("\n", 1)[0];
    }

    get extraLines() {
        return this.value
            ? this.value[1]
                  .split("\n")
                  .map((line) => line.trim())
                  .slice(1)
            : [];
    }

    get resId() {
        return this.value && this.value[0];
    }

    async openAction() {
        const action = await this.orm.call(this.relation, "get_formview_action", [[this.resId]], {
            context: this.props.context,
        });
        await this.actionService.doAction(action);
    }

    onClick(ev) {
        if (this.props.canOpen) {
            ev.stopPropagation();
            this.openAction();
        }
    }
}

const many2OneGridRow = __exports.many2OneGridRow = {
    ...gridRow,
    component: Many2OneGridRow,
};

registry.category("grid_components").add("many2one", many2OneGridRow);

return __exports;
});
;

/***********************************************************
*  Filepath: /web_grid/static/src/hooks/grid_cell_hook.js  *
*  Lines: 50                                               *
***********************************************************/
odoo.define('@web_grid/hooks/grid_cell_hook', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useComponent, useEffect } = require("@odoo/owl");

__exports.useMagnifierGlass = useMagnifierGlass; function useMagnifierGlass() {
    const component = useComponent();
    return {
        onMagnifierGlassClick() {
            const { context, domain, title } = component.state.cell;
            component.props.openRecords(title, domain.toList(), context);
        },
    };
}

__exports.useGridCell = useGridCell; function useGridCell() {
    const component = useComponent();
    useEffect(
        /** @param {HTMLElement | null} cellEl */
        (cellEl) => {
            if (!cellEl) {
                component.state.cell = null;
                return;
            }
            component.state.cell = component.props.getCell(
                cellEl.dataset.row,
                cellEl.dataset.column
            );
            Object.assign(component.rootRef.el.style, {
                "grid-row": cellEl.style["grid-row"],
                "grid-column": cellEl.style["grid-column"],
                "z-index": 1,
            });
            component.rootRef.el.dataset.gridRow = cellEl.dataset.gridRow;
            component.rootRef.el.dataset.gridColumn = cellEl.dataset.gridColumn;
            cellEl.querySelector(".o_grid_cell_readonly").classList.add("d-none");
            component.rootRef.el.classList.toggle(
                "o_field_cursor_disabled",
                !component.state.cell.row.isSection && !component.isEditable()
            );
            component.rootRef.el.classList.toggle("fw-bold", Boolean(component.state.cell.row.isSection));
        },
        () => [component.props.reactive.cell]
    );
}

return __exports;
});
;

/*******************************************************
*  Filepath: /web_grid/static/src/hooks/input_hook.js  *
*  Lines: 159                                          *
*******************************************************/
odoo.define('@web_grid/hooks/input_hook', ['@web/core/hotkeys/hotkey_service', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { getActiveHotkey } = require("@web/core/hotkeys/hotkey_service");

const { useEffect, useRef } = require("@odoo/owl");

__exports.useInputHook = useInputHook; function useInputHook(params) {
    const inputRef = params.ref || useRef(params.refName || "input");

    /*
     * A field is dirty if it is no longer sync with the model
     * More specifically, a field is no longer dirty after it has *tried* to update the value in the model.
     * An invalid value will therefore not be dirty even if the model will not actually store the invalid value.
     */
    let isDirty = false;

    /**
     * The last value that has been committed to the model.
     * Not changed in case of invalid field value.
     */
    let lastSetValue = null;

    /**
     * When a user types, we need to set the field as dirty.
     */
    function onInput(ev) {
        isDirty = ev.target.value !== lastSetValue;
        if (params.setDirty) {
            params.setDirty(isDirty);
        }
    }

    /**
     * On blur, we consider the field no longer dirty, even if it were to be invalid.
     * However, if the field is invalid, the new value will not be committed to the model.
     */
    function onChange(ev) {
        if (isDirty) {
            isDirty = false;
            let isInvalid = false;
            let val = ev.target.value;
            if (params.parse) {
                try {
                    val = params.parse(val);
                } catch {
                    if (params.setInvalid) {
                        params.setInvalid();
                    }
                    isInvalid = true;
                }
            }

            if (!isInvalid) {
                params.notifyChange(val);
                lastSetValue = ev.target.value;
            }

            if (params.setDirty) {
                params.setDirty(isDirty);
            }
        }
    }
    function onKeydown(ev) {
        const hotkey = getActiveHotkey(ev);
        if (params.discard && hotkey === "escape") {
            params.discard();
        } else if (params.commitChanges && ["enter", "tab", "shift+tab"].includes(hotkey)) {
            commitChanges();
        }
        if (params.onKeyDown) {
            params.onKeyDown(ev);
        }
    }

    useEffect(
        (inputEl) => {
            if (inputEl) {
                inputEl.addEventListener("input", onInput);
                inputEl.addEventListener("change", onChange);
                inputEl.addEventListener("keydown", onKeydown);
                return () => {
                    inputEl.removeEventListener("input", onInput);
                    inputEl.removeEventListener("change", onChange);
                    inputEl.removeEventListener("keydown", onKeydown);
                };
            }
        },
        () => [inputRef.el]
    );

    /**
     * Sometimes, a patch can happen with possible a new value for the field
     * If the user was typing a new value (isDirty) or the field is still invalid,
     * we need to do nothing.
     * If it is not such a case, we update the field with the new value.
     */
    useEffect(() => {
        const isInvalid = params.isInvalid ? params.isInvalid() : false;
        if (inputRef.el && !isDirty && !isInvalid) {
            inputRef.el.value = params.getValue();
            lastSetValue = inputRef.el.value;
        }
    });

    function isUrgentSaved(urgent) {
        if (params.isUrgentSaved) {
            return params.isUrgentSaved(urgent);
        }
        return urgent;
    }

    /**
     * Roughly the same as onChange, but called at more specific / critical times. (See bus events)
     */
    async function commitChanges(urgent) {
        if (!inputRef.el) {
            return;
        }

        isDirty = inputRef.el.value !== lastSetValue;
        if (isDirty || isUrgentSaved(urgent)) {
            let isInvalid = false;
            isDirty = false;
            let val = inputRef.el.value;
            if (params.parse) {
                try {
                    val = params.parse(val);
                } catch {
                    isInvalid = true;
                    if (urgent) {
                        return;
                    } else {
                        params.setInvalid();
                    }
                }
            }

            if (isInvalid) {
                return;
            }

            const result = params.commitChanges(val); // means change has been committed
            if (result) {
                lastSetValue = inputRef.el.value;
                if (params.setDirty) {
                    params.setDirty(isDirty);
                }
            }
        }
    }

    return inputRef;
}

return __exports;
});
;

/*************************************************************
*  Filepath: /web_grid/static/src/views/grid_arch_parser.js  *
*  Lines: 185                                                *
*************************************************************/
odoo.define('@web_grid/views/grid_arch_parser', ['@web/core/l10n/translation', '@web/core/utils/strings', '@web/core/utils/xml', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { _t } = require("@web/core/l10n/translation");
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");
const { getActiveActions, processButton } = require("@web/views/utils");

const GridArchParser = __exports.GridArchParser = class GridArchParser {
    parse(xmlDoc, models, modelName) {
        const archInfo = {
            activeActions: getActiveActions(xmlDoc),
            hideLineTotal: false,
            hideColumnTotal: false,
            hasBarChartTotal: false,
            createInline: false,
            displayEmpty: false,
            buttons: [],
            activeRangeName: "",
            ranges: {},
            sectionField: null,
            rowFields: [],
            columnFieldName: "",
            measureField: {
                name: "__count",
                aggregator: "sum",
                readonly: true,
                string: _t("Count"),
            },
            readonlyField: null,
            widgetPerFieldName: {},
            editable: false,
            formViewId: false,
        };
        let buttonId = 0;

        visitXML(xmlDoc, (node) => {
            if (node.tagName === "grid") {
                if (node.hasAttribute("hide_line_total")) {
                    archInfo.hideLineTotal = exprToBoolean(node.getAttribute("hide_line_total"));
                }
                if (node.hasAttribute("hide_column_total")) {
                    archInfo.hideColumnTotal = exprToBoolean(
                        node.getAttribute("hide_column_total")
                    );
                }
                if (node.hasAttribute("barchart_total")) {
                    archInfo.hasBarChartTotal = exprToBoolean(
                        node.getAttribute("barchart_total")
                    );
                }
                if (node.hasAttribute("create_inline")) {
                    archInfo.createInline = exprToBoolean(node.getAttribute("create_inline"));
                }
                if (node.hasAttribute("display_empty")) {
                    archInfo.displayEmpty = exprToBoolean(node.getAttribute("display_empty"));
                }
                if (node.hasAttribute("action") && node.hasAttribute("type")) {
                    archInfo.openAction = {
                        name: node.getAttribute("action"),
                        type: node.getAttribute("type"),
                    };
                }
                if (node.hasAttribute("editable")) {
                    archInfo.editable = exprToBoolean(node.getAttribute("editable"));
                }
                if (node.hasAttribute("form_view_id")) {
                    archInfo.formViewId = parseInt(node.getAttribute("form_view_id"), 10);
                }
            } else if (node.tagName === "field") {
                const fieldName = node.getAttribute("name"); // exists (rng validation)
                const fieldInfo = models[modelName].fields[fieldName];
                const type = node.getAttribute("type") || "row";
                const string = node.getAttribute("string") || fieldInfo.string;
                let invisible = node.getAttribute("invisible") || 'False';
                switch (type) {
                    case "row":
                        if (node.hasAttribute("widget")) {
                            archInfo.widgetPerFieldName[fieldName] = node.getAttribute("widget");
                        }
                        if (
                            node.hasAttribute("section") &&
                            exprToBoolean(node.getAttribute("section")) &&
                            !archInfo.sectionField
                        ) {
                            archInfo.sectionField = {
                                name: fieldName,
                                invisible,
                            };
                        } else {
                            archInfo.rowFields.push({
                                name: fieldName,
                                invisible,
                            });
                        }
                        break;
                    case "col":
                        archInfo.columnFieldName = fieldName;
                        const { ranges, activeRangeName } = this._extractRanges(node);
                        archInfo.ranges = ranges;
                        archInfo.activeRangeName = activeRangeName;
                        break;
                    case "measure":
                        if (node.hasAttribute("widget")) {
                            archInfo.widgetPerFieldName[fieldName] = node.getAttribute("widget");
                        }
                        archInfo.measureField = {
                            name: fieldName,
                            aggregator: node.getAttribute("operator") || fieldInfo.aggregator,
                            string,
                            readonly: exprToBoolean(node.getAttribute("readonly")) || fieldInfo.readonly,
                        };
                        break;
                    case "readonly":
                        let groupOperator = fieldInfo.aggregator;
                        if (node.hasAttribute("operator")) {
                            groupOperator = node.getAttribute("operator");
                        }
                        archInfo.readonlyField = {
                            name: fieldName,
                            aggregator: groupOperator,
                            string,
                        };
                        break;
                }
            } else if (node.tagName === "button") {
                archInfo.buttons.push({
                    ...processButton(node),
                    type: "button",
                    id: buttonId++,
                });
            }
        });
        archInfo.editable =
            archInfo.editable &&
            archInfo.measureField &&
            !archInfo.measureField.readonly &&
            archInfo.measureField.aggregator === "sum";
        return archInfo;
    }

    /**
     * Extract the range to display on the view, and filter
     * them according they should be visible or not (attribute 'invisible')
     *
     * @private
     * @param {Element} colNode - the node of 'col' in grid view arch definition
     * @returns {
     *      Object<{
     *          ranges: {
     *              name: {name: string, label: string, span: string, step: string, hotkey?: string}
     *          },
     *          activeRangeName: string,
     *      }>
     *  } list of ranges to apply in the grid view.
     */
    _extractRanges(colNode) {
        const ranges = {};
        let activeRangeName;
        let firstRangeName = "";
        for (const rangeNode of colNode.children) {
            const rangeName = rangeNode.getAttribute("name");
            if (!firstRangeName.length) {
                firstRangeName = rangeName;
            }
            ranges[rangeName] = {
                name: rangeName,
                description: rangeNode.getAttribute("string"),
                span: rangeNode.getAttribute("span"),
                step: rangeNode.getAttribute("step"),
                hotkey: rangeNode.getAttribute("hotkey"),
                default: exprToBoolean(rangeNode.getAttribute("default")),
            };
            if (ranges[rangeName].default) {
                activeRangeName = rangeName;
            }
        }
        return { ranges: ranges, activeRangeName: activeRangeName || firstRangeName };
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web_grid/static/src/views/grid_controller.js  *
*  Lines: 193                                               *
************************************************************/
odoo.define('@web_grid/views/grid_controller', ['@web/core/l10n/translation', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/l10n/dates', '@web/core/utils/hooks', '@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/views/view_button/view_button_hook', '@web/views/view_dialogs/form_view_dialog', '@web/views/view_button/view_button', '@web/search/action_hook', '@web/search/cog_menu/cog_menu', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/core/browser/browser', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { serializeDate, deserializeDate } = require("@web/core/l10n/dates");
const { useService } = require("@web/core/utils/hooks");
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useViewButtons } = require("@web/views/view_button/view_button_hook");
const { FormViewDialog } = require("@web/views/view_dialogs/form_view_dialog");
const { ViewButton } = require("@web/views/view_button/view_button");
const { useSetupAction } = require("@web/search/action_hook");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { browser } = require("@web/core/browser/browser");

const { Component, useState, onWillUnmount, useRef } = require("@odoo/owl");

const { DateTime } = luxon;

const GridController = __exports.GridController = class GridController extends Component {
    static components = {
        Layout,
        Dropdown,
        DropdownItem,
        ViewButton,
        CogMenu,
        SearchBar,
    };

    static props = {
        ...standardViewProps,
        archInfo: Object,
        buttonTemplate: String,
        Model: Function,
        Renderer: Function,
    };

    static template = "web_grid.GridView";

    setup() {
        const state = this.props.state || {};
        let activeRangeName = this.props.archInfo.activeRangeName;
        let defaultAnchor;
        if (state.activeRangeName) {
            activeRangeName = state.activeRangeName;
        } else if (this.isMobile && "day" in this.props.archInfo.ranges) {
            activeRangeName = "day";
        }
        if (state.anchor) {
            defaultAnchor = state.anchor;
        } else if (this.props.context.grid_anchor) {
            defaultAnchor = deserializeDate(this.props.context.grid_anchor);
        }
        this.dialogService = useService("dialog");
        this.model = useModelWithSampleData(this.props.Model, {
            resModel: this.props.resModel,
            sectionField: this.props.archInfo.sectionField,
            rowFields: this.props.archInfo.rowFields,
            columnFieldName: this.props.archInfo.columnFieldName,
            measureField: this.props.archInfo.measureField,
            readonlyField: this.props.archInfo.readonlyField,
            fieldsInfo: this.props.relatedModels[this.props.resModel].fields,
            activeRangeName,
            ranges: this.props.archInfo.ranges,
            defaultAnchor,
        });
        const rootRef = useRef("root");
        useSetupAction({
            rootRef: rootRef,
            getLocalState: () => {
                const { anchor, range } = this.model.navigationInfo;
                return {
                    anchor,
                    activeRangeName: range?.name,
                };
            }
        })
        const isWeekendVisible = browser.localStorage.getItem("grid.isWeekendVisible");
        this.state = useState({
            activeRangeName: this.model.navigationInfo.range?.name,
            isWeekendVisible: isWeekendVisible !== null && isWeekendVisible !== undefined
                ? JSON.parse(isWeekendVisible)
                : true,
        });
        useViewButtons(rootRef, {
            beforeExecuteAction: this.beforeExecuteActionButton.bind(this),
            afterExecuteAction: this.afterExecuteActionButton.bind(this),
            reload: this.reload.bind(this),
        });
        onWillUnmount(() => this.closeDialog?.());
        this.searchBarToggler = useSearchBarToggler();
    }

    get isMobile() {
        return this.env.isSmall;
    }

    get isEditable() {
        return (
            this.props.archInfo.activeActions.edit &&
            this.props.archInfo.editable
        );
    }

    get displayNoContent() {
        return (
            !(this.props.archInfo.displayEmpty || this.model.hasData()) || this.model.useSampleModel
        );
    }

    get displayAddALine() {
        return this.props.archInfo.activeActions.create;
    }

    get hasDisplayableData() {
        return true;
    }

    get options() {
        const { hideLineTotal, hideColumnTotal, hasBarChartTotal, createInline } =
            this.props.archInfo;
        return {
            hideLineTotal,
            hideColumnTotal,
            hasBarChartTotal,
            createInline,
        };
    }

    createRecord(params) {
        const columnContext = this.model.columnFieldIsDate
            ? {
                  [`default_${this.model.columnFieldName}`]: serializeDate(
                      this.model.navigationInfo.anchor
                  ),
              }
            : {};
        const context = {
            ...this.props.context,
            ...columnContext,
            ...(params?.context || {}),
        };
        this.closeDialog = this.dialogService.add(
            FormViewDialog,
            {
                title: _t("New Record"),
                resModel: this.model.resModel,
                viewId: this.props.archInfo.formViewId,
                onRecordSaved: this.onRecordSaved.bind(this),
                ...(params || {}),
                context,
            },
            {
                onClose: () => {
                    this.closeDialog = null;
                },
            }
        );
    }

    async beforeExecuteActionButton() {}

    async afterExecuteActionButton() {}

    async reload() {
        await this.model.fetchData();
    }

    async onRecordSaved(record) {
        await this.reload();
    }

    get columns() {
        return this.state.isWeekendVisible || this.state.activeRangeName === "day" ? this.model.columnsArray : this.model.columnsArray.filter(column => {
            return DateTime.fromISO(column.value).weekday < 6;
        });
    }

    toggleWeekendVisibility() {
        this.state.isWeekendVisible = !this.state.isWeekendVisible;
        browser.localStorage.setItem("grid.isWeekendVisible", this.state.isWeekendVisible);
    }
}

return __exports;
});
;

/*******************************************************
*  Filepath: /web_grid/static/src/views/grid_model.js  *
*  Lines: 1199                                         *
*******************************************************/
odoo.define('@web_grid/views/grid_model', ['@web/core/utils/concurrency', '@web/core/utils/hooks', '@web/core/domain', '@web/core/l10n/dates', '@web/core/l10n/localization', '@web/core/l10n/translation', '@web/model/model', '@web/core/browser/browser'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { KeepLast, Mutex } = require("@web/core/utils/concurrency");
const { useService } = require("@web/core/utils/hooks");
const { Domain } = require("@web/core/domain");
const { serializeDate } = require("@web/core/l10n/dates");
const { localization } = require("@web/core/l10n/localization");
const { _t } = require("@web/core/l10n/translation");
const { Model } = require("@web/model/model");
const { browser } = require("@web/core/browser/browser");

const { DateTime, Interval } = luxon;

const GridCell = __exports.GridCell = class GridCell {
    /**
     * Constructor
     *
     * @param dataPoint{GridDataPoint} the grid model.
     * @param row {GridRow} the grid row linked to the cell.
     * @param column {GridColumn} the grid column linked to the cell.
     * @param value {Number} the value of the cell.
     * @param isHovered {Boolean} is the cell in a hover state?
     */
    constructor(dataPoint, row, column, value = 0, isHovered = false) {
        this._dataPoint = dataPoint;
        this.row = row;
        this.column = column;
        this.model = dataPoint.model;
        this.value = value;
        this.isHovered = isHovered;
        this._readonly = false;
        this.column.addCell(this);
    }

    get readonly() {
        return this._readonly || this.column.readonly;
    }

    /**
     * Get the domain of the cell, it will be the domain of row AND the one of the column associated
     *
     * @return {Domain} the domain of the cell
     */
    get domain() {
        const domains = [this._dataPoint.searchParams.domain, this.row.domain, this.column.domain];
        return Domain.and(domains);
    }

    /**
     * Get the context to get the default values
     */
    get context() {
        return {
            ...(this.model.searchParams.context || {}),
            ...this.row.section?.context,
            ...this.row.context,
            ...this.column.context,
        };
    }

    get title() {
        const rowTitle = !this.row.section || this.row.section.isFake
            ? this.row.title
            : `${this.row.section.title} / ${this.row.title}`;
        const columnTitle = this.column.title;
        return `${rowTitle} (${columnTitle})`;
    }

    /**
     * Update the grid cell according to the value set by the current user.
     *
     * @param {Number} value the value entered by the current user.
     */
    async update(value) {
        return this.model.mutex.exec(async () => {
            await this._update(value);
        });
    }

    async _update(value) {
        const oldValue = this.value;
        const result = await this.model.orm.call(
            this.model.resModel,
            "grid_update_cell",
            [this.domain.toList({}), this.model.measureFieldName, value - oldValue],
            { context: this.context }
        );
        if (result) {
            this.model.actionService.doAction(result);
            return;
        }
        this.row.updateCell(this.column, value);
        this.model.notify();
    }
}

const GridRow = __exports.GridRow = class GridRow {
    /**
     * Constructor
     *
     * @param domain {Domain} the domain of the row.
     * @param valuePerFieldName {{string: string}} the list of to display the label of the row.
     * @param dataPoint {GridDataPoint} the grid model.
     * @param section {GridSection} the section of the grid.
     * @param columns {GridColumn[]} the columns of the grid.
     */
    constructor(domain, valuePerFieldName, dataPoint, section, isAdditionalRow = false) {
        this._domain = domain;
        this._dataPoint = dataPoint;
        this.cells = {};
        this.valuePerFieldName = valuePerFieldName;
        this.id = dataPoint.rowId++;
        this.model = dataPoint.model;
        this.section = section;
        if (section) {
            this.section.addRow(this);
        }
        this.grandTotal = 0;
        this.grandTotalWeekendHidden = 0;
        this.isAdditionalRow = isAdditionalRow;
        this._generateCells();
    }

    get initialRecordValues() {
        return this.valuePerFieldName;
    }

    get title() {
        const labelArray = [];
        for (const rowField of this._dataPoint.rowFields) {
            let title = this.valuePerFieldName[rowField.name];
            if (this.model.fieldsInfo[rowField.name].type === "many2one") {
                if (title) {
                    title = title[1];
                } else if (labelArray.length) {
                    title = "";
                } else {
                    title = "None";
                }
            }
            if (title) {
                labelArray.push(title);
            }
        }
        return labelArray.join(" / ");
    }

    get domain() {
        if (this.section.isFake) {
            return this._domain;
        }
        return Domain.and([this.section.domain, this._domain]);
    }

    get context() {
        const context = {};
        const getValue = (fieldName, value) =>
            this.model.fieldsInfo[fieldName].type === "many2one" ? value && value[0] : value;
        for (const [key, value] of Object.entries(this.valuePerFieldName)) {
            context[`default_${key}`] = getValue(key, value);
        }
        return context;
    }

    getSection() {
        return !this.section.isFake && this.section;
    }

    /**
     * Generate the cells for each column that is present in the row.
     * @private
     */
    _generateCells() {
        for (const column of this._dataPoint.columnsArray) {
            this.cells[column.id] = new this.model.constructor.Cell(
                this._dataPoint,
                this,
                column,
                0
            );
        }
    }

    _ensureColumnExist(column) {
        if (!(column.id in this._dataPoint.data.columns)) {
            throw new Error("Unbound index: the columnId is not in the row columns");
        }
        return true;
    }

    /**
     * Update the cell value of a cell.
     * @param {GridColumn} column containing the cell to update.
     * @param {number} value the value to update
     */
    updateCell(column, value) {
        this._ensureColumnExist(column);
        const cell = this.cells[column.id];
        const oldValue = cell.value;
        cell.value = value;
        const delta = value - oldValue;
        this.section.updateGrandTotal(column, delta);
        this.grandTotal += delta;
        this.grandTotalWeekendHidden += column.isWeekDay ? delta : 0;
        column.grandTotal += delta;
        if (this.isAdditionalRow && delta > 0) {
            this.isAdditionalRow = false;
        }
    }

    setReadonlyCell(column, readonly) {
        this._ensureColumnExist(column);
        if (readonly instanceof Array) {
            readonly = readonly.length > 0;
        } else if (!(readonly instanceof Boolean)) {
            readonly = Boolean(readonly);
        }
        this.cells[column.id]._readonly = readonly;
    }

    getGrandTotal(showWeekend) {
        return showWeekend ? this.grandTotal : this.grandTotalWeekendHidden;
    }
}

const GridSection = __exports.GridSection = class GridSection extends GridRow {
    constructor() {
        super(...arguments);
        this.sectionId = this._dataPoint.sectionId++;
        this.rows = {};
        this.isSection = true;
        this.lastRow = null;
    }

    get value() {
        return this.valuePerFieldName && this.valuePerFieldName[this._dataPoint.sectionField.name];
    }

    get domain() {
        let value = this.value;
        if (this.model.fieldsInfo[this._dataPoint.sectionField.name].type === "many2one") {
            value = value && value[0];
        }
        return new Domain([[this._dataPoint.sectionField.name, "=", value]]);
    }

    get title() {
        let title = this.value;
        if (
            this._dataPoint.sectionField &&
            this._dataPoint.fieldsInfo[this._dataPoint.sectionField.name].type === "many2one"
        ) {
            title = (title && title[1]) || "None";
        }
        return title;
    }

    get initialRecordValues() {
        return { [this._dataPoint.sectionField.name]: this.value };
    }

    get isFake() {
        return this.value == null;
    }

    get context() {
        const context = {};
        const getValue = (fieldName, value) =>
            this.model.fieldsInfo[fieldName].type === "many2one" ? value && value[0] : value;

        if (!this.isFake) {
            const sectionFieldName = this._dataPoint.sectionField.name;
            context[`default_${sectionFieldName}`] = getValue(sectionFieldName, this.value);
        }
        return context;
    }

    getSection() {
        return !this.isFake && this;
    }

    /**
     * Add row to the section rows.
     * @param row {GridRow} the row to add.
     */
    addRow(row) {
        if (row.id in this.rows) {
            throw new Error("Row already added in section");
        }
        this.rows[row.id] = row;
        this.lastRow = row;
    }

    /**
     * Update the grand totals according to the provided column and delta.
     * @param column {GridColumn} the column the grand total has to be updated for.
     * @param delta {Number} the delta to apply on the grand totals.
     */
    updateGrandTotal(column, delta) {
        this.cells[column.id].value += delta;
        this.grandTotal += delta;
        this.grandTotalWeekendHidden += column.isWeekDay ? delta : 0;
    }
}

const GridColumn = __exports.GridColumn = class GridColumn {
    /**
     * Constructor
     *
     * @param dataPoint {GridDataPoint} dataPoint of the grid.
     * @param title {string} the title of the column to display.
     */
    constructor(dataPoint, title, value, readonly = false) {
        this._dataPoint = dataPoint;
        this.model = dataPoint.model;
        this.title = title;
        this.value = value;
        this.cells = [];
        this.id = dataPoint.columnId++;
        this.grandTotal = 0;
        this.readonly = readonly;
    }

    /**
     * Add the cell to the column cells.
     * @param cell {GridCell} the cell to add.
     */
    addCell(cell) {
        if (cell.id in this.cells) {
            throw new Error("Cell already added in column");
        }
        this.cells.push(cell);
        this.grandTotal += cell.value;
    }

    get domain() {
        return new Domain([[this._dataPoint.columnFieldName, "=", this.value]]);
    }

    get context() {
        return { [`default_${this._dataPoint.columnFieldName}`]: this.value };
    }
}

const DateGridColumn = __exports.DateGridColumn = class DateGridColumn extends GridColumn {
    /**
     * Constructor
     *
     * @param dataPoint {GridDataPoint} data point of the grid.
     * @param title {string} the title of the column to display.
     * @param dateStart {String} the date start serialized
     * @param dateEnd {String} the date end serialized
     * @param isToday {Boolean} is the date column representing today?
     */
    constructor(dataPoint, title, dateStart, dateEnd, isToday, isWeekDay, readonly = false) {
        super(dataPoint, title, dateStart, readonly);
        this.dateEnd = dateEnd;
        this.isToday = isToday;
        this.isWeekDay = isWeekDay;
    }

    get domain() {
        return new Domain([
            "&",
            [this._dataPoint.columnFieldName, ">=", this.value],
            [this._dataPoint.columnFieldName, "<", this.dateEnd],
        ]);
    }
}

const GridDataPoint = __exports.GridDataPoint = class GridDataPoint {
    constructor(model, params) {
        this.model = model;
        const { rowFields, sectionField, searchParams } = params;
        this.rowFields = rowFields;
        this.sectionField = sectionField;
        this.searchParams = searchParams;
        this.sectionId = 0;
        this.rowId = 0;
        this.columnId = 0;
    }

    get orm() {
        return this.model.orm;
    }

    get Section() {
        return this.model.constructor.Section;
    }

    get Row() {
        return this.model.constructor.Row;
    }

    get Column() {
        return this.model.constructor.Column;
    }

    get DateColumn() {
        return this.model.constructor.DateColumn;
    }

    get Cell() {
        return this.model.constructor.Cell;
    }

    get fieldsInfo() {
        return this.model.fieldsInfo;
    }

    get columnFieldName() {
        return this.model.columnFieldName;
    }

    get resModel() {
        return this.model.resModel;
    }

    get fields() {
        return this._getFields();
    }

    get groupByFields() {
        return this._getFields(true);
    }

    get navigationInfo() {
        return this.model.navigationInfo;
    }

    get dateFormat() {
        return { day: "ccc,\nMMM\u00A0d", month: "MMMM\nyyyy" };
    }

    get columnFieldIsDate() {
        return this.model.columnFieldIsDate;
    }

    get columnGroupByFieldName() {
        let columnGroupByFieldName = this.columnFieldName;
        if (this.columnFieldIsDate) {
            columnGroupByFieldName += `:${this.navigationInfo.range.step}`;
        }
        return columnGroupByFieldName;
    }

    get readonlyField() {
        return this.model.readonlyField;
    }

    get sectionsArray() {
        return Object.values(this.data.sections);
    }

    get rowsArray() {
        return Object.values(this.data.rows);
    }

    get columnsArray() {
        return Object.values(this.data.columns);
    }

    /**
     * Get fields to use in the group by or in fields of the read_group
     * @private
     * @param grouped true to return the fields for the group by.
     * @return {string[]} list of fields name.
     */
    _getFields(grouped = false) {
        const fields = [];
        if (!grouped) {
            fields.push(
                this.columnFieldName,
                this.model.measureGroupByFieldName,
                "ids:array_agg(id)"
            );
            if (this.readonlyField) {
                const aggReadonlyField = `${this.readonlyField.name}:${this.readonlyField.aggregator}`;
                fields.push(aggReadonlyField);
            }
        } else {
            fields.push(this.columnGroupByFieldName);
        }
        fields.push(...this.rowFields.map((r) => r.name));
        if (this.sectionField) {
            fields.push(this.sectionField.name);
        }
        return fields;
    }

    _getDateColumnTitle(date) {
        if (this.navigationInfo.range.step in this.dateFormat) {
            return date.toFormat(this.dateFormat[this.navigationInfo.range.step]);
        }
        return serializeDate(date);
    }

    /**
     * Generate the date columns.
     * @private
     * @return {GridColumn[]}
     */
    _generateDateColumns() {
        const generateNext = (dateStart) =>
            dateStart.plus({ [`${this.navigationInfo.range.step}s`]: 1 });
        for (
            let currentDate = this.navigationInfo.periodStart;
            currentDate < this.navigationInfo.periodEnd;
            currentDate = generateNext(currentDate)
        ) {
            const domainStart = currentDate;
            const domainStop = generateNext(currentDate);
            const domainStartSerialized = serializeDate(domainStart);
            const isWeekDay = currentDate.weekday < 6;
            const column = new this.DateColumn(
                this,
                this._getDateColumnTitle(currentDate),
                domainStartSerialized,
                serializeDate(domainStop),
                currentDate.startOf("day").equals(this.model.today.startOf("day")),
                isWeekDay,
            );
            this.data.columns[column.id] = column;
            this.data.columnsKeyToIdMapping[domainStartSerialized] = column.id;
        }
    }

    /**
     * Search grid columns
     *
     * @param {Array} domain domain to filter the result
     * @param {string} readonlyField field uses to make column readonly if true
     * @returns {Array} array containing id, display_name and readonly if readonlyField is defined.
     */
    async _searchMany2oneColumns(domain, readonlyField) {
        const fieldsToFetch = ["id", "display_name"];
        if (readonlyField) {
            fieldsToFetch.push(readonlyField);
        }
        const columnField = this.fieldsInfo[this.columnFieldName];
        const columnRecords = await this.orm.searchRead(
            columnField.relation,
            domain || [],
            fieldsToFetch
        );
        return columnRecords.map((read) => Object.values(read));
    }

    /**
     * Initialize the data.
     * @private
     */
    async _initialiseData() {
        this.data = {
            columnsKeyToIdMapping: {},
            columns: {},
            rows: {},
            rowsKeyToIdMapping: {},
            fieldsInfo: this.fieldsInfo,
            sections: {},
            sectionsKeyToIdMapping: {},
        };
        this.record = {
            context: {},
            resModel: this.resModel,
            resIds: [],
        };
        let columnRecords = [];
        const columnField = this.fieldsInfo[this.columnFieldName];
        if (this.columnFieldIsDate) {
            this._generateDateColumns();
        } else {
            if (columnField.type === "selection") {
                const selectionFieldValues = await this.orm.call(
                    "ir.model.fields",
                    "get_field_selection",
                    [this.resModel, this.columnFieldName]
                );
                columnRecords = selectionFieldValues;
            } else if (columnField.type === "many2one") {
                columnRecords = await this._searchMany2oneColumns();
            } else {
                throw new Error(
                    "Unmanaged column type. Supported types are date, selection and many2one."
                );
            }
            for (const record of columnRecords) {
                let readonly = false;
                let key, value;
                if (record.length === 2) {
                    [key, value] = record;
                } else {
                    [key, value, readonly] = record;
                }
                const column = new this.Column(this, value, key, Boolean(readonly));
                this.data.columns[column.id] = column;
                this.data.columnsKeyToIdMapping[key] = column.id;
            }
        }
    }

    async fetchData() {
        const data = await this.orm.webReadGroup(
            this.resModel,
            Domain.and([this.searchParams.domain, this.model.generateNavigationDomain()]).toList(
                {}
            ),
            this.fields,
            this.groupByFields,
            {
                lazy: false,
            }
        );
        if (this.orm.isSample) {
            data.groups = data.groups.filter((group) => {
                const date = DateTime.fromISO(group["__range"][this.columnGroupByFieldName].from);
                return (
                    date >= this.navigationInfo.periodStart && date <= this.navigationInfo.periodEnd
                );
            });
        }
        return data;
    }

    /**
     * Gets additional groups to be added to the grid. The call to this function is made in parallel to the main data
     * fetching.
     *
     * This function is intended to be overriden in modules where we want to display additional sections and/or rows in
     * the grid than what would be returned by the webReadGroup.
     * The model `sectionField` and `rowFields` can be used in order to know what need to be returned.
     *
     * An example of this is:
     * - when considering timesheet, we want to ease their encoding by adding (to the data that is fetched for scale),
     *   the entries that have been entered the week before. That way, the first day of week
     *   (or month, depending on the scale), a line is already displayed with 0's and can directly been used in the
     *   grid instead of having to use the create button.
     *
     * @return {Array<Promise<Object>>} an array of Promise of Object of type:
     *                                      {
     *                                          sectionKey: {
     *                                              value: Any,
     *                                              rows: {
     *                                                  rowKey: {
     *                                                      domain: Domain,
     *                                                      values: [Any],
     *                                                  },
     *                                              },
     *                                          },
     *                                      }
     * @private
     */
    _fetchAdditionalData() {
        return [];
    }

    /**
     * Gets additional groups to be added to the grid. The call to this function is made after the main data fetching
     * has been processed which allows using `data` in the code.
     * This function is intended to be overriden in modules where we want to display additional sections and/or rows in
     * the grid than what would be returned by the webReadGroup.
     * The model `sectionField`, `rowFields` as well as `data` can be used in order to know what need to be returned.
     *
     * @return {Array<Promise<Object>>} an array of Promise of Object of type:
     *                                      {
     *                                          sectionKey: {
     *                                              value: Any,
     *                                              rows: {
     *                                                  rowKey: {
     *                                                      domain: Domain,
     *                                                      values: [Any],
     *                                                  },
     *                                              },
     *                                          },
     *                                      }
     * @private
     */
    _postFetchAdditionalData() {
        return [];
    }

    _getAdditionalPromises() {
        return [this._fetchUnavailabilityDays()];
    }

    async _fetchUnavailabilityDays(args = {}) {
        if (!this.columnFieldIsDate) {
            return {};
        }
        const result = await this.orm.call(
            this.resModel,
            "grid_unavailability",
            [
                serializeDate(this.navigationInfo.periodStart),
                serializeDate(this.navigationInfo.periodEnd),
            ],
            {
                ...args,
            }
        );
        this._processUnavailabilityDays(result);
    }

    _processUnavailabilityDays(result) {
        return;
    }

    /**
     * Generate the row key according to the provided read group result.
     * @param readGroupResult {Array} the read group result the key has to be generated for.
     * @private
     * @return {string}
     */
    _generateRowKey(readGroupResult) {
        let key = "";
        const sectionKey =
            (this.sectionField && this._generateSectionKey(readGroupResult)) || false;
        for (const rowField of this.rowFields) {
            let value = rowField.name in readGroupResult && readGroupResult[rowField.name];
            if (this.fieldsInfo[rowField.name].type === "many2one") {
                value = value && value[0];
            }
            key += `${value}\\|/`;
        }
        return `${sectionKey}@|@${key}`;
    }

    /**
     * Generate the section
     * @param readGroupResult
     * @private
     */
    _generateSectionKey(readGroupResult) {
        let value = readGroupResult[this.sectionField.name];
        if (this.fieldsInfo[this.sectionField.name].type === "many2one") {
            value = value && value[0];
        }
        return `/|\\${value.toString()}`;
    }

    /**
     * Generate the row domain for the provided read group result.
     * @param readGroupResult {Array} the read group result the domain has to be generated for.
     * @return {{domain: Domain, values: Object}} the generated domain and values.
     */
    _generateRowDomainAndValues(readGroupResult) {
        let domain = new Domain();
        const values = {};
        for (const rowField of this.rowFields) {
            const result = rowField.name in readGroupResult && readGroupResult[rowField.name];
            let value = result;
            if (this.fieldsInfo[rowField.name].type === "many2one") {
                value = value && value[0];
            }
            values[rowField.name] = result;
            domain = Domain.and([domain, [[rowField.name, "=", value]]]);
        }
        return { domain, values };
    }

    _generateFakeSection() {
        const section = new this.Section(null, null, this, null);
        this.data.sections[section.id] = section;
        this.data.sectionsKeyToIdMapping["false"] = section.id;
        this.data.rows[section.id] = section;
        this.data.rowsKeyToIdMapping["false"] = section.id;
        return section;
    }

    async _generateData(readGroupResults) {
        let section;
        for (const readGroupResult of readGroupResults.groups) {
            if (!this.orm.isSample) {
                this.record.resIds.push(...readGroupResult.ids);
            }
            const rowKey = this._generateRowKey(readGroupResult);
            if (this.sectionField) {
                const sectionKey = this._generateSectionKey(readGroupResult);
                if (!(sectionKey in this.data.sectionsKeyToIdMapping)) {
                    const newSection = new this.Section(
                        null,
                        { [this.sectionField.name]: readGroupResult[this.sectionField.name] },
                        this,
                        null
                    );
                    this.data.sections[newSection.id] = newSection;
                    this.data.sectionsKeyToIdMapping[sectionKey] = newSection.id;
                    this.data.rows[newSection.id] = newSection;
                    this.data.rowsKeyToIdMapping[sectionKey] = newSection.id;
                }
                section = this.data.sections[this.data.sectionsKeyToIdMapping[sectionKey]];
            } else if (Object.keys(this.data.sections).length === 0) {
                section = this._generateFakeSection();
            }
            let row;
            if (!(rowKey in this.data.rowsKeyToIdMapping)) {
                const { domain, values } = this._generateRowDomainAndValues(readGroupResult);
                row = new this.Row(domain, values, this, section);
                this.data.rows[row.id] = row;
                this.data.rowsKeyToIdMapping[rowKey] = row.id;
            } else {
                row = this.data.rows[this.data.rowsKeyToIdMapping[rowKey]];
            }
            let columnKey;
            if (this.columnFieldIsDate) {
                columnKey = readGroupResult["__range"][this.columnGroupByFieldName].from;
            } else {
                const columnField = this.fieldsInfo[this.columnFieldName];
                if (columnField.type === "selection") {
                    columnKey = readGroupResult[this.columnFieldName];
                } else if (columnField.type === "many2one") {
                    columnKey = readGroupResult[this.columnFieldName][0];
                } else {
                    throw new Error(
                        "Unmanaged column type. Supported types are date, selection and many2one."
                    );
                }
            }
            if (this.data.columnsKeyToIdMapping[columnKey] in this.data.columns) {
                const column = this.data.columns[this.data.columnsKeyToIdMapping[columnKey]];
                row.updateCell(column, readGroupResult[this.model.measureFieldName]);
                if (this.readonlyField && this.readonlyField.name in readGroupResult) {
                    row.setReadonlyCell(column, readGroupResult[this.readonlyField.name]);
                }
            }
        }
    }

    /**
     * Method meant to be overridden whenever an item (row and section) post process is needed.
     * @param item {GridSection|GridRow}
     */
    _itemsPostProcess(item) {}

    async load() {
        await this._initialiseData();

        const mergeAdditionalData = (fetchedData) => {
            const additionalData = {};
            for (const data of fetchedData) {
                for (const [sectionKey, sectionInfo] of Object.entries(data)) {
                    if (!(sectionKey in additionalData)) {
                        additionalData[sectionKey] = sectionInfo;
                    } else {
                        for (const [rowKey, rowInfo] of Object.entries(sectionInfo.rows)) {
                            if (!(rowKey in additionalData[sectionKey].rows)) {
                                additionalData[sectionKey].rows[rowKey] = rowInfo;
                            }
                        }
                    }
                }
            }
            return additionalData;
        };

        const appendAdditionData = (additionalData) => {
            for (const [sectionKey, sectionInfo] of Object.entries(additionalData)) {
                if (!(sectionKey in this.data.sectionsKeyToIdMapping)) {
                    if (this.sectionField) {
                        const newSection = new this.Section(
                            null,
                            { [this.sectionField.name]: sectionInfo.value },
                            this,
                            null
                        );
                        this.data.sections[newSection.id] = newSection;
                        this.data.sectionsKeyToIdMapping[sectionKey] = newSection.id;
                        this.data.rows[newSection.id] = newSection;
                        this.data.rowsKeyToIdMapping[sectionKey] = newSection.id;
                    } else {
                        // if no sectionField and the section is not in sectionsKeyToIdMapping then no section is generated
                        this._generateFakeSection();
                    }
                }
                const section = this.data.sections[this.data.sectionsKeyToIdMapping[sectionKey]];
                for (const [rowKey, rowInfo] of Object.entries(sectionInfo.rows)) {
                    if (!(rowKey in this.data.rowsKeyToIdMapping)) {
                        const newRow = new this.Row(
                            rowInfo.domain,
                            rowInfo.values,
                            this,
                            section,
                            true
                        );
                        this.data.rows[newRow.id] = newRow;
                        this.data.rowsKeyToIdMapping[rowKey] = newRow.id;
                        for (const column of Object.values(this.data.columns)) {
                            newRow.updateCell(column, 0);
                        }
                    }
                }
            }
        };

        const [data, additionalData] = await Promise.all([
            this.fetchData(),
            Promise.all(this._fetchAdditionalData()),
        ]);
        this._generateData(data);
        appendAdditionData(mergeAdditionalData(additionalData));
        if (!this.orm.isSample) {
            const [, postFetchAdditionalData] = await Promise.all([
                Promise.all(this._getAdditionalPromises()),
                Promise.all(this._postFetchAdditionalData()),
            ]);
            appendAdditionData(mergeAdditionalData(postFetchAdditionalData));
        }

        this.data.items = [];
        for (const section of this.sectionsArray) {
            this.data.items.push(section);
            this._itemsPostProcess(section);
            for (const rowId in section.rows) {
                const row = section.rows[rowId];
                this._itemsPostProcess(row);
                this.data.items.push(row);
            }
        }
    }
}

const GridNavigationInfo = __exports.GridNavigationInfo = class GridNavigationInfo {
    constructor(anchor, model) {
        this.anchor = anchor;
        this.model = model;
    }

    get _targetWeekday() {
        const firstDayOfWeek = localization.weekStart;
        return this.anchor.weekday < firstDayOfWeek ? firstDayOfWeek - 7 : firstDayOfWeek;
    }

    get periodStart() {
        if (this.range.span !== "week") {
            return this.anchor.startOf(this.range.span);
        }
        // Luxon's default is monday to monday week so we need to change its behavior.
        return this.anchor.set({ weekday: this._targetWeekday }).startOf("day");
    }

    get periodEnd() {
        if (this.range.span !== "week") {
            return this.anchor.endOf(this.range.span);
        }
        // Luxon's default is monday to monday week so we need to change its behavior.
        return this.anchor
            .set({ weekday: this._targetWeekday })
            .plus({ weeks: 1, days: -1 })
            .endOf("day");
    }

    get interval() {
        return Interval.fromDateTimes(this.periodStart, this.periodEnd);
    }

    contains(date) {
        return this.interval.contains(date.startOf("day"));
    }
}

const GridModel = __exports.GridModel = class GridModel extends Model {
    static DataPoint = GridDataPoint;
    static Cell = GridCell;
    static Column = GridColumn;
    static DateColumn = DateGridColumn;
    static Row = GridRow;
    static Section = GridSection;
    static NavigationInfo = GridNavigationInfo;

    setup(params) {
        this.notificationService = useService("notification");
        this.actionService = useService("action");
        this.keepLast = new KeepLast();
        this.mutex = new Mutex();
        this.defaultSectionField = params.sectionField;
        this.defaultRowFields = params.rowFields;
        this.resModel = params.resModel;
        this.fieldsInfo = params.fieldsInfo;
        this.columnFieldName = params.columnFieldName;
        this.columnFieldIsDate = this.fieldsInfo[params.columnFieldName].type === "date";
        this.measureField = params.measureField;
        this.readonlyField = params.readonlyField;
        this.ranges = params.ranges;
        this.defaultAnchor = params.defaultAnchor || this.today;
        this.navigationInfo = new this.constructor.NavigationInfo(this.defaultAnchor, this);
        const activeRangeName =
            browser.localStorage.getItem(this.storageKey) || params.activeRangeName;
        if (Object.keys(this.ranges).length && activeRangeName) {
            this.navigationInfo.range = this.ranges[activeRangeName];
        }
    }

    get data() {
        return this._dataPoint?.data || {};
    }

    get record() {
        return this._dataPoint?.record || {};
    }

    get today() {
        return DateTime.local().startOf("day");
    }

    get sectionsArray() {
        return Object.values(this.data.sections);
    }

    get itemsArray() {
        return this.data.items;
    }

    get columnsArray() {
        return Object.values(this.data.columns);
    }

    get maxColumnsTotal() {
        return Math.max(...this.columnsArray.map((c) => c.grandTotal));
    }

    get measureFieldName() {
        return this.measureField.name;
    }

    get measureGroupByFieldName() {
        if (this.measureField.aggregator) {
            return `${this.measureFieldName}:${this.measureField.aggregator}`;
        }
        return this.measureFieldName;
    }

    get storageKey() {
        return `scaleOf-viewId-${this.env.config.viewId}`;
    }

    isToday(date) {
        return date.startOf("day").equals(this.today.startOf("day"));
    }

    /**
     * Set the new range according to the range name passed into parameter.
     * @param rangeName {string} the range name to set.
     */
    async setRange(rangeName) {
        this.navigationInfo.range = this.ranges[rangeName];
        browser.localStorage.setItem(this.storageKey, rangeName);
        await this.fetchData();
    }

    async setAnchor(anchor) {
        this.navigationInfo.anchor = anchor;
        await this.fetchData();
    }

    async setTodayAnchor() {
        await this.setAnchor(this.today);
    }

    /**
     * @override
     */
    hasData() {
        return this.sectionsArray.length;
    }

    generateNavigationDomain() {
        if (this.columnFieldIsDate) {
            return new Domain([
                "&",
                [this.columnFieldName, ">=", serializeDate(this.navigationInfo.periodStart)],
                [this.columnFieldName, "<=", serializeDate(this.navigationInfo.periodEnd)],
            ]);
        } else {
            return Domain.TRUE;
        }
    }

    /**
     * Reset the anchor
     */
    async resetAnchor() {
        await this.setAnchor(this.defaultAnchor);
    }

    /**
     * Move the anchor to the next/previous step
     * @param direction {"forward"|"backward"} the direction to the move the anchor
     */
    async moveAnchor(direction) {
        if (direction == "forward") {
            this.navigationInfo.anchor = this.navigationInfo.anchor.plus({
                [this.navigationInfo.range.span]: 1,
            });
        } else if (direction == "backward") {
            this.navigationInfo.anchor = this.navigationInfo.anchor.minus({
                [this.navigationInfo.range.span]: 1,
            });
        } else {
            throw Error("Invalid argument");
        }
        if (
            this.navigationInfo.contains(this.today) &&
            this.navigationInfo.anchor.startOf("day").equals(this.today.startOf("day"))
        ) {
            this.navigationInfo.anchor = this.today;
        }
        await this.fetchData();
    }

    /**
     * Load the model
     *
     * @override
     * @param params {Object} the search parameters (domain, groupBy, etc.)
     * @return {Promise<void>}
     */
    async load(params = {}) {
        const searchParams = {
            ...this.searchParams,
            ...params,
        };
        const groupBys = [];
        let notificationDisplayed = false;
        for (const groupBy of searchParams.groupBy) {
            if (groupBy.startsWith(this.columnFieldName)) {
                if (!notificationDisplayed) {
                    this.notificationService.add(
                        _t(
                            "Grouping by the field used in the column of the grid view is not possible."
                        ),
                        { type: "warning" }
                    );
                    notificationDisplayed = true;
                }
            } else {
                groupBys.push(groupBy);
            }
        }
        if (searchParams.length !== groupBys.length) {
            searchParams.groupBy = groupBys;
        }
        let rowFields = [];
        let sectionField;
        if (searchParams.groupBy.length) {
            if (
                this.defaultSectionField &&
                searchParams.groupBy.length > 1 &&
                searchParams.groupBy[0] === this.defaultSectionField.name
            ) {
                sectionField = this.defaultSectionField;
            }
            const rowFieldPerFieldName = Object.fromEntries(
                this.defaultRowFields.map((r) => [r.name, r])
            );
            for (const groupBy of searchParams.groupBy) {
                if (sectionField && groupBy === sectionField.name) {
                    continue;
                }
                if (groupBy in rowFieldPerFieldName) {
                    rowFields.push({
                        ...rowFieldPerFieldName[groupBy],
                        invisible: "False",
                    });
                } else {
                    rowFields.push({ name: groupBy });
                }
            }
        } else {
            if (this.defaultSectionField && (this.defaultSectionField.invisible !== "True" && this.defaultSectionField.invisible !== "1")) {
                sectionField = this.defaultSectionField;
            }
            rowFields = this.defaultRowFields.filter((r) => (r.invisible !== "True" && r.invisible !== "1"));
        }

        const dataPoint = new this.constructor.DataPoint(this, {
            searchParams,
            rowFields,
            sectionField,
        });
        await this.keepLast.add(dataPoint.load());
        this._dataPoint = dataPoint;

        this.searchParams = searchParams;
        this.rowFields = rowFields;
        this.sectionField = sectionField;
    }

    async fetchData(params = {}) {
        await this.load(params);
        this.useSampleModel = false;
        this.notify();
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_grid/static/src/views/grid_renderer.js  *
*  Lines: 650                                             *
**********************************************************/
odoo.define('@web_grid/views/grid_renderer', ['@web/core/l10n/translation', '@web/core/domain', '@web/core/registry', '@web/core/utils/hooks', '@web/core/utils/strings', '@web/core/utils/timing', '@web/core/virtual_grid_hook', '@web/views/fields/field', '@web/model/record', '@web/core/hotkeys/hotkey_service', '@web/views/view_components/view_scale_selector', '@web_grid/components/grid_component/grid_component', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { Domain } = require("@web/core/domain");
const { registry } = require("@web/core/registry");
const { useService } = require("@web/core/utils/hooks");
const { escape } = require("@web/core/utils/strings");
const { useDebounced } = require("@web/core/utils/timing");
const { useVirtualGrid } = require("@web/core/virtual_grid_hook");
const { Field } = require("@web/views/fields/field");
const { Record } = require("@web/model/record");
const { getActiveHotkey } = require("@web/core/hotkeys/hotkey_service");
const { ViewScaleSelector } = require("@web/views/view_components/view_scale_selector");

const { GridComponent } = require("@web_grid/components/grid_component/grid_component");

const {
    Component,
    markup,
    useState,
    onWillUpdateProps,
    onMounted,
    onPatched,
    reactive,
    useRef,
    useExternalListener,
} = require("@odoo/owl");

const GridRenderer = __exports.GridRenderer = class GridRenderer extends Component {
    static components = {
        Field,
        GridComponent,
        Record,
        ViewScaleSelector,
    };

    static template = "web_grid.Renderer";

    static props = {
        sections: { type: Array, optional: true },
        columns: { type: Array, optional: true },
        rows: { type: Array, optional: true },
        model: { type: Object, optional: true },
        options: Object,
        sectionField: { type: Object, optional: true },
        rowFields: Array,
        measureField: Object,
        isEditable: Boolean,
        widgetPerFieldName: Object,
        openAction: { type: Object, optional: true },
        contentRef: Object,
        createInline: Boolean,
        createRecord: Function,
        ranges: { type: Object, optional: true },
        state: Object,
        toggleWeekendVisibility: Function,
    };

    static defaultProps = {
        sections: [],
        columns: [],
        rows: [],
        model: {},
        ranges: {},
    };

    setup() {
        this.rendererRef = useRef("renderer");
        this.actionService = useService("action");
        this.editionState = useState({
            hoveredCellInfo: false,
            editedCellInfo: false,
        });
        this.hoveredElement = null;
        const measureFieldName = this.props.model.measureFieldName;
        const fieldInfo = this.props.model.fieldsInfo[measureFieldName];
        const measureFieldWidget = this.props.widgetPerFieldName[measureFieldName];
        const widgetName = measureFieldWidget || fieldInfo.type;
        this.gridCell = registry.category("grid_components").get(widgetName);
        this.hoveredCellProps = {
            // props cell hovered
            name: measureFieldName,
            type: widgetName,
            component: this.gridCell.component,
            reactive: reactive({ cell: null }),
            fieldInfo,
            readonly: !this.props.isEditable,
            openRecords: this.openRecords.bind(this),
            editMode: false,
            onEdit: this.onEditCell.bind(this),
            getCell: this.getCell.bind(this),
            isMeasure: true,
        };
        this.editCellProps = {
            // props for cell in edit mode
            name: measureFieldName,
            type: widgetName,
            component: this.gridCell.component,
            reactive: reactive({ cell: null }),
            fieldInfo,
            readonly: !this.props.isEditable,
            openRecords: this.openRecords.bind(this),
            editMode: true,
            onEdit: this.onEditCell.bind(this),
            getCell: this.getCell.bind(this),
            onKeyDown: this.onCellKeydown.bind(this),
            isMeasure: true,
        };
        this.isEditing = false;
        onWillUpdateProps(this.onWillUpdateProps);
        onMounted(this._focusOnToday);
        onPatched(this._focusOnToday);
        // This property is used to avoid refocus on today whenever a cell value is updated.
        this.shouldFocusOnToday = true;
        this.onMouseOver = useDebounced(this._onMouseOver, 10);
        this.onMouseOut = useDebounced(this._onMouseOut, 10);
        this.virtualGrid = useVirtualGrid({
            scrollableRef: this.props.contentRef,
            initialScroll: { top: 60 },
        });
        useExternalListener(window, "click", this.onClick);
        useExternalListener(window, "keydown", this.onKeyDown);
    }

    getCell(rowId, columnId) {
        return this.props.model.data.rows[rowId]?.cells[columnId];
    }

    getItemHeight(item) {
        let height = this.rowHeight;
        if (item.isSection && item.isFake) {
            return 0;
        }
        if (this.props.createInline && !item.isSection && item.section.lastRow.id === item.id) {
            height *= 2; // to include the Add a line row
        }
        return height;
    }

    get isMobile() {
        return this.env.isSmall;
    }

    get rowHeight() {
        const baseHeight = this.isMobile ? 48 : 32;
        /*
         * On mobile devices, grouped by fields are stacked vertically.
         * By default, the base height accommodates up to 2 fields.
         * For each additional field beyond the first 2, we add 20px to maintain proper spacing.
         */
        const extraHeight = this.isMobile
            ? Math.max(0, this.props.model.rowFields.length - 2) * 20
            : 0;
        return baseHeight + extraHeight;
    }

    get virtualRows() {
        this.virtualGrid.setRowsHeights(this.props.rows.map((row) => this.getItemHeight(row)));
        const [start, end] = this.virtualGrid.rowsIndexes;
        return this.props.rows.slice(start, end + 1);
    }

    getRowPosition(row, isCreateInlineRow = false) {
        const rowIndex = row ? this.props.rows.findIndex((r) => r.id === row.id) : 0;
        const section = row && row.getSection();
        const sectionDisplayed = Boolean(section && (section.value || this.props.sections.length > 1));
        let rowPosition = this.rowsGap + rowIndex + 1 + (sectionDisplayed ? section.sectionId : 0);
        if (isCreateInlineRow) {
            rowPosition += 1;
        }
        if (!sectionDisplayed) {
            rowPosition -= 1;
        }
        return rowPosition;
    }

    getTotalRowPosition() {
        let sectionIndex = 0;
        if (this.props.model.sectionField && this.props.sections.length) {
            if (this.props.sections.length > 1 || this.props.sections[0].value) {
                sectionIndex = this.props.sections.length;
            }
        }
        return (
            (this.props.rows.length || 1) +
            sectionIndex +
            (this.props.createInline ? 1 : 0) +
            this.rowsGap
        );
    }

    onWillUpdateProps(nextProps) {}

    formatValue(value) {
        return this.gridCell.formatter(value);
    }

    /**
     * @deprecated
     * TODO: [XBO] remove me in master
     * @param {*} data
     */
    getDefaultState(data) {
        return {};
    }

    get rowsCount() {
        const addLineRows = this.props.createInline ? this.props.sections.length || 1 : 0;
        return this.props.rows.length - (this.props.model.sectionField ? 0 : 1) + addLineRows;
    }

    get gridTemplateRows() {
        let totalRows = 0;
        if (!this.props.options.hideColumnTotal) {
            totalRows += 1;
            if (this.props.options.hasBarChartTotal) {
                totalRows += 1;
            }
        }
        // Row height must be hard-coded for the virtual hook to work properly.
        return `auto repeat(${this.rowsCount + totalRows}, ${this.rowHeight}px)`;
    }

    get gridTemplateColumns() {
        return `auto repeat(${this.props.columns.length}, ${
            this.props.columns.length > 7 ? "minmax(8ch, auto)" : "minmax(10ch, 1fr)"
        }) minmax(10ch, 10em)`;
    }

    get measureLabel() {
        const measureFieldName = this.props.model.measureFieldName;
        if (measureFieldName === "__count") {
            return _t("Total");
        }
        return (
            this.props.measureField.string || this.props.model.fieldsInfo[measureFieldName].string
        );
    }

    get rowsGap() {
        return 1;
    }

    get columnsGap() {
        return 1;
    }

    get displayAddLine() {
        return this.props.createInline && this.row.id === this.row.section.lastRow.id;
    }

    getCellColorClass(column) {
        return "text-900";
    }

    getSectionColumnsClasses(column, row) {
        const isToday = column.isToday;
        return {
            'bg-info bg-opacity-50': isToday,
            'bg-200 border-top': !isToday,
            'bg-opacity-75': this.getUnavailableClass(column) === 'o_grid_unavailable' && row.cells[column.id].value === 0,
        }
    }

    getSectionCellsClasses(column, row) {
        return {
            'text-opacity-25' : row.cells[column.id].value === 0 || this.getUnavailableClass(column) === 'o_grid_unavailable',
        };
    }

    isTextDanger() {
        return false;
    }

    getTextColorClasses(column, row, isEven) {
        const value = row.cells[column.id].value;
        const isTextDanger = this.isTextDanger(row, column);
        return {
            'text-bg-view': isEven && value >= 0 && !isTextDanger,
            'text-900': !isEven && value >= 0 && !isTextDanger,
            'text-danger': value < 0 || isTextDanger,
        }
    }

    getCellsClasses(column, row, section, isEven) {
        return {
            ...this.getTextColorClasses(column, row, isEven),
            'o_grid_cell_today': column.isToday,
            'fst-italic': row.isAdditionalRow,
        };
    }

    _getSectionTotalCellBgColor(section) {
        return 'text-bg-800';
    }

    getSectionTotalRowClass(section, grandTotal) {
        return {
            [this._getSectionTotalCellBgColor(section)]: true,
            'text-opacity-25': grandTotal === 0,
        };
    }

    getColumnBarChartHeightStyle(column) {
        let heightPercentage = 0;
        if (this.props.model.maxColumnsTotal !== 0) {
            heightPercentage = (column.grandTotal / this.props.model.maxColumnsTotal) * 100;
        }
        return `height: ${heightPercentage}%; bottom: 0;`;
    }

    getFooterTotalCellClasses(grandTotal) {
        if (grandTotal < 0) {
            return "bg-danger text-bg-danger";
        }

        return "bg-400";
    }

    getUnavailableClass(column, section = undefined) {
        return "";
    }

    getFieldAdditionalProps(fieldName) {
        return {
            name: fieldName,
            type: this.props.widgetPerFieldName[fieldName] || this.props.model.fieldsInfo[fieldName].type,
        };
    }

    onCreateInlineClick(section) {
        const context = {
            ...(section?.context || {}),
        };
        const title = _t("Add a Line");
        this.props.createRecord({ context, title });
    }

    _focusOnToday() {
        if (!this.shouldFocusOnToday) {
            return;
        }
        this.shouldFocusOnToday = false;
        const { navigationInfo, columnFieldIsDate } = this.props.model;
        if (this.isMobile || !columnFieldIsDate || navigationInfo.range.name != "month"){
            return;
        }
        const rendererEl = this.rendererRef.el;
        const todayEl = rendererEl.querySelector("div.o_grid_column_title.fw-bolder");
        if (todayEl) {
            rendererEl.parentElement.scrollLeft = todayEl.offsetLeft - rendererEl.offsetWidth / 2 + todayEl.offsetWidth / 2;
        }
    }

    _onMouseOver(ev) {
        if (this.hoveredElement || ev.fromElement?.classList.contains("dropdown-item")) {
            // As mouseout is call prior to mouseover, if hoveredElement is set this means
            // that we haven't left it. So it's a mouseover inside it.
            return;
        }
        const highlightableElement = ev.target.closest(".o_grid_highlightable");
        if (!highlightableElement) {
            // We are not in an element that should trigger a highlight.
            return;
        }
        const { column, gridRow, gridColumn, row } = highlightableElement.dataset;
        const isCellInColumnTotalHighlighted =
            highlightableElement.classList.contains("o_grid_row_total");
        const elementsToHighlight = this.rendererRef.el.querySelectorAll(
            `.o_grid_highlightable[data-grid-row="${gridRow}"]:not(.o_grid_add_line):not(.o_grid_column_title), .o_grid_highlightable[data-grid-column="${gridColumn}"]:not(.o_grid_row_timer):not(.o_grid_section_title):not(.o_grid_row_title${
                isCellInColumnTotalHighlighted ? ",.o_grid_row_total" : ""
            })`
        );
        for (const node of elementsToHighlight) {
            if (node.classList.contains("o_grid_bar_chart_container")) {
                node.classList.add("o_grid_highlighted");
            }
            if (node.dataset.gridRow === gridRow) {
                node.classList.add("o_grid_highlighted");
                if (node.dataset.gridColumn === gridColumn) {
                    node.classList.add("o_grid_cell_highlighted");
                } else {
                    node.classList.add("o_grid_row_highlighted");
                }
            }
        }
        this.hoveredElement = highlightableElement;
        const cell = this.editCellProps.reactive.cell;
        if (
            row &&
            column &&
            !(cell && cell.dataset.row === row && cell.dataset.column === column)
        ) {
            this.hoveredCellProps.reactive.cell = highlightableElement;
        }
    }

    /**
     * Mouse out handler
     *
     * @param {MouseEvent} ev
     */
    _onMouseOut(ev) {
        if (!this.hoveredElement) {
            // If hoveredElement is not set this means were not in a o_grid_highlightable. So ignore it.
            return;
        }
        /** @type {HTMLElement | null} */
        let relatedTarget = ev.relatedTarget;
        const gridCell = relatedTarget?.closest(".o_grid_cell");
        if (
            gridCell &&
            gridCell.dataset.gridRow === this.hoveredElement.dataset.gridRow &&
            gridCell.dataset.gridColumn === this.hoveredElement.dataset.gridColumn &&
            gridCell !== this.editCellProps.reactive.cell
        ) {
            return;
        }
        while (relatedTarget) {
            // Go up the parent chain
            if (relatedTarget === this.hoveredElement) {
                // Check that we are still inside hoveredConnector.
                // If so it means it is a transition between child elements so ignore it.
                return;
            }
            relatedTarget = relatedTarget.parentElement;
        }
        const { gridRow, gridColumn } = this.hoveredElement.dataset;
        const elementsHighlighted = this.rendererRef.el.querySelectorAll(
            `.o_grid_highlightable[data-grid-row="${gridRow}"], .o_grid_highlightable[data-grid-column="${gridColumn}"]`
        );
        for (const node of elementsHighlighted) {
            node.classList.remove(
                "o_grid_highlighted",
                "o_grid_row_highlighted",
                "o_grid_cell_highlighted"
            );
        }
        this.hoveredElement = null;
        if (this.hoveredCellProps.reactive.cell) {
            this.hoveredCellProps.reactive.cell
                .querySelector(".o_grid_cell_readonly")
                .classList.remove("d-none");
            this.hoveredCellProps.reactive.cell = null;
        }
    }

    onEditCell(value) {
        if (this.editCellProps.reactive.cell) {
            this.editCellProps.reactive.cell
                .querySelector(".o_grid_cell_readonly")
                .classList.remove("d-none");
        }
        if (value) {
            this.editCellProps.reactive.cell = this.hoveredCellProps.reactive.cell;
            this.hoveredCellProps.reactive.cell = null;
        } else {
            this.editCellProps.reactive.cell = null;
        }
    }

    _onKeyDown(ev) {
        const hotkey = getActiveHotkey(ev);
        if (hotkey === "escape" && this.editCellProps.reactive.cell) {
            this.onEditCell(false);
        }
    }

    /**
     * Handle click on any element in the grid
     *
     * @param {MouseEvent} ev
     */
    onClick(ev) {
        if (
            !this.editCellProps.reactive.cell ||
            ev.target.closest(".o_grid_highlighted") ||
            ev.target.closest(".o_grid_cell")
        ) {
            return;
        }
        this.onEditCell(false);
    }

    onKeyDown(ev) {
        this._onKeyDown(ev);
    }

    /**
     * Handle the click on a cell in mobile
     *
     * @param {MouseEvent} ev
     */
    onCellClick(ev) {
        ev.stopPropagation();
        const cell = ev.target.closest(".o_grid_highlightable");
        const { row, column } = cell.dataset;
        if (row && column) {
            if (this.editCellProps.reactive.cell) {
                this.editCellProps.reactive.cell
                    .querySelector(".o_grid_cell_readonly")
                    .classList.remove("d-none");
            }
            this.editCellProps.reactive.cell = cell;
        }
    }

    /**
     * Handle keydown when cell is edited in the grid view.
     *
     * @param {KeyboardEvent} ev
     * @param {import("./grid_model").GridCell | null} cell
     */
    onCellKeydown(ev, cell) {
        const hotkey = getActiveHotkey(ev);
        if (!this.rendererRef.el || !cell || !["tab", "shift+tab", "enter"].includes(hotkey)) {
            this._onKeyDown(ev);
            return;
        }
        // Purpose: prevent browser defaults
        ev.preventDefault();
        // Purpose: stop other window keydown listeners (e.g. home menu)
        ev.stopImmediatePropagation();
        let rowId = cell.row.id;
        let columnId = cell.column.id;
        const columnIds = this.props.columns.map((c) => c.id);
        const rowIds = [];
        for (const item of this.props.rows) {
            if (!item.isSection) {
                rowIds.push(item.id);
            }
        }
        let columnIndex = columnIds.indexOf(columnId);
        let rowIndex = rowIds.indexOf(rowId);
        if (hotkey === "tab") {
            columnIndex += 1;
            rowIndex += 1;
            if (columnIndex < columnIds.length) {
                columnId = columnIds[columnIndex];
            } else {
                columnId = columnIds[0];
                if (rowIndex < rowIds.length) {
                    rowId = rowIds[rowIndex];
                } else {
                    rowId = rowIds[0];
                }
            }
        } else if (hotkey === "shift+tab") {
            columnIndex -= 1;
            rowIndex -= 1;
            if (columnIndex >= 0) {
                columnId = columnIds[columnIndex];
            } else {
                columnId = columnIds[columnIds.length - 1];
                if (rowIndex >= 0) {
                    rowId = rowIds[rowIndex];
                } else {
                    rowId = rowIds[rowIds.length - 1];
                }
            }
        } else if (hotkey === "enter") {
            rowIndex += 1;
            if (rowIndex >= rowIds.length) {
                columnIndex = (columnIndex + 1) % columnIds.length;
                columnId = columnIds[columnIndex];
            }
            rowIndex = rowIndex % rowIds.length;
            rowId = rowIds[rowIndex];
        }
        this.onEditCell(false);
        this.hoveredCellProps.reactive.cell = this.rendererRef.el.querySelector(
            `.o_grid_highlightable[data-row="${rowId}"][data-column="${columnId}"]`
        );
        this.onEditCell(true);
    }

    async openRecords(actionTitle, domain, context) {
        const resModel = this.props.model.resModel;
        if (this.props.openAction) {
            const resIds = await this.props.model.orm.search(resModel, domain);
            this.actionService.doActionButton({
                ...this.props.openAction,
                resModel,
                resIds,
                context,
            });
        } else {
            // retrieve form and list view ids from the action
            const { views = [] } = this.env.config;
            const openRecordsViews = ["list", "form"].map((viewType) => {
                const view = views.find((view) => view[1] === viewType);
                return [view ? view[0] : false, viewType];
            });
            this.actionService.doAction({
                type: "ir.actions.act_window",
                name: actionTitle,
                res_model: resModel,
                views: openRecordsViews,
                domain,
                context,
                help: this._getNoContentHelper(),
            });
        }
    }

    /** Return grid cell action helper when no records are found. */
    _getNoContentHelper() {
        const noActivitiesFound = _t("No activities found");
        return  markup(
            `<p class='o_view_nocontent_smiling_face'>${escape(noActivitiesFound)}</p>`
        );
    }

    onMagnifierGlassClick(section, column) {
        const title = `${section.title} (${column.title})`;
        const domain = Domain.and([section.domain, column.domain]).toList();
        this.openRecords(title, domain, section.context);
    }

    get rangesArray() {
        return Object.values(this.props.ranges);
    }

    async onRangeClick(name) {
        await this.props.model.setRange(name);
        this.props.state.activeRangeName = name;
        this.shouldFocusOnToday = true;
    }

    async onTodayButtonClick() {
        await this.props.model.setTodayAnchor();
        this.shouldFocusOnToday = true;
    }

    async onPreviousButtonClick() {
        await this.props.model.moveAnchor("backward");
        this.shouldFocusOnToday = true;
    }

    async onNextButtonClick() {
        await this.props.model.moveAnchor("forward");
        this.shouldFocusOnToday = true;
    }
}

return __exports;
});
;

/******************************************************
*  Filepath: /web_grid/static/src/views/grid_view.js  *
*  Lines: 34                                          *
******************************************************/
odoo.define('@web_grid/views/grid_view', ['@web/core/registry', '@web_grid/views/grid_arch_parser', '@web_grid/views/grid_controller', '@web_grid/views/grid_model', '@web_grid/views/grid_renderer'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { GridArchParser } = require("@web_grid/views/grid_arch_parser");
const { GridController } = require("@web_grid/views/grid_controller");
const { GridModel } = require("@web_grid/views/grid_model");
const { GridRenderer } = require("@web_grid/views/grid_renderer");

const gridView = __exports.gridView = {
    type: "grid",
    ArchParser: GridArchParser,
    Controller: GridController,
    Model: GridModel,
    Renderer: GridRenderer,
    buttonTemplate: "web_grid.Buttons",

    props: (genericProps, view) => {
        const { ArchParser, Model, Renderer, buttonTemplate: viewButtonTemplate } = view;
        const { arch, relatedModels, resModel, buttonTemplate } = genericProps;
        return {
            ...genericProps,
            archInfo: new ArchParser().parse(arch, relatedModels, resModel),
            buttonTemplate: buttonTemplate || viewButtonTemplate,
            Model,
            Renderer,
        };
    }
};

registry.category('views').add('grid', gridView);

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /analytic_enterprise/static/src/analytic_line_grid/analytic_line_grid_model.js  *
*  Lines: 50                                                                                 *
*********************************************************************************************/
odoo.define('@analytic_enterprise/analytic_line_grid/analytic_line_grid_model', ['@web/core/l10n/dates', '@web_grid/views/grid_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { serializeDate, deserializeDate } = require("@web/core/l10n/dates");
const { GridNavigationInfo, GridModel, GridDataPoint } = require("@web_grid/views/grid_model");

const AnalyticLineGridDataPoint = __exports.AnalyticLineGridDataPoint = class AnalyticLineGridDataPoint extends GridDataPoint {
    async _initialiseData() {
        if (this.navigationInfo.range.span === "year") {
            await this.navigationInfo.fetchPeriod();
        }
        await super._initialiseData();
    }
}

const AnalyticLineGridNavigationInfo = __exports.AnalyticLineGridNavigationInfo = class AnalyticLineGridNavigationInfo extends GridNavigationInfo {
    get periodStart() {
        if (this.range.span !== "year" || !this._periodStart) {
            return super.periodStart;
        }
        return this._periodStart;
    }

    get periodEnd() {
        if (this.range.span !== "year" || !this._periodEnd) {
            return super.periodEnd;
        }
        return this._periodEnd;
    }

    async fetchPeriod() {
        const { date_from, date_to } = await this.model.orm.call(
            this.model.resModel,
            "grid_compute_year_range",
            [serializeDate(this.anchor)]
        );
        this._periodStart = deserializeDate(date_from);
        this._periodEnd = deserializeDate(date_to);
    }
}

const AnalyticLineGridModel = __exports.AnalyticLineGridModel = class AnalyticLineGridModel extends GridModel {
    static DataPoint = AnalyticLineGridDataPoint;
    static NavigationInfo = AnalyticLineGridNavigationInfo;
}

return __exports;
});
;

/********************************************************************************************
*  Filepath: /analytic_enterprise/static/src/analytic_line_grid/analytic_line_grid_view.js  *
*  Lines: 20                                                                                *
********************************************************************************************/
odoo.define('@analytic_enterprise/analytic_line_grid/analytic_line_grid_view', ['@web/core/registry', '@web_grid/views/grid_view', '@analytic_enterprise/analytic_line_grid/analytic_line_grid_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");

const { gridView } = require("@web_grid/views/grid_view");

const { AnalyticLineGridModel } = require("@analytic_enterprise/analytic_line_grid/analytic_line_grid_model");

const analyticLineGridView = __exports.analyticLineGridView = {
    ...gridView,
    Model: AnalyticLineGridModel,
}

registry.category("views").add("analytic_line_grid", analyticLineGridView)

return __exports;
});
;

/**********************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_map/project_task_map_model.js  *
*  Lines: 23                                                                                  *
**********************************************************************************************/
odoo.define('@project_enterprise/views/project_task_map/project_task_map_model', ['@web/core/l10n/translation', '@web_map/map_view/map_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { MapModel } = require("@web_map/map_view/map_model");

const ProjectTaskMapModel = __exports.ProjectTaskMapModel = class ProjectTaskMapModel extends MapModel {
    /**
     * @override
     */
    _getEmptyGroupLabel(fieldName) {
        if (fieldName === "project_id") {
            return _t("Private");
        } else if (fieldName === "user_ids") {
            return _t("Unassigned");
        } else {
            return super._getEmptyGroupLabel(fieldName);
        }
    }
}

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_map/project_task_map_renderer.js  *
*  Lines: 13                                                                                     *
*************************************************************************************************/
odoo.define('@project_enterprise/views/project_task_map/project_task_map_renderer', ['@web_map/map_view/map_renderer'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { MapRenderer } = require("@web_map/map_view/map_renderer");

const ProjectTaskMapRenderer = __exports.ProjectTaskMapRenderer = class ProjectTaskMapRenderer extends MapRenderer {
    static template = "project_enterprise.ProjectTaskMapRenderer";
}

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_map/project_task_map_view.js  *
*  Lines: 22                                                                                 *
*********************************************************************************************/
odoo.define('@project_enterprise/views/project_task_map/project_task_map_view', ['@web/core/registry', '@web_map/map_view/map_view', '@project_enterprise/views/project_task_map/project_task_map_model', '@project_enterprise/views/project_task_map/project_task_map_renderer', '@project_enterprise/views/highlight_project_task_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { mapView } = require("@web_map/map_view/map_view");
const { ProjectTaskMapModel } = require("@project_enterprise/views/project_task_map/project_task_map_model");
const { ProjectTaskMapRenderer } = require("@project_enterprise/views/project_task_map/project_task_map_renderer");
const { HighlightProjectTaskSearchModel } = require("@project_enterprise/views/highlight_project_task_search_model");

const projectTaskMapView = __exports.projectTaskMapView = {
    ...mapView,
    Model: ProjectTaskMapModel,
    Renderer: ProjectTaskMapRenderer,
    SearchModel: HighlightProjectTaskSearchModel,
};

registry.category("views").add("project_task_map", projectTaskMapView);

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_graph/project_task_graph_view.js  *
*  Lines: 14                                                                                     *
*************************************************************************************************/
odoo.define('@project_enterprise/views/project_task_graph/project_task_graph_view', ['@web/core/registry', '@project/views/project_task_graph/project_task_graph_view', '@project_enterprise/views/highlight_project_task_search_model'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { projectTaskGraphView } = require("@project/views/project_task_graph/project_task_graph_view");
const { HighlightProjectTaskSearchModel } = require("@project_enterprise/views/highlight_project_task_search_model");

registry.category("views").add("project_enterprise_task_graph", {
    ...projectTaskGraphView,
    SearchModel: HighlightProjectTaskSearchModel,
});

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_pivot/project_task_pivot_view.js  *
*  Lines: 14                                                                                     *
*************************************************************************************************/
odoo.define('@project_enterprise/views/project_task_pivot/project_task_pivot_view', ['@web/core/registry', '@project/views/project_task_pivot/project_pivot_view', '@project_enterprise/views/highlight_project_task_search_model'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { projectPivotView } = require("@project/views/project_task_pivot/project_pivot_view");
const { HighlightProjectTaskSearchModel } = require("@project_enterprise/views/highlight_project_task_search_model");

registry.category("views").add("project_enterprise_task_pivot", {
    ...projectPivotView,
    SearchModel: HighlightProjectTaskSearchModel,
});

return __exports;
});
;

/*******************************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_task_activity/project_task_activity_view.js  *
*  Lines: 14                                                                                           *
*******************************************************************************************************/
odoo.define('@project_enterprise/views/project_task_activity/project_task_activity_view', ['@web/core/registry', '@mail/views/web/activity/activity_view', '@project_enterprise/views/highlight_project_task_search_model'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { activityView } = require("@mail/views/web/activity/activity_view");
const { HighlightProjectTaskSearchModel } = require("@project_enterprise/views/highlight_project_task_search_model");

registry.category("views").add("project_enterprise_activity", {
    ...activityView,
    SearchModel: HighlightProjectTaskSearchModel,
});

return __exports;
});
;

/************************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/milestones_popover.js  *
*  Lines: 22                                                                        *
************************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/milestones_popover', ['@odoo/owl', '@web/core/l10n/dates'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Component } = require("@odoo/owl");
const { formatDate } = require("@web/core/l10n/dates");

const MilestonesPopover = __exports.MilestonesPopover = class MilestonesPopover extends Component {
    static template = "project_enterprise.MilestonesPopover";
    static props = ["close", "displayMilestoneDates", "displayProjectName", "projects"];

    getDeadline(milestone) {
        if (!milestone.deadline) {
            return;
        }
        return formatDate(milestone.deadline);
    }
}

return __exports;
});
;

/****************************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/task_gantt_arch_parser.js  *
*  Lines: 22                                                                            *
****************************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/task_gantt_arch_parser', ['@web_gantt/gantt_arch_parser'], function (require) {
'use strict';
let __exports = {};
const { GanttArchParser } = require("@web_gantt/gantt_arch_parser");

const TaskGanttArchParser = __exports.TaskGanttArchParser = class TaskGanttArchParser extends GanttArchParser {
    parse() {
        const archInfo = super.parse(...arguments);
        const decorationFields = new Set([...archInfo.decorationFields, "project_id"]);
        if (archInfo.dependencyEnabled) {
            decorationFields.add("allow_task_dependencies");
            decorationFields.add("display_warning_dependency_in_gantt");
        }
        return {
            ...archInfo,
            decorationFields: [...decorationFields],
        };
    }
}

return __exports;
});
;

/***************************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/task_gantt_controller.js  *
*  Lines: 9                                                                            *
***************************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/task_gantt_controller', ['@web_gantt/gantt_controller'], function (require) {
'use strict';
let __exports = {};
const { GanttController } = require("@web_gantt/gantt_controller");

const TaskGanttController = __exports.TaskGanttController = class TaskGanttController extends GanttController {}

return __exports;
});
;

/**********************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/task_gantt_model.js  *
*  Lines: 266                                                                     *
**********************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/task_gantt_model', ['@web/core/l10n/translation', '@web/core/l10n/dates', '@web_gantt/gantt_model', '@web/core/utils/arrays', '@web/core/domain', '@project_enterprise/views/project_highlight_tasks'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { deserializeDate, deserializeDateTime, serializeDateTime } = require("@web/core/l10n/dates");
const { GanttModel } = require("@web_gantt/gantt_model");
const { sortBy } = require("@web/core/utils/arrays");
const { Domain } = require("@web/core/domain");
const { useProjectModelActions } = require("@project_enterprise/views/project_highlight_tasks");

const MAP_MANY_2_MANY_FIELDS = [
    {
        many2many_field: "personal_stage_type_ids",
        many2one_field: "personal_stage_type_id",
    },
];

const TaskGanttModel = __exports.TaskGanttModel = class TaskGanttModel extends GanttModel {
    //-------------------------------------------------------------------------
    // Public
    //-------------------------------------------------------------------------

    setup() {
        super.setup(...arguments);
        this.getHighlightIds = useProjectModelActions({
            getContext: () => this.env.searchModel._context,
            getHighlightPlannedIds: () => this.env.searchModel.highlightPlannedIds,
        }).getHighlightIds;
    }

    getDialogContext() {
        const context = super.getDialogContext(...arguments);
        this._replaceSpecialMany2manyKeys(context);
        if ("user_ids" in context && !context.user_ids) {
            delete context.user_ids;
        }
        return context;
    }

    toggleHighlightPlannedFilter(ids) {
        super.toggleHighlightPlannedFilter(...arguments);
        this.env.searchModel.toggleHighlightPlannedFilter(ids);
    }

    /**
     * @override
     */
    reschedule(ids, schedule, callback) {
        if (!schedule.smart_task_scheduling) {
            return super.reschedule(...arguments);
        }
        if (!Array.isArray(ids)) {
            ids = [ids];
        }

        const allData = this._scheduleToData(schedule);
        const endDateTime = deserializeDateTime(allData.date_deadline).endOf(
            this.metaData.scale.id
        );

        const data = this.removeRedundantData(allData, ids);
        delete data.name;
        return this.mutex.exec(async () => {
            try {
                const result = await this.orm.call(
                    this.metaData.resModel,
                    "schedule_tasks",
                    [ids, data],
                    {
                        context: {
                            ...this.searchParams.context,
                            last_date_view: serializeDateTime(endDateTime),
                            cell_part: this.metaData.scale.cellPart,
                        },
                    }
                );
                if (result && Array.isArray(result) && result.length > 1) {
                    this.toggleHighlightPlannedFilter(Object.keys(result[1]).map(Number));
                }
                if (callback) {
                    callback(result);
                }
            } finally {
                this.fetchData();
            }
        });
    }

    _reschedule(ids, data, context) {
        return this.orm.call(this.metaData.resModel, "web_gantt_write", [ids, data], {
            context,
        });
    }

    async unscheduleTask(id) {
        await this.orm.call("project.task", "action_unschedule_task", [id]);
        this.fetchData();
    }

    //-------------------------------------------------------------------------
    // Protected
    //-------------------------------------------------------------------------

    /**
     * Retrieve the milestone data based on the task domain and the project deadline if applicable.
     * @override
     */
    async _fetchData(metaData, additionalContext) {
        const globalStart = metaData.globalStart.toISODate();
        const globalStop = metaData.globalStop.toISODate();
        const scale = metaData.scale.unit;
        additionalContext = {
            ...(additionalContext || {}),
            gantt_start_date: globalStart,
            gantt_scale: scale,
        };
        const proms = [this.getHighlightIds(), super._fetchData(metaData, additionalContext)];
        let milestones = [];
        const projectDeadlines = [];
        const projectStartDates = [];
        if (!this.orm.isSample && !this.env.isSmall) {
            const prom = this.orm
                .call("project.task", "get_all_deadlines", [globalStart, globalStop], {
                    context: this.searchParams.context,
                })
                .then(({ milestone_id, project_id }) => {
                    milestones = milestone_id.map((m) => ({
                        ...m,
                        deadline: deserializeDate(m.deadline),
                    }));
                    for (const project of project_id) {
                        const dateEnd = project.date;
                        const dateStart = project.date_start;
                        if (dateEnd >= globalStart && dateEnd <= globalStop) {
                            projectDeadlines.push({
                                ...project,
                                date: deserializeDate(dateEnd),
                            });
                        }
                        if (dateStart >= globalStart && dateStart <= globalStop) {
                            projectStartDates.push({
                                ...project,
                                date: deserializeDate(dateStart),
                            });
                        }
                    }
                });
            proms.push(prom);
        }
        this.highlightIds = (await Promise.all(proms))[0];
        this.data.milestones = sortBy(milestones, (m) => m.deadline);
        this.data.projectDeadlines = sortBy(projectDeadlines, (d) => d.date);
        this.data.projectStartDates = sortBy(projectStartDates, (d) => d.date);
    }

    /**
     * @override
     */
    _generateRows(metaData, params) {
        const { groupedBy, groups, parentGroup } = params;
        if (groupedBy.length) {
            const groupedByField = groupedBy[0];
            if (groupedByField === "user_ids") {
                // Here we are generating some rows under a common "parent" (if any).
                // We make sure that a row with resId = false for "user_id"
                // ('Unassigned Tasks') and same "parent" will be added by adding
                // a suitable fake group to groups (a subset of the groups returned
                // by read_group).
                const fakeGroup = Object.assign({}, ...parentGroup);
                groups.push(fakeGroup);
            }
        }
        const rows = super._generateRows(...arguments);

        // keep empty row to the head and sort the other rows alphabetically
        // except when grouping by stage or personal stage
        if (!["stage_id", "personal_stage_type_ids"].includes(groupedBy[0])) {
            rows.sort((a, b) => {
                if (a.resId && !b.resId) {
                    return 1;
                } else if (!a.resId && b.resId) {
                    return -1;
                } else {
                    return a.name.localeCompare(b.name);
                }
            });
        }
        return rows;
    }

    /**
     * @override
     */
    _getRowName(_, groupedByField, value) {
        if (!value) {
            if (groupedByField === "user_ids") {
                return _t(" Unassigned");
            } else if (groupedByField === "project_id") {
                return _t(" Private");
            }
        }
        return super._getRowName(...arguments);
    }

    /**
     * In the case of special Many2many Fields, like personal_stage_type_ids in project.task
     * model, we don't want to write the many2many field but use the inverse method of the
     * linked Many2one field, in this case the personal_stage_type_id, to create or update the
     * record - here set the stage_id - in the personal_stage_type_ids.
     *
     * This is mandatory since the python ORM doesn't support the creation of
     * a personnal stage from scratch. If this method is not overriden, then an entry
     * will be inserted in the project_task_user_rel.
     * One for the faked Many2many user_ids field (1), and a second one for the other faked
     * Many2many personal_stage_type_ids field (2).
     *
     * While the first one meets the constraint on the project_task_user_rel, the second one
     * fails because it specifies no user_id; It tries to insert (task_id, stage_id) into the
     * relation.
     *
     * If we don't remove those key from the context, the ORM will face two problems :
     * - It will try to insert 2 entries in the project_task_user_rel
     * - It will try to insert an incorrect entry in the project_task_user_rel
     *
     * @param {Object} object
     */
    _replaceSpecialMany2manyKeys(object) {
        for (const { many2many_field, many2one_field } of MAP_MANY_2_MANY_FIELDS) {
            if (many2many_field in object) {
                object[many2one_field] = object[many2many_field][0];
                delete object[many2many_field];
            }
        }
    }

    /**
     * @override
     */
    _scheduleToData() {
        const data = super._scheduleToData(...arguments);
        this._replaceSpecialMany2manyKeys(data);
        return data;
    }

    /**
     * @override
     */
    load(searchParams) {
        const { context, domain, groupBy } = searchParams;
        let displayUnassigned = false;
        if (groupBy.length === 0 || groupBy[groupBy.length - 1] === "user_ids") {
            for (const node of domain) {
                if (node.length === 3 && node[0] === "user_ids.name" && node[1] === "ilike") {
                    displayUnassigned = true;
                }
            }
        }
        if (displayUnassigned) {
            searchParams.domain = Domain.or([domain, "[('user_ids', '=', false)]"]).toList();
        }
        return super.load({ ...searchParams, context: { ...context }, displayUnassigned });
    }
}

return __exports;
});
;

/*************************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/task_gantt_renderer.js  *
*  Lines: 326                                                                        *
*************************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/task_gantt_renderer', ['@project_enterprise/views/view_dialogs/select_auto_plan_create_dialog', '@web/core/l10n/translation', '@mail/views/web/fields/avatar/avatar', '@odoo/owl', '@web/core/l10n/localization', '@web/core/popover/popover_hook', '@web/core/utils/hooks', '@web_gantt/gantt_renderer', '@web/core/utils/strings', '@project_enterprise/views/task_gantt/milestones_popover', '@web/views/view_dialogs/form_view_dialog', '@web/views/fields/formatters'], function (require) {
'use strict';
let __exports = {};
const { SelectCreateAutoPlanDialog } = require("@project_enterprise/views/view_dialogs/select_auto_plan_create_dialog");
const { _t } = require("@web/core/l10n/translation");
const { Avatar } = require("@mail/views/web/fields/avatar/avatar");
const { markup, onWillUnmount, useEffect } = require("@odoo/owl");
const { localization } = require("@web/core/l10n/localization");
const { usePopover } = require("@web/core/popover/popover_hook");
const { useService } = require("@web/core/utils/hooks");
const { GanttRenderer } = require("@web_gantt/gantt_renderer");
const { escape } = require("@web/core/utils/strings");
const { MilestonesPopover } = require("@project_enterprise/views/task_gantt/milestones_popover");
const { FormViewDialog } = require("@web/views/view_dialogs/form_view_dialog");
const { formatFloatTime } = require("@web/views/fields/formatters");

const TaskGanttRenderer = __exports.TaskGanttRenderer = class TaskGanttRenderer extends GanttRenderer {
    static components = {
        ...GanttRenderer.components,
        Avatar,
    };
    static headerTemplate = "project_enterprise.TaskGanttRenderer.Header";
    static rowHeaderTemplate = "project_enterprise.TaskGanttRenderer.RowHeader";
    static rowContentTemplate = "project_enterprise.TaskGanttRenderer.RowContent";
    static totalRowTemplate = "project_enterprise.TaskGanttRenderer.TotalRow";
    static pillTemplate = "project_enterprise.TaskGanttRenderer.Pill";
    setup() {
        super.setup(...arguments);
        this.notificationService = useService("notification");
        this.orm = useService("orm");
        useEffect(
            (el) => el.classList.add("o_project_gantt"),
            () => [this.gridRef.el]
        );
        const position = localization.direction === "rtl" ? "bottom" : "right";
        this.milestonePopover = usePopover(MilestonesPopover, { position });
        onWillUnmount(() => {
            this.notificationFn?.();
        });
    }

    /**
     * @override
     */
    enrichPill(pill) {
        const enrichedPill = super.enrichPill(pill);
        if (enrichedPill?.record) {
            if (
                this.props.model.highlightIds &&
                !this.props.model.highlightIds.includes(enrichedPill.record.id)
            ) {
                pill.className += " opacity-25";
            }
        }
        return enrichedPill;
    }

    computeVisibleColumns() {
        super.computeVisibleColumns();
        this.columnMilestones = {}; // deadlines and milestones by project
        for (const column of this.columns) {
            this.columnMilestones[column.id] = {
                hasDeadLineExceeded: false,
                allReached: true,
                projects: {},
                hasMilestone: false,
                hasDeadline: false,
                hasStartDate: false,
            };
        }
        // Handle start date at the beginning of the current period
        this.columnMilestones[this.columns[0].id].edge = {
            projects: {},
            hasStartDate: false,
        };
        const projectStartDates = [...this.model.data.projectStartDates];
        const projectDeadlines = [...this.model.data.projectDeadlines];
        const milestones = [...this.model.data.milestones];

        let project = projectStartDates.shift();
        let projectDeadline = projectDeadlines.shift();
        let milestone = milestones.shift();
        let i = 0;
        while (i < this.columns.length && (project || projectDeadline || milestone)) {
            const column = this.columns[i];
            const nextColumn = this.columns[i + 1];
            const info = this.columnMilestones[column.id];

            if (i == 0 && project && column && column.stop > project.date) {
                // For the first column, start dates have to be displayed at the start of the period
                if (!info.edge.projects[project.id]) {
                    info.edge.projects[project.id] = {
                        milestones: [],
                        id: project.id,
                        name: project.name,
                    };
                }
                info.edge.projects[project.id].isStartDate = true;
                info.edge.hasStartDate = true;
                project = projectStartDates.shift();
            } else if (project && nextColumn?.stop > project.date) {
                if (!info.projects[project.id]) {
                    info.projects[project.id] = {
                        milestones: [],
                        id: project.id,
                        name: project.name,
                    };
                }
                info.projects[project.id].isStartDate = true;
                info.hasStartDate = true;
                project = projectStartDates.shift();
            }

            if (projectDeadline && column.stop > projectDeadline.date) {
                if (!info.projects[projectDeadline.id]) {
                    info.projects[projectDeadline.id] = {
                        milestones: [],
                        id: projectDeadline.id,
                        name: projectDeadline.name,
                    };
                }
                info.projects[projectDeadline.id].isDeadline = true;
                info.hasDeadline = true;
                projectDeadline = projectDeadlines.shift();
            }

            if (milestone && column.stop > milestone.deadline) {
                const [projectId, projectName] = milestone.project_id;
                if (!info.projects[projectId]) {
                    info.projects[projectId] = {
                        milestones: [],
                        id: projectId,
                        name: projectName,
                    };
                }
                const { is_deadline_exceeded, is_reached } = milestone;
                info.projects[projectId].milestones.push(milestone);
                info.hasMilestone = true;
                milestone = milestones.shift();
                if (is_deadline_exceeded) {
                    info.hasDeadLineExceeded = true;
                }
                if (!is_reached) {
                    info.allReached = false;
                }
            }
            if (
                (!project || !nextColumn || nextColumn?.stop < project.date) &&
                (!projectDeadline || column.stop < projectDeadline.date) &&
                (!milestone || column.stop < milestone.deadline)
            ) {
                i++;
            }
        }
    }

    computeDerivedParams() {
        this.rowsWithAvatar = {};
        super.computeDerivedParams();
    }

    getConnectorAlert(masterRecord, slaveRecord) {
        if (
            masterRecord.display_warning_dependency_in_gantt &&
            slaveRecord.display_warning_dependency_in_gantt
        ) {
            return super.getConnectorAlert(...arguments);
        }
    }

    getPopoverProps(pill) {
        const props = super.getPopoverProps(...arguments);
        const { record } = pill;
        if (record.planning_overlap) {
            props.context.planningOverlapHtml = markup(record.planning_overlap);
        }
        props.context.allocated_hours = formatFloatTime(props.context.allocated_hours);
        return props;
    }

    getAvatarProps(row) {
        return this.rowsWithAvatar[row.id];
    }

    getSelectCreateDialogProps() {
        const props = super.getSelectCreateDialogProps(...arguments);
        const onCreateEdit = () => {
            this.dialogService.add(FormViewDialog, {
                context: props.context,
                resModel: props.resModel,
                onRecordSaved: async (record) => {
                    await record.save({ reload: false });
                    await this.model.fetchData();
                },
            });
        };
        const onSelectedAutoPlan = (resIds) => {
            props.context.smart_task_scheduling = true;
            if (resIds.length) {
                this.model.reschedule(
                    resIds,
                    props.context,
                    this.openPlanDialogCallback.bind(this)
                );
            }
        };
        props.onSelectedNoSmartSchedule = props.onSelected;
        props.onSelected = onSelectedAutoPlan;
        props.onCreateEdit = onCreateEdit;
        return props;
    }

    hasAvatar(row) {
        return row.id in this.rowsWithAvatar;
    }

    getNotificationOnSmartSchedule(warningString, old_vals_per_task_id) {
        this.notificationFn?.();
        this.notificationFn = this.notificationService.add(
            markup(
                `<i class="fa btn-link fa-check"></i><span class="ms-1">${escape(
                    warningString
                )}</span>`
            ),
            {
                type: "success",
                sticky: true,
                buttons: [
                    {
                        name: "Undo",
                        icon: "fa-undo",
                        onClick: async () => {
                            const ids = Object.keys(old_vals_per_task_id).map(Number);
                            await this.orm.call("project.task", "action_rollback_auto_scheduling", [
                                ids,
                                old_vals_per_task_id,
                            ]);
                            this.model.toggleHighlightPlannedFilter(false);
                            this.notificationFn();
                            await this.model.fetchData();
                        },
                    },
                ],
            }
        );
    }

    openPlanDialogCallback(res) {
        if (res && Array.isArray(res)) {
            const warnings = Object.entries(res[0]);
            const old_vals_per_task_id = res[1];
            for (const warning of warnings) {
                this.notificationService.add(warning[1], {
                    title: _t("Warning"),
                    type: "warning",
                    sticky: true,
                });
            }
            if (warnings.length === 0) {
                this.getNotificationOnSmartSchedule(
                    _t("Tasks have been successfully scheduled for the upcoming periods."),
                    old_vals_per_task_id
                );
            }
        }
    }

    processRow(row) {
        const { groupedByField, name, resId } = row;
        if (groupedByField === "user_ids" && Boolean(resId)) {
            const { fields } = this.model.metaData;
            const resModel = fields.user_ids.relation;
            this.rowsWithAvatar[row.id] = { resModel, resId, displayName: name };
        }
        return super.processRow(...arguments);
    }

    shouldRenderRecordConnectors(record) {
        if (record.allow_task_dependencies) {
            return super.shouldRenderRecordConnectors(...arguments);
        }
        return false;
    }

    highlightPill(pillId, highlighted) {
        if (!this.connectorDragState.dragging) {
            return super.highlightPill(pillId, highlighted);
        }
        const pill = this.pills[pillId];
        if (!pill) {
            return;
        }
        const { record } = pill;
        if (!this.shouldRenderRecordConnectors(record)) {
            return super.highlightPill(pillId, false);
        }
        return super.highlightPill(pillId, highlighted);
    }

    onPlan(rowId, columnStart, columnStop) {
        const { start, stop } = this.getColumnStartStop(columnStart, columnStop);
        this.dialogService.add(
            SelectCreateAutoPlanDialog,
            this.getSelectCreateDialogProps({ rowId, start, stop, withDefault: true })
        );
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    onMilestoneMouseEnter(ev, projects) {
        this.milestonePopover.open(ev.target, {
            displayMilestoneDates: this.model.metaData.scale.id === "year",
            displayProjectName: !this.model.searchParams.context.default_project_id,
            projects,
        });
    }

    onMilestoneMouseLeave() {
        this.milestonePopover.close();
    }
}

return __exports;
});
;

/*********************************************************************************
*  Filepath: /project_enterprise/static/src/views/task_gantt/task_gantt_view.js  *
*  Lines: 26                                                                     *
*********************************************************************************/
odoo.define('@project_enterprise/views/task_gantt/task_gantt_view', ['@web_gantt/gantt_view', '@project_enterprise/views/task_gantt/task_gantt_controller', '@web/core/registry', '@project_enterprise/views/task_gantt/task_gantt_arch_parser', '@project_enterprise/views/task_gantt/task_gantt_model', '@project_enterprise/views/task_gantt/task_gantt_renderer', '@project_enterprise/views/project_task_search_model'], function (require) {
'use strict';
let __exports = {};
const { ganttView } = require("@web_gantt/gantt_view");
const { TaskGanttController } = require("@project_enterprise/views/task_gantt/task_gantt_controller");
const { registry } = require("@web/core/registry");
const { TaskGanttArchParser } = require("@project_enterprise/views/task_gantt/task_gantt_arch_parser");
const { TaskGanttModel } = require("@project_enterprise/views/task_gantt/task_gantt_model");
const { TaskGanttRenderer } = require("@project_enterprise/views/task_gantt/task_gantt_renderer");
const { ProjectTaskSearchModel } = require("@project_enterprise/views/project_task_search_model");

const viewRegistry = registry.category("views");

const taskGanttView = __exports.taskGanttView = {
    ...ganttView,
    Controller: TaskGanttController,
    ArchParser: TaskGanttArchParser,
    Model: TaskGanttModel,
    Renderer: TaskGanttRenderer,
    SearchModel: ProjectTaskSearchModel,
};

viewRegistry.add("task_gantt", taskGanttView);

return __exports;
});
;

/****************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_gantt/project_gantt_model.js  *
*  Lines: 25                                                                            *
****************************************************************************************/
odoo.define('@project_enterprise/views/project_gantt/project_gantt_model', ['@web/core/user', '@web_gantt/gantt_model'], function (require) {
'use strict';
let __exports = {};
const { user } = require('@web/core/user');
const { GanttModel } = require("@web_gantt/gantt_model");

const COLOR_FIELD = "stage_id";

const ProjectGanttModel = __exports.ProjectGanttModel = class ProjectGanttModel extends GanttModel {
    /**
     * @override
     */
    async load(searchParams) {
        const stagesEnabled = await user.hasGroup("project.group_project_stages");
        if (stagesEnabled && !this.metaData.colorField) {
            // This is equivalent to setting a color attribute for the gantt view, but only when we have read access to
            // the field (i.e. the user has the 'project.group_project_stages' group).
            this.metaData.colorField = COLOR_FIELD;
        }
        await super.load(searchParams);
    }
}

return __exports;
});
;

/*******************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_gantt/project_gantt_renderer.js  *
*  Lines: 39                                                                               *
*******************************************************************************************/
odoo.define('@project_enterprise/views/project_gantt/project_gantt_renderer', ['@mail/views/web/fields/avatar/avatar', '@web_gantt/gantt_renderer'], function (require) {
'use strict';
let __exports = {};
const { Avatar } = require("@mail/views/web/fields/avatar/avatar");
const { GanttRenderer } = require("@web_gantt/gantt_renderer");

const ProjectGanttRenderer = __exports.ProjectGanttRenderer = class ProjectGanttRenderer extends GanttRenderer {
    static components = {
        ...GanttRenderer.components,
        Avatar,
    };
    static rowHeaderTemplate = "project_enterprise.ProjectGanttRenderer.RowHeader";

    computeDerivedParams() {
        this.rowsWithAvatar = {};
        super.computeDerivedParams();
    }

    processRow(row) {
        const { groupedByField, name, resId } = row;
        if (groupedByField === "user_id" && Boolean(resId)) {
            const { fields } = this.model.metaData;
            const resModel = fields.user_id.relation;
            this.rowsWithAvatar[row.id] = { resModel, resId, displayName: name };
        }
        return super.processRow(...arguments);
    }

    getAvatarProps(row) {
        return this.rowsWithAvatar[row.id];
    }

    hasAvatar(row) {
        return row.id in this.rowsWithAvatar;
    }
}

return __exports;
});
;

/***************************************************************************************
*  Filepath: /project_enterprise/static/src/views/project_gantt/project_gantt_view.js  *
*  Lines: 18                                                                           *
***************************************************************************************/
odoo.define('@project_enterprise/views/project_gantt/project_gantt_view', ['@web_gantt/gantt_view', '@web/core/registry', '@project_enterprise/views/project_gantt/project_gantt_model', '@project_enterprise/views/project_gantt/project_gantt_renderer'], function (require) {
'use strict';
let __exports = {};
const { ganttView } = require("@web_gantt/gantt_view");
const { registry } = require("@web/core/registry");
const { ProjectGanttModel } = require("@project_enterprise/views/project_gantt/project_gantt_model");
const { ProjectGanttRenderer } = require("@project_enterprise/views/project_gantt/project_gantt_renderer");

const projectGanttView = __exports.projectGanttView = {
    ...ganttView,
    Model: ProjectGanttModel,
    Renderer: ProjectGanttRenderer,
};

registry.category("views").add("project_gantt", projectGanttView);

return __exports;
});
;

/******************************************************************************
*  Filepath: /spreadsheet_edition/static/src/assets/graph_view/graph_view.js  *
*  Lines: 67                                                                  *
******************************************************************************/
odoo.define('@spreadsheet_edition/assets/graph_view/graph_view', ['@web/views/graph/graph_renderer', '@web/core/user', '@web/session', '@web/core/utils/patch', '@web/core/utils/hooks', '@spreadsheet_edition/assets/components/spreadsheet_selector_dialog/spreadsheet_selector_dialog', '@web/core/utils/objects'], function (require) {
'use strict';
let __exports = {};
const { GraphRenderer } = require("@web/views/graph/graph_renderer");
const { user } = require("@web/core/user");
const { session } = require("@web/session");
const { patch } = require("@web/core/utils/patch");
const { useService } = require("@web/core/utils/hooks");
const { SpreadsheetSelectorDialog } = require("@spreadsheet_edition/assets/components/spreadsheet_selector_dialog/spreadsheet_selector_dialog");
const { omit } = require("@web/core/utils/objects");

const patchGraphSpreadsheet = __exports.patchGraphSpreadsheet = () => ({
    setup() {
        super.setup(...arguments);
        this.notification = useService("notification");
        this.actionService = useService("action");
        this.menu = useService("menu");
        this.canInsertChart = session.can_insert_in_spreadsheet;
    },

    async onInsertInSpreadsheet() {
        const { actionId } = this.env.config;
        const { xml_id } = actionId
            ? await this.actionService.loadAction(actionId, this.env.searchModel.context)
            : {};
        const actionOptions = {
            preProcessingAsyncAction: "insertChart",
            preProcessingAsyncActionData: {
                metaData: this.model.metaData,
                searchParams: {
                    ...this.model.searchParams,
                    domain: this.env.searchModel.domainString,
                    context: omit(
                        this.model.searchParams.context,
                        ...Object.keys(user.context),
                        "graph_measure",
                        "graph_order"
                    ),
                },
                actionXmlId: xml_id,
            },
        };
        const params = {
            type: "GRAPH",
            name: this.model.metaData.title,
            actionOptions,
        };
        this.env.services.dialog.add(SpreadsheetSelectorDialog, params);
    },
});

/**
 * This patch is a little trick, which require a little explanation:
 *
 * In this patch, we add some dependencies to the graph view (menu service,
 * router service, ...).
 * To test it, we add these dependencies in our tests, but these dependencies
 * are not added in the tests of the base graph view (in web/). The same thing
 * occurs for the button "Insert in spreadsheet".
 * As we do not want to modify tests in web/ in order to integrate a behavior
 * defined in another module, we disable this patch in a file that is only
 * loaded in test assets (disable_patch.js), and re-active it in our tests.
 */
const unpatchGraphSpreadsheet = __exports.unpatchGraphSpreadsheet = patch(GraphRenderer.prototype, patchGraphSpreadsheet());

return __exports;
});
;

/******************************************************************************
*  Filepath: /spreadsheet_edition/static/src/assets/pivot_view/pivot_view.js  *
*  Lines: 121                                                                 *
******************************************************************************/
odoo.define('@spreadsheet_edition/assets/pivot_view/pivot_view', ['@web/views/pivot/pivot_renderer', '@web/core/user', '@web/core/utils/arrays', '@web/core/utils/patch', '@web/core/utils/hooks', '@web/core/utils/objects', '@web/core/l10n/translation', '@spreadsheet_edition/assets/components/spreadsheet_selector_dialog/spreadsheet_selector_dialog', '@web/session'], function (require) {
'use strict';
let __exports = {};
const { PivotRenderer } = require("@web/views/pivot/pivot_renderer");
const { user } = require("@web/core/user");
const { intersection, unique } = require("@web/core/utils/arrays");
const { patch } = require("@web/core/utils/patch");
const { useService } = require("@web/core/utils/hooks");
const { omit } = require("@web/core/utils/objects");

const { _t } = require("@web/core/l10n/translation");
const { SpreadsheetSelectorDialog } = require("@spreadsheet_edition/assets/components/spreadsheet_selector_dialog/spreadsheet_selector_dialog");

const { session } = require("@web/session");

/**
 * This const is defined in o-spreadsheet library, but has to be redefined here
 * because o-spreadsheet is lazy loaded in another bundle than this file is.
 */
const ALL_PERIODS = {
    quarter: _t("Quarter & Year"),
    month: _t("Month & Year"),
    week: _t("Week & Year"),
    day: _t("Day"),
    year: _t("Year"),
    quarter_number: _t("Quarter"),
    month_number: _t("Month"),
    iso_week_number: _t("Week"),
    day_of_month: _t("Day of Month"),
};

patch(PivotRenderer.prototype, {
    setup() {
        super.setup(...arguments);
        this.notification = useService("notification");
        this.actionService = useService("action");
        this.canInsertPivot = session.can_insert_in_spreadsheet;
    },

    async onInsertInSpreadsheet() {
        let name = this.model.metaData.title;
        const groupBy =
            this.model.metaData.fullColGroupBys[0] || this.model.metaData.fullRowGroupBys[0];
        if (groupBy) {
            let [field, period] = groupBy.split(":");
            period = ALL_PERIODS[period];
            if (period) {
                name = _t("%(pivot_title)s by %(group_by)s (%(granularity)s)", {
                    pivot_title: name,
                    group_by: this.model.metaData.fields[field].string,
                    granularity: period,
                });
            } else {
                name = _t("%(pivot_title)s by %(group_by)s", {
                    pivot_title: name,
                    group_by: this.model.metaData.fields[field].string,
                });
            }
        }
        const { actionId } = this.env.config;
        const { xml_id } = actionId
            ? await this.actionService.loadAction(actionId, this.env.searchModel.context)
            : {};

        const actionOptions = {
            preProcessingAsyncAction: "insertPivot",
            preProcessingAsyncActionData: {
                metaData: this.model.metaData,
                searchParams: {
                    ...this.model.searchParams,
                    domain: this.env.searchModel.domainString,
                    context: omit(
                        this.model.searchParams.context,
                        ...Object.keys(user.context),
                        "pivot_measures",
                        "pivot_row_groupby",
                        "pivot_column_groupby"
                    ),
                },
                name,
                actionXmlId: xml_id,
            },
        };
        const params = {
            type: "PIVOT",
            name,
            actionOptions,
        };
        this.env.services.dialog.add(SpreadsheetSelectorDialog, params);
    },

    hasDuplicatedGroupbys() {
        const fullColGroupBys = this.model.metaData.fullColGroupBys;
        const fullRowGroupBys = this.model.metaData.fullRowGroupBys;
        // without aggregator
        const colGroupBys = fullColGroupBys.map((el) => el.split(":")[0]);
        const rowGroupBys = fullRowGroupBys.map((el) => el.split(":")[0]);
        return (
            unique([...fullColGroupBys, ...fullRowGroupBys]).length <
                fullColGroupBys.length + fullRowGroupBys.length ||
            // can group by the same field with different aggregator in the same dimension
            intersection(colGroupBys, rowGroupBys).length
        );
    },

    isInsertButtonDisabled() {
        return (
            !this.model.hasData() ||
            this.model.metaData.activeMeasures.length === 0 ||
            this.model.useSampleModel ||
            this.hasDuplicatedGroupbys()
        );
    },

    getInsertButtonTooltip() {
        return this.hasDuplicatedGroupbys() ? _t("Pivot contains duplicate groupbys") : undefined;
    },
});

return __exports;
});
;

/**********************************************************************************
*  Filepath: /web_studio/static/src/client_action/action_editor/action_editor.js  *
*  Lines: 267                                                                     *
**********************************************************************************/
odoo.define('@web_studio/client_action/action_editor/action_editor', ['@odoo/owl', '@web/core/utils/hooks', '@web/core/network/rpc', '@web/core/user', '@web/core/registry', '@web/core/l10n/translation', '@web/core/utils/arrays', '@web/core/dropdown/dropdown_item', '@web/core/confirmation_dialog/confirmation_dialog', '@web/webclient/actions/action_service', '@web/model/record', '@web/views/fields/many2many_tags/many2many_tags_field', '@web/views/fields/char/char_field', '@web/views/fields/text/text_field', '@web_studio/client_action/components/thumbnail_item/thumbnail_item', '@web_studio/studio_service', '@web_studio/client_action/editor/new_view_dialogs/new_view_dialog', '@web_studio/client_action/editor/new_view_dialogs/map_new_view_dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");
const { useOwnedDialogs, useService } = require("@web/core/utils/hooks");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { registry } = require("@web/core/registry");
const { _t } = require("@web/core/l10n/translation");
const { sortBy } = require("@web/core/utils/arrays");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { AlertDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { standardActionServiceProps } = require("@web/webclient/actions/action_service");

const { Record } = require("@web/model/record");
const {
    Many2ManyTagsField,
    many2ManyTagsField,
} = require("@web/views/fields/many2many_tags/many2many_tags_field");
const { CharField } = require("@web/views/fields/char/char_field");
const { TextField } = require("@web/views/fields/text/text_field");

const { ThumbnailItem } = require("@web_studio/client_action/components/thumbnail_item/thumbnail_item");
const { viewTypeToString, useStudioServiceAsReactive } = require("@web_studio/studio_service");
const { NewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/new_view_dialog");
const { MapNewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/map_new_view_dialog");

function getViewCategories() {
    return {
        general: {
            title: _t("General views"),
            viewTypes: ["form", "search", "activity"],
        },
        multiple: {
            title: _t("Multiple records views"),
            viewTypes: ["list", "kanban", "map"],
        },
        timeline: {
            title: _t("Timeline views"),
            viewTypes: ["calendar", "cohort", "gantt"],
        },
        reporting: {
            title: _t("Reporting views"),
            viewTypes: ["graph", "pivot"],
        },
    };
}

const actionFieldsGet = {
    id: { type: "integer" },
    name: { type: "char" },
    help: { type: "text" },
    groups_id: { type: "many2many", relation: "res.groups", string: "Groups" },
};

function getActionActiveFields() {
    const activeFields = {};
    for (const fName of Object.keys(actionFieldsGet)) {
        activeFields[fName] = {};
    }

    const groups_idRelated = Object.fromEntries(
        many2ManyTagsField.relatedFields({ options: {} }).map((f) => [f.name, f])
    );
    activeFields.groups_id.related = { activeFields: groups_idRelated, fields: groups_idRelated };

    return activeFields;
}

function getActionValues(action) {
    const values = {};
    for (const fName of Object.keys(actionFieldsGet)) {
        values[fName] = action[fName];
    }
    return values;
}

class ActionEditor extends Component {
    static template = "web_studio.ActionEditor";
    static props = { ...standardActionServiceProps };
    static components = {
        ThumbnailItem,
        DropdownItem,
        Record,
        CharField,
        TextField,
        Many2ManyTagsField,
    };

    setup() {
        this.studio = useStudioServiceAsReactive();
        this.action = useService("action");
        this.notification = useService("notification");
        this.viewCategories = getViewCategories();
        this.addDialog = useOwnedDialogs();

        this.actionFieldsGet = { ...actionFieldsGet };
    }

    get actionRecordProps() {
        const values = getActionValues(this.studio.editedAction);
        return {
            fields: this.actionFieldsGet,
            resModel: "ir.actions.act_window",
            resId: values.id,
            mode: "edit",
            values,
            activeFields: getActionActiveFields(),
            onRecordChanged: (record, changes) => {
                return this.editAction(changes);
            },
        };
    }

    get activeViews() {
        return this.studio.editedAction.views.map(([, name]) => name);
    }

    getOrderedViewTypes(viewTypes) {
        const activeViews = this.activeViews;
        const currentDefaultView = activeViews[0];
        const viewInfos = viewTypes.map((viewType) => {
            return {
                name: viewType,
                title: viewTypeToString(viewType),
                isActive: activeViews.includes(viewType),
                isDefault: currentDefaultView === viewType,
                imgUrl: `/web_studio/static/src/img/view_type/${viewType}.png`,
                canBeDefault: !["form", "search"].includes(viewType),
                canBeDisabled: viewType !== "search",
            };
        });
        return sortBy(
            viewInfos,
            ({ isDefault, isActive }) => {
                return isDefault ? 2 : isActive ? 1 : 0;
            },
            "desc"
        );
    }

    setDefaultView(viewType) {
        let viewModes = this.studio.editedAction.view_mode.split(",");
        viewModes = viewModes.filter((m) => m !== viewType);
        viewModes.unshift(viewType);
        return this.editAction({ view_mode: viewModes.join(",") });
    }

    disableView(viewType) {
        const viewMode = this.studio.editedAction.view_mode
            .split(",")
            .filter((m) => m !== viewType);

        if (!viewMode.length) {
            this.addDialog(AlertDialog, {
                body: _t("You cannot deactivate this view as it is the last one active."),
            });
        } else {
            return this.editAction({ view_mode: viewMode.join(",") });
        }
    }

    restoreDefaultView(viewType) {
        return this.env.editionFlow.restoreDefaultView(null, viewType);
    }

    async addViewType(viewType) {
        const action = this.studio.editedAction;
        const viewMode = action.view_mode.split(",");
        viewMode.push(viewType);
        let viewAdded = await rpc("/web_studio/add_view_type", {
            action_type: action.type,
            action_id: action.id,
            res_model: action.res_model,
            view_type: viewType,
            args: { view_mode: viewMode.join(",") },
            context: user.context,
        });

        if (viewAdded !== true) {
            viewAdded = await new Promise((resolve) => {
                let DialogClass;
                const dialogProps = {
                    confirm: async () => {
                        resolve(true);
                    },
                    cancel: () => resolve(false),
                };
                if (["gantt", "calendar", "cohort"].includes(viewType)) {
                    DialogClass = NewViewDialog;
                    dialogProps.viewType = viewType;
                } else if (viewType === "map") {
                    DialogClass = MapNewViewDialog;
                } else {
                    this.addDialog(AlertDialog, {
                        body: _t(
                            "Creating this type of view is not currently supported in Studio."
                        ),
                    });
                    resolve(false);
                }
                this.addDialog(DialogClass, dialogProps);
            });
        }
        if (viewAdded) {
            await this.editAction({ view_mode: viewMode.join(",") });
        }
        return viewAdded;
    }

    editView(viewType) {
        this.studio.setParams({ viewType, editorTab: "views" });
    }

    async onThumbnailClicked(viewType) {
        if (this.activeViews.includes(viewType)) {
            return this.editView(viewType);
        }
        const resModel = this.studio.editedAction.res_model;
        if (viewType === "activity") {
            const activityAllowed = await this.studio.isAllowed("activity", resModel);
            if (!activityAllowed) {
                this.notification.add(
                    _t("Activity view unavailable on this model"),
                    {
                        title: false,
                        type: "danger",
                    }
                );
                return;
            }
        }
        if (await this.addViewType(viewType)) {
            return this.editView(viewType);
        }
    }

    openFormAction() {
        return this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "ir.actions.act_window",
                res_id: this.studio.editedAction.id,
                views: [[false, "form"]],
                target: "current",
            },
            {
                stackPosition: "replacePreviousAction",
            }
        );
    }

    async editAction(changes) {
        await rpc("/web_studio/edit_action", {
            action_id: this.studio.editedAction.id,
            action_type: "ir.actions.act_window",
            args: changes,
        });
        return this.studio.reload({}, false);
    }
}

registry.category("actions").add("web_studio.action_editor", ActionEditor);

return __exports;
});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/client_action/app_creator/app_creator.js  *
*  Lines: 210                                                                 *
******************************************************************************/
odoo.define('@web_studio/client_action/app_creator/app_creator', ['@odoo/owl', '@web/core/network/rpc', '@web/core/user', '@web/core/utils/hooks', '@web_studio/client_action/model_configurator/model_configurator', '@web_studio/client_action/icon_creator/icon_creator', '@web_studio/client_action/menu_creator/menu_creator'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Component, reactive, useExternalListener, useState } = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { useAutofocus, useService } = require("@web/core/utils/hooks");
const { ModelConfigurator } = require("@web_studio/client_action/model_configurator/model_configurator");
const { DEFAULT_ICON, IconCreator } = require("@web_studio/client_action/icon_creator/icon_creator");
const { MenuCreator, MenuCreatorModel } = require("@web_studio/client_action/menu_creator/menu_creator");

class AppCreatorState {
    /**
     * @param {Function} onFinished
     */
    constructor({ onFinished }) {
        this._onFinished = onFinished;
        // ==================== Misc ====================
        this.step = "welcome";

        // ================== Fields ==================
        this.fieldsValidators = {
            appName: () => !!this.data.appName,
            menu: (_this) => _this.menuCreatorModel.isValid,
        };
        this.menuCreatorModel = reactive(new MenuCreatorModel());

        this.data = {
            appName: "",
            iconData: DEFAULT_ICON,
            menu: this.menuCreatorModel.data,
            modelOptions: [],
        };

        // ================== Steps ==================
        this._steps = {
            welcome: {
                next: () => "app",
            },
            app: {
                previous: "welcome",
                next: () => "model",
                fields: ["appName"],
            },
            model: {
                previous: "app",
                next: (data) => {
                    return data.menu.modelChoice === "new" ? "model_configuration" : "";
                },
                fields: ["menu"],
            },
            model_configuration: {
                previous: "model",
            },
        };
    }

    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------

    get step() {
        return this._step;
    }

    set step(step) {
        this._step = step;
        this.showValidation = false;
    }

    get nextStep() {
        return this._stepInvalidFields.length ? false : this._next;
    }

    get hasPrevious() {
        return "previous" in this._currentStep;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    isFieldValid(fieldName) {
        return this.showValidation ? this.fieldsValidators[fieldName](this) : true;
    }

    next() {
        this.showValidation = true;
        const invalidFields = this._stepInvalidFields;
        if (invalidFields.length) {
            return;
        }
        const next = this._next;
        if (next) {
            this.step = next;
        } else {
            return this._onFinished();
        }
    }

    previous() {
        if (this._currentStep.previous) {
            this.step = this._currentStep.previous;
        }
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    get _currentStep() {
        return this._steps[this._step];
    }

    get _next() {
        return this._currentStep.next ? this._currentStep.next(this.data) : "";
    }

    get _stepInvalidFields() {
        return (this._currentStep.fields || []).filter((fName) => {
            return !this.fieldsValidators[fName](this);
        });
    }
}

const AppCreator = __exports.AppCreator = class AppCreator extends Component {
    static template = "web_studio.AppCreator";
    static components = { IconCreator, ModelConfigurator, MenuCreator };
    static props = {
        onNewAppCreated: { type: Function },
    };

    setup() {
        this.state = useState(
            new AppCreatorState({
                onFinished: this.createNewApp.bind(this),
            })
        );

        this.uiService = useService("ui");

        useAutofocus();
        useExternalListener(window, "keydown", this.onKeydown);
    }

    /**
     * @returns {Promise}
     */
    async createNewApp() {
        this.uiService.block();
        const data = this.state.data;
        const iconData = data.iconData;

        const iconValue =
            iconData.type === "custom_icon"
                ? // custom icon data
                  [iconData.iconClass, iconData.color, iconData.backgroundColor]
                : // attachment
                  iconData.uploaded_attachment_id;

        try {
            const result = await rpc("/web_studio/create_new_app", {
                app_name: data.appName,
                menu_name: data.menu.menuName,
                model_choice: data.menu.modelChoice,
                model_id: data.menu.modelChoice && data.menu.modelId && data.menu.modelId[0],
                model_options: data.modelOptions,
                icon: iconValue,
                context: user.context,
            });
            await this.props.onNewAppCreated(result);
        } finally {
            this.uiService.unblock();
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @param {KeyboardEvent} ev
     */
    onKeydown(ev) {
        if (
            ev.key === "Enter" &&
            !(
                ev.target.classList &&
                ev.target.classList.contains("o_web_studio_app_creator_previous")
            )
        ) {
            ev.preventDefault();
            this.state.next();
        }
    }

    /**
     * Handle the confirmation of options in the modelconfigurator
     * @param {Object} options
     */
    onConfirmOptions(options) {
        this.state.data.modelOptions = options;
        return this.state.next();
    }
}

return __exports;
});
;

/***********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector.js  *
*  Lines: 43                                                                                                           *
***********************************************************************************************************************/
odoo.define('@web_studio/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector', ['@odoo/owl', '@web/core/select_menu/select_menu', '@web_studio/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");
const { SelectMenu } = require("@web/core/select_menu/select_menu");
const { getFontAwesomeIcons } = require("@web_studio/utils");

const FontAwesomeIconSelector = __exports.FontAwesomeIconSelector = class FontAwesomeIconSelector extends Component {
    static defaultProps = {
        className: "",
        menuClassName: "",
    };
    static template = "web_studio.FontAwesomeIconSelector";
    static props = {
        className: { type: String, optional: true },
        menuClassName: { type: String, optional: true },
        value: { type: String },
        onSelect: { type: Function, optional: true },
        slots: true,
    };
    static components = { SelectMenu };

    setup() {
        this.ICONS = getFontAwesomeIcons();
    }

    get iconChoices() {
        return this.ICONS.map((icon) => {
            return {
                label: icon.searchTerms.join(" "),
                value: icon.className,
            };
        });
    }

    getIconTooltip(value) {
        return this.ICONS.find((icon) => icon.className === value).tooltip;
    }
}

return __exports;
});
;

/***************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/components/sidebar_draggable_item/sidebar_draggable_item.js  *
*  Lines: 19                                                                                                   *
***************************************************************************************************************/
odoo.define('@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");

const SidebarDraggableItem = __exports.SidebarDraggableItem = class SidebarDraggableItem extends Component {
    static template = "web_studio.SidebarDraggableItem";
    static props = {
        className: { type: String, optional: true },
        description: { type: String, optional: true },
        dropData: { optional: true },
        string: { type: String },
        structure: { type: String },
    };
}

return __exports;
});
;

/***********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/components/thumbnail_item/thumbnail_item.js  *
*  Lines: 29                                                                                   *
***********************************************************************************************/
odoo.define('@web_studio/client_action/components/thumbnail_item/thumbnail_item', ['@odoo/owl', '@web/core/dropdown/dropdown'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");
const { Dropdown } = require("@web/core/dropdown/dropdown");

const ThumbnailItem = __exports.ThumbnailItem = class ThumbnailItem extends Component {
    static defaultProps = {
        showMoreMenu: true,
        onClick: () => {},
    };
    static template = "web_studio.ThumbnailItem";
    static props = {
        className: { type: String, optional: true },
        showMoreMenu: { type: Boolean, optional: true },
        icon: { type: Object },
        onClick: { type: Function, optional: true },
        slots: true,
    };
    static components = { Dropdown };

    get hasDropdown() {
        return this.props.showMoreMenu && this.props.slots && this.props.slots.dropdown;
    }
}

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/app_menu_editor/app_menu_editor.js  *
*  Lines: 202                                                                                *
*********************************************************************************************/
odoo.define('@web_studio/client_action/editor/app_menu_editor/app_menu_editor', ['@odoo/owl', '@web/core/network/rpc', '@web/core/utils/hooks', '@web/core/dialog/dialog', '@web/core/user', '@web/core/utils/nested_sortable', '@web/views/view_dialogs/form_view_dialog', '@web_studio/client_action/menu_creator/menu_creator', '@web_studio/client_action/utils'], function (require) {
'use strict';
let __exports = {};
const { Component, useRef, useState } = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { useBus, useService, useOwnedDialogs } = require("@web/core/utils/hooks");
const { Dialog } = require("@web/core/dialog/dialog");
const { user } = require("@web/core/user");
const { useNestedSortable } = require("@web/core/utils/nested_sortable");
const { FormViewDialog } = require("@web/views/view_dialogs/form_view_dialog");
const { MenuCreatorDialog } = require("@web_studio/client_action/menu_creator/menu_creator");
const { useDialogConfirmation, useSubEnvAndServices } = require("@web_studio/client_action/utils");

const EditMenuDialogProps = { ...Dialog.props };
EditMenuDialogProps.close = { type: Function };
delete EditMenuDialogProps.slots;
class EditMenuDialog extends Component {
    static components = { Dialog };
    static template = "web_studio.AppMenuEditor.EditMenuDialog";
    static props = EditMenuDialogProps;

    setup() {
        // Keep the bus from the WebClient
        const originalBus = this.env.bus;
        useBus(originalBus, "MENUS:APP-CHANGED", () => (this.state.tree = this.getTree()));

        this.menus = useService("menu");
        this.addDialog = useOwnedDialogs();
        this.orm = useService("orm");

        useBus(this.env.bus, "ACTION_MANAGER:UPDATE", () => this.cancel());

        // States and data
        this.state = useState({ tree: {}, flatMenus: {} });
        this.state.tree = this.getTree();
        this.toMove = {};
        this.toDelete = [];

        // DragAndDrop to move menus around
        const root = useRef("root");
        useNestedSortable({
            ref: root,
            handle: ".o-draggable-handle",
            nest: true,
            maxLevels: 5,
            useElementSize: true,
            onDrop: this.moveMenu.bind(this),
        });

        const { confirm, cancel } = useDialogConfirmation({
            confirm: async () => {
                await this.saveChanges();
            },
        });
        this.confirm = confirm;
        this.cancel = cancel;
    }

    get flatMenus() {
        return this.state.flatMenus;
    }

    get mainItem() {
        return this.state.tree;
    }

    getTree() {
        let currentApp = this.menus.getCurrentApp();
        if (!currentApp) {
            return null;
        }
        currentApp = this.menus.getMenuAsTree(currentApp.id);
        const item = this._getItemFromMenu(currentApp, null);
        item.isDraggable = false;
        item.isRemovable = false;
        return item;
    }

    _getItemFromMenu(menu, parentId) {
        const item = {
            id: menu.id,
            name: menu.name,
            isDraggable: true,
            isRemovable: true,
            parentId,
        };
        item.children = menu.childrenTree.map((menu) => this._getItemFromMenu(menu, item.id));
        this.flatMenus[item.id] = item;
        return item;
    }

    moveMenu({ element, parent, previous }) {
        const menuId = parseInt(element.dataset.itemId);
        const menu = this.flatMenus[menuId];

        // Remove element from parent's children (since we are moving it, this is the mandatory first step)
        let parentMenu = this.flatMenus[menu.parentId];
        parentMenu.children = parentMenu.children.filter((m) => m.id !== menuId);

        // Determine next parent
        const parentLi = parent?.closest("li");
        const parentMenuId = parentLi ? parseInt(parentLi.dataset.itemId) : this.mainItem.id;
        if (parentMenuId !== parentMenu.id) {
            parentMenu = this.flatMenus[parentMenuId];
            menu.parentId = parentMenu.id;
        }

        // Determine at which position we should place the element
        if (previous) {
            const previousMenu = this.flatMenus[previous.dataset.itemId];
            const index = parentMenu.children.findIndex((child) => child === previousMenu);
            parentMenu.children.splice(index + 1, 0, menu);
        } else {
            parentMenu.children.unshift(menu);
        }

        // Last step: prepare the data that can be sent to the server.
        this.toMove[menuId] = {
            parent_menu_id: menu.parentId,
        };

        parentMenu.children.forEach((m, index) => {
            this.toMove[m.id] = this.toMove[m.id] || {};
            this.toMove[m.id].sequence = index + 1;
        });
    }

    removeItem(menu) {
        const parentMenu = this.flatMenus[menu.parentId];
        if (!parentMenu) {
            return;
        }
        parentMenu.children = parentMenu.children.filter((m) => m.id !== menu.id);
        this.toDelete.push(menu.id);
    }

    editItem(menu) {
        this.addDialog(FormViewDialog, {
            resModel: "ir.ui.menu",
            resId: menu.id,
            onRecordSaved: async () => {
                await this.saveChanges(true);
            },
        });
    }

    async saveChanges(reload = false) {
        if (Object.keys(this.toMove).length || this.toDelete.length) {
            await this.orm.call("ir.ui.menu", "customize", [], {
                to_move: this.toMove,
                to_delete: this.toDelete,
            });
            reload = true;
        }
        if (reload) {
            await this.menus.reload();
        }
    }

    onNewMenu() {
        this.addDialog(MenuCreatorDialog, {
            confirm: async (data) => {
                await rpc("/web_studio/create_new_menu", {
                    menu_name: data.menuName,
                    model_id: data.modelId[0],
                    model_choice: data.modelChoice,
                    model_options: data.modelOptions || {},
                    parent_menu_id: this.mainItem.id,
                    context: user.context,
                });
                this.env.bus.trigger("CLEAR-CACHES");
                this.menus.reload();
            },
        });
    }
}

const AppMenuEditor = __exports.AppMenuEditor = class AppMenuEditor extends Component {
    static props = {
        env: { type: Object },
    };
    static template = "web_studio.AppMenuEditor";

    setup() {
        this.menus = useService("menu");
        // original bus from webClient
        const bus = this.env.bus;
        // ovverride the whole env coming from within studio
        // contains an override of dialog and an override of action
        useSubEnvAndServices(this.props.env);
        this.addDialog = useOwnedDialogs();
        useBus(bus, "MENUS:APP-CHANGED", () => this.render());
    }

    onClick(ev) {
        ev.preventDefault();
        this.addDialog(EditMenuDialog);
    }
}

return __exports;
});
;

/**************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/edition_flow.js  *
*  Lines: 328                                                             *
**************************************************************************/
odoo.define('@web_studio/client_action/editor/edition_flow', ['@web/core/l10n/translation', '@web/core/network/rpc', '@odoo/owl', '@web_studio/client_action/utils', '@web/core/confirmation_dialog/confirmation_dialog', '@web/core/utils/concurrency'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { toRaw, useState, useEnv, reactive, onMounted, onWillUnmount, markRaw } = require("@odoo/owl");
const { Reactive } = require("@web_studio/client_action/utils");

const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { KeepLast } = require("@web/core/utils/concurrency");

/**
 * Provides standard shortcuts for the ActionEditor and  ViewEditor.
 * Used as a communcation interface between the editorMenu
 * and the ActionEditor or the ViewEditor
 *
 * Supports snackBar, breadcrumbs, operation stack
 */
const EditionFlow = __exports.EditionFlow = class EditionFlow extends Reactive {
    constructor(env, services) {
        super();
        this.env = env;
        for (const [servName, serv] of Object.entries(services)) {
            this[servName] = serv;
        }
        this.setup();
    }
    setup() {
        let requestId;
        const updateBreadcrumbs = (studio) => {
            if (studio.requestId !== requestId) {
                this.breadcrumbs = [];
            }
            requestId = studio.requestId;
        };
        const studio = reactive(this.studio, () => updateBreadcrumbs(studio));
        this.studio = studio;
        this.breadcrumbs = [];
        updateBreadcrumbs(studio);
    }

    pushBreadcrumb(crumb) {
        const bcLength = this.breadcrumbs.length;
        const handler = () => {
            this.breadcrumbs.length = bcLength + 1;
            // Reset studio to its own state
            // In case another action has been done
            this.studio.setParams({}, false);
        };
        this.breadcrumbs.push({ data: crumb, handler });
    }

    async loadViews({ forceSearch = false } = {}) {
        const editedAction = this.studio.editedAction;
        const { context, res_model, id } = editedAction;
        const views = [...editedAction.views];
        if (forceSearch && !views.some((tuple) => tuple[1] === "search")) {
            views.push([false, "search"]);
        }
        const newContext = { ...context, lang: false };
        const options = { loadIrFilters: true, loadActionMenus: false, id, studio: true };
        const res = await this.view.loadViews(
            { resModel: res_model, views, context: newContext },
            options
        );
        return JSON.parse(JSON.stringify(res));
    }
    restoreDefaultView(viewId, viewType) {
        return new Promise((resolve) => {
            const confirm = async () => {
                if (!viewId && viewType) {
                    // To restore the default view from an inherited one, we need first to retrieve the default view id
                    const result = await this.loadViews();
                    viewId = result.views[viewType].id;
                }
                const res = await rpc("/web_studio/restore_default_view", {
                    view_id: viewId,
                });
                this.env.bus.trigger("CLEAR-CACHES");
                resolve(res);
            };
            this.dialog.add(ConfirmationDialog, {
                body: _t(
                    "Are you sure you want to restore the default view?\r\nAll customization done with studio on this view will be lost."
                ),
                confirm,
                cancel: () => resolve(false),
            });
        });
    }
}

__exports.useEditorBreadcrumbs = useEditorBreadcrumbs; function useEditorBreadcrumbs(initialCrumb) {
    const env = useEnv();
    const editionFlow = env.editionFlow;

    if (initialCrumb && !editionFlow.breadcrumbs.length) {
        onMounted(() => editionFlow.pushBreadcrumb(initialCrumb));
    }

    const crumbs = useState(editionFlow.breadcrumbs);
    const push = (crumb) => editionFlow.pushBreadcrumb(crumb);
    return { crumbs, push };
}

__exports.useEditorMenuItem = useEditorMenuItem; function useEditorMenuItem(MenuItem) {
    const editionFlow = useEnv().editionFlow;
    onMounted(() => {
        editionFlow.MenuItem = MenuItem;
    });
    onWillUnmount(() => {
        if (toRaw(editionFlow).MenuItem === MenuItem) {
            editionFlow.MenuItem = null;
        }
    });
}

/**
 * Indicates whether a the concrete editor has finished its async operation
 * with its state: loaded/loading
 */

// PAss state instead of proms
// PAss count ? => error handling ?
// ecrase prom precedente ?
//
const SnackbarIndicator = __exports.SnackbarIndicator = class SnackbarIndicator extends Reactive {
    constructor() {
        super();
        this.state = "";
        this.keepLast = markRaw(new KeepLast());
    }

    add(prom) {
        this.state = "loading";
        const raw = this.raw();
        this.pending = Promise.all([raw.pending, prom]);

        this.keepLast
            .add(raw.pending)
            .then(() => (this.state = "loaded"))
            .catch(() => {
                this.state = "error";
            })
            .finally(() => {
                this.pending = null;
            });
        return prom;
    }
}

/**
 * A Class that manages undo/redo of some operations
 * in a sort of MutexedKeeLast: doing many calls to "do"
 * will just store the arguments and keep only the last call's results
 */
const EditorOperations = __exports.EditorOperations = class EditorOperations extends Reactive {
    constructor(params) {
        super();
        this.operations = [];
        this.undone = [];
        this._lock = "";
        this._keepLast = markRaw(new KeepLast());

        this._callbacks = {
            do: params.do,
            onError: params.onError,
            onDone: params.onDone,
        };
    }

    get canUndo() {
        return this.operations.length || (this.pending && this.pending.length);
    }

    get canRedo() {
        return this.undone.length || (this.pendingUndone && this.pendingUndone.length);
    }

    _wrapPromise(prom) {
        return this._keepLast.add(prom);
    }

    _prepare(mode) {
        const raw = this.raw();
        const lock = raw._lock;
        if (lock && lock !== mode) {
            this._wrapPromise(Promise.resolve());
            this._close();
            return false;
        }
        this._lock = mode;
        const pending = raw.pending;
        if (!pending) {
            this.pending = [...raw.operations];
            this.pendingUndone = [...raw.undone];
        }
        return true;
    }

    async _do(mode, pending, lastOp) {
        let result;
        let error;
        try {
            result = await this._wrapPromise(
                this._callbacks.do({ mode, operations: pending, lastOp })
            );
        } catch (e) {
            error = e;
        }
        if (error) {
            return { error };
        }
        return { result };
    }

    _close(done = null) {
        const raw = this.raw();
        const mode = raw._lock;
        this._lock = null;
        const pending = raw.pending;
        const pendingUndone = raw.pendingUndone;
        this.pending = null;
        this.pendingUndone = null;

        if (!done) {
            return;
        }

        if ("result" in done) {
            this.operations = pending;
            this.undone = pendingUndone;
            if (typeof done.result !== "boolean") {
                return this._callbacks.onDone({
                    mode,
                    pending,
                    pendingUndone,
                    result: done.result,
                });
            }
        }
        if ("error" in done) {
            return this._callbacks.onError({ mode, pending, error: done.error });
        }
    }

    async undo(canRedo = true) {
        if (!this._prepare("undo")) {
            this._close();
            return;
        }
        const ops = this.raw().pending;
        if (!ops || !ops.length) {
            this._close();
            return;
        }
        const op = ops.pop();
        if (canRedo) {
            this.pendingUndone.push(op);
        }
        const done = await this._do("undo", this.raw().pending, op);
        this._close(done);
    }

    pushOp(op) {
        this.operations.push(op);
    }

    async redo() {
        if (!this._prepare("redo")) {
            this._close();
            return;
        }

        const ops = this.raw().pendingUndone;
        if (!ops || !ops.length) {
            this._close();
            return;
        }
        const op = ops.pop();
        this.pending.push(op);
        const done = await this._do("do", this.raw().pending, op);
        this._close(done);
    }

    async doMulti(ops = []) {
        if (!ops.length) {
            return;
        }
        let prom;
        for (let i = 0; i < ops.length; i++) {
            let silent = true;
            if (i === ops.length - 1) {
                silent = false;
            }
            prom = this.do(ops[i], silent);
        }
        return prom;
    }

    async do(op, silent = false) {
        if (!this._prepare("do") || !op) {
            this._close();
            return;
        }
        this.pending.push(op);
        this.pendingUndone = [];
        let done = {};
        if (!silent) {
            done = await this._do("do", this.raw().pending, op);
        } else {
            done = { result: true };
        }
        this._close(done);
    }

    clear(all = true) {
        this.operations = [];
        if (all) {
            this.undone = [];
        }
    }
}

return __exports;
});
;

/********************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/editor.js  *
*  Lines: 150                                                       *
********************************************************************/
odoo.define('@web_studio/client_action/editor/editor', ['@odoo/owl', '@web/core/registry', '@web/webclient/actions/action_service', '@web/core/utils/hooks', '@web_studio/client_action/editor/studio_action_container', '@web_studio/client_action/editor/editor_menu/editor_menu', '@web_studio/client_action/editor/app_menu_editor/app_menu_editor', '@web_studio/client_action/editor/new_model_item/new_model_item', '@web_studio/client_action/editor/edition_flow', '@web_studio/studio_service', '@web_studio/client_action/utils', '@web/core/utils/objects'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { Component, EventBus, onWillDestroy, useState, useSubEnv, xml } = require("@odoo/owl");

const { registry } = require("@web/core/registry");
const { makeActionManager } = require("@web/webclient/actions/action_service");
const { useBus, useService } = require("@web/core/utils/hooks");

const { StudioActionContainer } = require("@web_studio/client_action/editor/studio_action_container");
const { EditorMenu } = require("@web_studio/client_action/editor/editor_menu/editor_menu");

const { AppMenuEditor } = require("@web_studio/client_action/editor/app_menu_editor/app_menu_editor");
const { NewModelItem } = require("@web_studio/client_action/editor/new_model_item/new_model_item");
const { EditionFlow } = require("@web_studio/client_action/editor/edition_flow");
const { useStudioServiceAsReactive } = require("@web_studio/studio_service");
const { useSubEnvAndServices, useServicesOverrides } = require("@web_studio/client_action/utils");
const { omit } = require("@web/core/utils/objects");

class DialogWithEnv extends Component {
    static template = xml`<t t-component="props.Component" t-props="componentProps" />`;
    static props = ["*"];

    setup() {
        useSubEnvAndServices(this.props.env);
    }

    get componentProps() {
        const additionalProps = omit(this.props, "Component", "env", "componentProps");
        return { ...this.props.componentProps, ...additionalProps };
    }
}
const dialogService = {
    dependencies: ["dialog"],
    start(env, { dialog }) {
        function addDialog(Component, _props, options) {
            const props = { env, Component, componentProps: _props };
            return dialog.add(DialogWithEnv, props, options);
        }
        return { ...dialog, add: addDialog };
    },
};

const actionServiceStudio = {
    dependencies: ["studio", "dialog"],
    start(env, { studio }) {
        const router = {
            current: { hash: {} },
            pushState() {},
            hideKeyFromUrl: () => {},
        };
        const action = makeActionManager(env, router);
        const _doAction = action.doAction;

        async function doAction(actionRequest, options) {
            if (actionRequest === "web_studio.action_edit_report") {
                return studio.setParams({
                    editedReport: options.report,
                });
            }
            return _doAction(...arguments);
        }

        return Object.assign(action, { doAction });
    },
};

const menuButtonsRegistry = registry.category("studio_navbar_menubuttons");
const Editor = __exports.Editor = class Editor extends Component {
    static template = "web_studio.Editor";
    static props = {};
    static components = {
        EditorMenu,
        StudioActionContainer,
    };

    static menuButtonsId = 1;
    setup() {
        const globalBus = this.env.bus;
        const newBus = new EventBus();
        useBus(globalBus, "CLEAR-UNCOMMITTED-CHANGES", (ev) =>
            newBus.trigger("CLEAR-UNCOMMITTED-CHANGES", ev.detail)
        );
        useBus(globalBus, "MENUS:APP-CHANGED", (ev) =>
            newBus.trigger("MENUS:APP-CHANGED", ev.detail)
        );
        newBus.addEventListener("CLEAR-CACHES", () => globalBus.trigger("CLEAR-CACHES"));

        useSubEnv({
            bus: newBus,
        });

        useServicesOverrides({
            dialog: dialogService,
            action: actionServiceStudio,
        });
        this.studio = useService("studio");

        const editionFlow = new EditionFlow(this.env, {
            dialog: useService("dialog"),
            studio: useStudioServiceAsReactive(),
            view: useService("view"),
        });
        useSubEnv({
            editionFlow,
        });

        this.actionService = useService("action");

        this.state = useState({ actionContainerId: 1 });
        useBus(this.studio.bus, "UPDATE", async () => {
            this.state.actionContainerId++;
        });

        // Push instance-specific components in the navbar. Because we want those elements
        // immediately, we add them at setup time, not onMounted.
        // Also, because they are Editor instance-specific, and that Destroyed is mostly called
        // after the new instance is created, we need to remove the old entries before adding the new ones
        menuButtonsRegistry.getEntries().forEach(([name]) => {
            if (name.startsWith("app_menu_editor_") || name.startsWith("new_model_item_")) {
                menuButtonsRegistry.remove(name);
            }
        });
        const menuButtonsId = this.constructor.menuButtonsId++;
        menuButtonsRegistry.add(`app_menu_editor_${menuButtonsId}`, {
            Component: AppMenuEditor,
            props: { env: this.env },
        });
        menuButtonsRegistry.add(`new_model_item_${menuButtonsId}`, { Component: NewModelItem });
        onWillDestroy(() => {
            menuButtonsRegistry.remove(`app_menu_editor_${menuButtonsId}`);
            menuButtonsRegistry.remove(`new_model_item_${menuButtonsId}`);
        });
    }

    switchView({ viewType }) {
        this.studio.setParams({ viewType, editorTab: "views" });
    }
    switchViewLegacy(ev) {
        this.studio.setParams({ viewType: ev.detail.view_type });
    }

    switchTab({ tab }) {
        this.studio.setParams({ editorTab: tab });
    }
}

return __exports;
});
;

/*************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/editor_menu/editor_menu.js  *
*  Lines: 144                                                                        *
*************************************************************************************/
odoo.define('@web_studio/client_action/editor/editor_menu/editor_menu', ['@web/core/l10n/translation', '@web/core/l10n/localization', '@web/core/registry', '@odoo/owl', '@web_studio/studio_service'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { _t } = require("@web/core/l10n/translation");
const { localization } = require("@web/core/l10n/localization");
const { registry } = require("@web/core/registry");

const { Component, useState } = require("@odoo/owl");
const { useStudioServiceAsReactive } = require("@web_studio/studio_service");
const editorTabRegistry = registry.category("web_studio.editor_tabs");

class Breadcrumbs extends Component {
    static template = "web_studio.EditorMenu.Breadcrumbs";
    static props = {
        currentTab: { type: Object },
        switchTab: Function,
    };
    setup() {
        this.editionFlow = useState(this.env.editionFlow);
        this.nextCrumbId = 1;
    }
    get breadcrumbs() {
        const currentTab = this.props.currentTab;
        const crumbs = [
            {
                data: {
                    name: currentTab.name,
                },
                handler: () => this.props.switchTab({ tab: currentTab.id }),
            },
        ];
        const breadcrumbs = this.editionFlow.breadcrumbs;
        breadcrumbs.forEach((crumb) => {
            crumbs.push(crumb);
        });
        for (const crumb of crumbs) {
            crumb.id = this.nextCrumbId++;
        }
        return crumbs;
    }
}

const EditorMenu = __exports.EditorMenu = class EditorMenu extends Component {
    static props = {
        switchTab: Function,
        switchView: Function,
    };
    static template = "web_studio.EditorMenu";
    static viewTypes = [
        {
            title: _t("Form"),
            type: "form",
            iconClasses: "fa fa-address-card",
        },
        {
            title: _t("List"),
            type: "list",
            iconClasses: "oi oi-view-list",
        },
        {
            title: _t("Kanban"),
            type: "kanban",
            iconClasses: "oi oi-view-kanban",
        },
        {
            title: _t("Map"),
            type: "map",
            iconClasses: "fa fa-map-marker",
        },
        {
            title: _t("Calendar"),
            type: "calendar",
            iconClasses: "fa fa-calendar",
        },
        {
            title: _t("Graph"),
            type: "graph",
            iconClasses: "fa fa-area-chart",
        },
        {
            title: _t("Pivot"),
            type: "pivot",
            iconClasses: "oi oi-view-pivot",
        },
        {
            title: _t("Gantt"),
            type: "gantt",
            iconClasses: "fa fa-tasks",
        },
        {
            title: _t("Cohort"),
            type: "cohort",
            iconClasses: "oi oi-view-cohort",
        },
        {
            title: _t("Activity"),
            type: "activity",
            iconClasses: "fa fa-clock-o",
        },
        {
            title: _t("Search"),
            type: "search",
            iconClasses: "oi oi-search",
        },
    ];

    static components = { Breadcrumbs };
    setup() {
        this.l10n = localization;
        this.studio = useStudioServiceAsReactive();
        this.editionFlow = useState(this.env.editionFlow);
    }

    get activeViews() {
        const action = this.studio.editedAction;
        const viewTypes = (action._views || action.views).map(([, type]) => type);
        return this.constructor.viewTypes.filter((vt) => viewTypes.includes(vt.type));
    }

    get editorTabs() {
        const entries = editorTabRegistry.getEntries();
        return entries.map((entry) => Object.assign({}, entry[1], { id: entry[0] }));
    }

    get currentTab() {
        return this.editorTabs.find((tab) => tab.id === this.studio.editorTab);
    }

    openTab(tab) {
        this.props.switchTab({ tab });
    }
}

editorTabRegistry
    .add("views", { name: _t("Views"), action: "web_studio.action_editor" })
    .add("reports", { name: _t("Reports") })
    .add("automations", { name: _t("Automations") })
    .add("automation_webhooks", { name: _t("Webhooks") })
    .add("acl", { name: _t("Access Control") })
    .add("filters", { name: _t("Filter Rules") });

return __exports;
});
;

/*******************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/new_model_item/new_model_item.js  *
*  Lines: 84                                                                               *
*******************************************************************************************/
odoo.define('@web_studio/client_action/editor/new_model_item/new_model_item', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/network/rpc', '@web/core/user', '@web/core/utils/hooks', '@web/core/dialog/dialog', '@web_studio/client_action/model_configurator/model_configurator', '@web_studio/client_action/utils'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { useBus, useService, useOwnedDialogs } = require("@web/core/utils/hooks");
const { Dialog } = require("@web/core/dialog/dialog");
const { ModelConfiguratorDialog } = require("@web_studio/client_action/model_configurator/model_configurator");
const { useDialogConfirmation } = require("@web_studio/client_action/utils");

class SimpleNewModelDialog extends Component {
    static template = "web_studio.SimpleNewModelDialog";
    static components = { Dialog };
    static props = { close: { type: Function } };

    setup() {
        this.addDialog = useOwnedDialogs();
        this.menus = useService("menu");
        this.action = useService("action");
        this.studio = useService("studio");
        this.state = useState({ modelName: "", showValidation: false });
        const { confirm, cancel } = useDialogConfirmation({
            confirm: async (data) => {
                const { menu_id, action_id } = await rpc("/web_studio/create_new_menu", {
                    menu_name: this.state.modelName,
                    model_id: false,
                    model_choice: "new",
                    model_options: data.modelOptions,
                    parent_menu_id: this.menus.getCurrentApp().id,
                    context: user.context,
                });
                await this.menus.reload();
                const action = await this.action.loadAction(action_id);
                this.menus.setCurrentMenu(menu_id);
                this.studio.setParams({ action, viewType: "form" });
            },
        });

        this._confirm = confirm;
        this._cancel = cancel;
    }

    confirm(data = {}) {
        return this._confirm(data);
    }

    onConfigureModel() {
        if (!this.state.modelName) {
            this.state.showValidation = true;
            return;
        }

        this.addDialog(ModelConfiguratorDialog, {
            confirmLabel: _t("Create Model"),
            confirm: (data) => {
                this.confirm({ modelOptions: data });
            },
        });
    }
}

const NewModelItem = __exports.NewModelItem = class NewModelItem extends Component {
    static props = {};
    static template = "web_studio.NewModelItem";

    setup() {
        this.addDialog = useOwnedDialogs();
        this.menus = useService("menu");
        this.studio = useService("studio");
        this.action = useService("action");

        useBus(this.env.bus, "MENUS:APP-CHANGED", () => this.render());
    }

    onClick(ev) {
        ev.preventDefault();
        this.addDialog(SimpleNewModelDialog);
    }
}

return __exports;
});
;

/**************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/new_view_dialogs/map_new_view_dialog.js  *
*  Lines: 49                                                                                      *
**************************************************************************************************/
odoo.define('@web_studio/client_action/editor/new_view_dialogs/map_new_view_dialog', ['@web/core/l10n/translation', '@web_studio/client_action/editor/new_view_dialogs/new_view_dialog', '@web/core/utils/hooks', '@web/core/confirmation_dialog/confirmation_dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { NewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/new_view_dialog");
const { useService } = require("@web/core/utils/hooks");
const { AlertDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const MapNewViewDialog = __exports.MapNewViewDialog = class MapNewViewDialog extends NewViewDialog {
    static template = "web_studio.MapNewViewDialog";
    static props = {
        ...NewViewDialog.props,
    };

    setup() {
        super.setup();
        this.dialog = useService("dialog");
        this.fieldsChoice = {
            res_partner: null,
        };
    }

    get viewType() {
        return "map";
    }

    computeSpecificFields(fields) {
        this.partnerFields = fields.filter(
            (field) => field.type === "many2one" && field.relation === "res.partner"
        );
        if (!this.partnerFields.length) {
            this.dialog.add(AlertDialog, {
                title: _t("Contact Field Required"),
                body: _t("Map views are based on the address of a linked Contact. You need to have a Many2one field linked to the res.partner model in order to create a map view."),
                contentClass: "o_web_studio_preserve_space",
            });
            this.props.close();
        } else {
            this.fieldsChoice.res_partner = this.partnerFields[0].name;
        }
    }
}

delete MapNewViewDialog.props.viewType;

return __exports;
});
;

/**********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/new_view_dialogs/new_view_dialog.js  *
*  Lines: 106                                                                                 *
**********************************************************************************************/
odoo.define('@web_studio/client_action/editor/new_view_dialogs/new_view_dialog', ['@web/core/l10n/translation', '@web/core/network/rpc', '@web/core/user', '@web/core/utils/hooks', '@web/core/confirmation_dialog/confirmation_dialog', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { useService } = require("@web/core/utils/hooks");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const { onWillStart } = require("@odoo/owl");

const NewViewDialog = __exports.NewViewDialog = class NewViewDialog extends ConfirmationDialog {
    static template = "web_studio.NewViewDialog";
    static GROUPABLE_TYPES = ["many2one", "char", "boolean", "selection", "date", "datetime"];
    static MEASURABLE_TYPES = ["integer", "float"];
    static props = {
        ...ConfirmationDialog.props,
        viewType: String,
    };

    setup() {
        super.setup();
        this.orm = useService("orm");
        this.studio = useService("studio");
        this.mandatoryStopDate = ["gantt", "cohort"].includes(this.viewType);

        this.title = _t("Generate %s View", this.viewType);

        this.fieldsChoice = {
            date_start: null,
            date_stop: null,
        };

        onWillStart(async () => {
            const fieldsGet = await this.orm.call(this.studio.editedAction.res_model, "fields_get");
            const fields = Object.entries(fieldsGet).map(([fName, field]) => {
                field.name = fName;
                return field;
            });
            fields.sort((first, second) => {
                if (first.string === second.string) {
                    return 0;
                }
                if (first.string < second.string) {
                    return -1;
                }
                if (first.string > second.string) {
                    return 1;
                }
            });
            this.computeSpecificFields(fields);
        });
    }

    get viewType() {
        return this.props.viewType;
    }

    /**
     * Compute date, row and measure fields.
     */
    computeSpecificFields(fields) {
        this.dateFields = [];
        this.rowFields = [];
        this.measureFields = [];
        fields.forEach((field) => {
            if (field.store) {
                // date fields
                if (field.type === "date" || field.type === "datetime") {
                    this.dateFields.push(field);
                }
                // row fields
                if (this.constructor.GROUPABLE_TYPES.includes(field.type)) {
                    this.rowFields.push(field);
                }
                // measure fields
                if (this.constructor.MEASURABLE_TYPES.includes(field.type)) {
                    // id and sequence are not measurable
                    if (field.name !== "id" && field.name !== "sequence") {
                        this.measureFields.push(field);
                    }
                }
            }
        });
        if (this.dateFields.length) {
            this.fieldsChoice.date_start = this.dateFields[0].name;
            this.fieldsChoice.date_stop = this.dateFields[0].name;
        }
    }

    async _confirm() {
        await rpc("/web_studio/create_default_view", {
            model: this.studio.editedAction.res_model,
            view_type: this.viewType,
            attrs: this.fieldsChoice,
            context: user.context,
        });
        super._confirm();
    }
}
delete NewViewDialog.props.body;

return __exports;
});
;

/*************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/studio_action_container.js  *
*  Lines: 113                                                                        *
*************************************************************************************/
odoo.define('@web_studio/client_action/editor/studio_action_container', ['@web/webclient/actions/action_container', '@web/core/utils/hooks', '@web/core/registry', '@web/core/network/rpc', '@web/core/utils/concurrency', '@odoo/owl', '@web_studio/studio_service', '@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { ActionContainer } = require("@web/webclient/actions/action_container");
const { useService } = require("@web/core/utils/hooks");
const { registry } = require("@web/core/registry");
const { rpc } = require("@web/core/network/rpc");
const { KeepLast } = require("@web/core/utils/concurrency");
const { Component, markup, onWillStart, onWillUnmount, onWillUpdateProps, xml } = require("@odoo/owl");
const { useStudioServiceAsReactive } = require("@web_studio/studio_service");
const { resetViewCompilerCache } = require("@web/views/view_compiler");

const editorTabRegistry = registry.category("web_studio.editor_tabs");

const StudioActionContainer = __exports.StudioActionContainer = class StudioActionContainer extends Component {
    static props = {
        ...ActionContainer.props,
        reloadId: { type: Number },
    };

    static template = xml`
        <t t-name="web.ActionContainer">
        <div class="o_action_manager">
            <t t-if="info.Component" t-component="info.Component" className="'o_action'" t-props="info.componentProps" t-key="info.id"/>
        </div>
        </t>`;

    setup() {
        this.actionService = useService("action");
        this.studio = useStudioServiceAsReactive();
        this.info = {};

        let actionKey = 1;
        const onUiUpdate = ({ detail: info }) => {
            this.info = info;
            actionKey++;
            this.render();
        };
        this.env.bus.addEventListener("ACTION_MANAGER:UPDATE", onUiUpdate);
        onWillUnmount(() => this.env.bus.removeEventListener("ACTION_MANAGER:UPDATE", onUiUpdate));

        const doAction = async (action, options) => {
            try {
                await this.actionService.doAction(action, options);
                this.actionKey = actionKey;
            } catch (e) {
                if (action !== "web_studio.action_editor") {
                    // Fallback on the actionEditor, except if the actionEditor crashes
                    this.studio.setParams({ editorTab: "views" });
                }
                // Rethrow anyway: the error doesn't originates from a user's action
                throw e;
            }
        };

        onWillStart(async () => {
            const action = await this.getStudioAction();
            this.studioKey = this.studio.requestId;
            doAction(action);
            await Promise.resolve();
        });

        const willUpdateKeepLast = new KeepLast();
        onWillUpdateProps(async () => {
            if (this.studio.requestId !== this.studioKey || this.actionKey !== actionKey) {
                const action = await willUpdateKeepLast.add(this.getStudioAction());
                resetViewCompilerCache();
                return new Promise((_resolve) => {
                    const resolve = () => {
                        this.env.bus.removeEventListener("ACTION_MANAGER:UPDATE", resolve);
                        _resolve();
                    };
                    this.studioKey = this.studio.requestId;
                    doAction(action, { clearBreadcrumbs: true, noEmptyTransition: true }).finally(
                        () => {
                            this.env.bus.removeEventListener("ACTION_MANAGER:UPDATE", resolve);
                        }
                    );
                    this.env.bus.addEventListener("ACTION_MANAGER:UPDATE", resolve);
                });
            }
        });
    }
    async getStudioAction() {
        const { editorTab, editedAction, editedReport, editedViewType } = this.studio;
        const tab = editorTabRegistry.get(editorTab);
        if (editorTab === "views") {
            if (editedViewType) {
                return "web_studio.view_editor";
            }
            return tab.action;
        }
        if (tab.action) {
            const action = tab.action;
            return action instanceof Function ? action(this.env) : action;
        } else if (editorTab === "reports" && editedReport) {
            return "web_studio.report_editor";
        } else {
            const action = await rpc("/web_studio/get_studio_action", {
                action_name: editorTab,
                model: editedAction.res_model,
                view_id: editedAction.view_id && editedAction.view_id[0], // Not sure it is correct or desirable
            });
            action.help = action.help && markup(action.help);
            return action;
        }
    }
}

return __exports;
});
;

/********************************************************************************
*  Filepath: /web_studio/static/src/client_action/icon_creator/icon_creator.js  *
*  Lines: 136                                                                   *
********************************************************************************/
odoo.define('@web_studio/client_action/icon_creator/icon_creator', ['@web_studio/utils', '@web/core/dropdown/dropdown', '@web/core/select_menu/select_menu', '@web/core/file_input/file_input', '@web/core/user', '@web/core/utils/hooks', '@web_studio/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { COLORS, BG_COLORS } = require("@web_studio/utils");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { SelectMenu } = require("@web/core/select_menu/select_menu");
const { FileInput } = require("@web/core/file_input/file_input");
const { user } = require("@web/core/user");
const { useService } = require("@web/core/utils/hooks");
const { FontAwesomeIconSelector } = require("@web_studio/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector");

const { Component } = require("@odoo/owl");

const DEFAULT_ICON = __exports.DEFAULT_ICON = {
    backgroundColor: BG_COLORS[0],
    color: COLORS[10],
    iconClass: "fa fa-home",
    type: "custom_icon",
};

/**
 * Icon creator
 *
 * Component which purpose is to design an app icon. It can be an uploaded image
 * which will be displayed as is, or an icon customized with the help of presets
 * of colors and icon symbols (@see web_studio/static/src/utils for the full list of colors
 * and icon classes).
 * @extends Component
 */
const IconCreator = __exports.IconCreator = class IconCreator extends Component {
    static components = {
        Dropdown,
        FileInput,
        FontAwesomeIconSelector,
        SelectMenu,
    };
    static defaultProps = DEFAULT_ICON;
    static props = {
        backgroundColor: { type: String, optional: 1 },
        color: { type: String, optional: 1 },
        editable: { type: Boolean, optional: 1 },
        iconClass: { type: String, optional: 1 },
        type: { validate: (t) => ["base64", "custom_icon"].includes(t), optional: 1 },
        uploaded_attachment_id: { type: Number, optional: 1 },
        webIconData: { type: String, optional: 1 },
        onIconChange: Function,
    };
    static template = "web_studio.IconCreator";

    /**
     * @param {Object} [props]
     * @param {string} [props.backgroundColor] Background color of the custom
     *      icon.
     * @param {string} [props.color] Color of the custom icon.
     * @param {boolean} props.editable
     * @param {string} [props.iconClass] Font Awesome class of the custom icon.
     * @param {string} props.type 'base64' (if an actual image) or 'custom_icon'.
     * @param {number} [props.uploaded_attachment_id] Databse ID of an uploaded
     *      attachment
     * @param {string} [props.webIconData] Base64-encoded string representing
     *      the icon image.
     */
    setup() {
        this.orm = useService("orm");

        this.fileInputProps = {
            acceptedFileExtensions: "image/png",
            resModel: "res.users",
            resId: user.userId,
        };
    }

    get backgroundColorChoices() {
        return this.getChoices(BG_COLORS);
    }

    get colorChoices() {
        return this.getChoices(COLORS);
    }

    getChoices(object) {
        return object.map((color) => {
            return {
                label: color,
                value: color,
            };
        });
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    onDesignIconClick() {
        this.props.onIconChange(DEFAULT_ICON);
    }

    /**
     * @param {Object[]} files
     */
    async onFileUploaded([file]) {
        if (!file) {
            // Happens when cancelling upload
            return;
        }
        const res = await this.orm.read("ir.attachment", [file.id], ["datas"]);

        this.props.onIconChange({
            type: "base64",
            uploaded_attachment_id: file.id,
            webIconData: "data:image/png;base64," + res[0].datas.replace(/\s/g, ""),
        });
    }

    /**
     * @param {string} palette
     * @param {string} value
     */
    onPaletteItemClick(palette, value) {
        if (this.props[palette] === value) {
            return; // same value
        }
        this.props.onIconChange({
            backgroundColor: this.props.backgroundColor,
            color: this.props.color,
            iconClass: this.props.iconClass,
            type: "custom_icon",
            [palette]: value,
        });
    }
}

return __exports;
});
;

/********************************************************************************
*  Filepath: /web_studio/static/src/client_action/menu_creator/menu_creator.js  *
*  Lines: 119                                                                   *
********************************************************************************/
odoo.define('@web_studio/client_action/menu_creator/menu_creator', ['@odoo/owl', '@web/core/utils/hooks', '@web/core/dialog/dialog', '@web/core/l10n/translation', '@web_studio/client_action/utils', '@web_studio/client_action/model_configurator/model_configurator', '@web/core/record_selectors/record_selector'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { useOwnedDialogs } = require("@web/core/utils/hooks");
const { Dialog } = require("@web/core/dialog/dialog");

const { _t } = require("@web/core/l10n/translation");

const { useDialogConfirmation } = require("@web_studio/client_action/utils");
const { ModelConfiguratorDialog } = require("@web_studio/client_action/model_configurator/model_configurator");
const { RecordSelector } = require("@web/core/record_selectors/record_selector");

const MenuCreatorModel = __exports.MenuCreatorModel = class MenuCreatorModel {
    constructor({ allowNoModel } = {}) {
        this.data = {
            modelId: false,
            menuName: "",
            modelChoice: "new",
        };

        // Info to select what kind of model is linked to the menu
        this.modelChoiceSelection = {
            new: _t("New Model"),
            existing: _t("Existing Model"),
        };

        if (allowNoModel) {
            this.modelChoiceSelection.parent = _t("Parent Menu");
        }
    }

    validateField(fieldName) {
        if (fieldName === "menuName") {
            return !!this.data.menuName;
        } else if (fieldName === "modelId") {
            return this.data.modelChoice === "existing" ? !!this.data.modelId : true;
        }
    }

    get isValid() {
        return ["menuName", "modelId"].every((fName) => this.validateField(fName));
    }
}

const MenuCreator = __exports.MenuCreator = class MenuCreator extends Component {
    static template = "web_studio.MenuCreator";
    static components = { RecordSelector };
    static props = {
        menuCreatorModel: { type: Object },
        showValidation: { type: Boolean, optional: true },
    };
    static defaultProps = {
        showValidation: false,
    };

    get multiRecordSelectorProps() {
        return {
            resModel: "ir.model",
            resId: this.state.data.modelId && this.state.data.modelId[0],
            update: (resId) => (this.state.data.modelId = [resId]),
            domain: [
                ["transient", "=", false],
                ["abstract", "=", false],
            ],
        };
    }

    setup() {
        this.state = useState(this.props.menuCreatorModel);
    }

    isValid(fieldName) {
        return this.props.showValidation ? this.state.validateField(fieldName) : true;
    }
}

const MenuCreatorDialog = __exports.MenuCreatorDialog = class MenuCreatorDialog extends Component {
    static template = "web_studio.MenuCreatorDialog";
    static components = { Dialog, MenuCreator };
    static props = { confirm: { type: Function }, close: { type: Function } };

    setup() {
        this.addDialog = useOwnedDialogs();
        this.menuCreatorModel = useState(new MenuCreatorModel({ allowNoModel: true }));
        this.state = useState({ showValidation: false });
        const { confirm, cancel } = useDialogConfirmation({
            confirm: async (data = {}) => {
                if (!this.menuCreatorModel.isValid) {
                    this.state.showValidation = true;
                    return false;
                }
                await this.props.confirm(data);
            },
        });
        this._confirm = confirm;
        this._cancel = cancel;
    }

    confirm(data = {}) {
        this._confirm({ ...this.menuCreatorModel.data, ...data });
    }

    onCreateNewModel() {
        if (!this.menuCreatorModel.isValid) {
            this.state.showValidation = true;
            return;
        }
        this.addDialog(ModelConfiguratorDialog, {
            confirmLabel: _t("Create Menu"),
            confirm: (data) => {
                this.confirm({ modelOptions: data });
            },
        });
    }
}

return __exports;
});
;

/********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/model_configurator/model_configurator.js  *
*  Lines: 147                                                                               *
********************************************************************************************/
odoo.define('@web_studio/client_action/model_configurator/model_configurator', ['@web/core/dialog/dialog', '@odoo/owl', '@web/core/l10n/translation', '@web/session'], function (require) {
'use strict';
let __exports = {};
const { Dialog } = require("@web/core/dialog/dialog");
const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { session } = require("@web/session");

/** You might wonder why I defined all these strings here and not in the template.
 * The reason is that I wanted clear templates that use a single element to render an option,
 * meaning that the label and helper text had to be defined here in the code.
 */
function getModelOptions() {
    const modelOptions = {
        use_partner: {
            label: _t("Contact details"),
            help: _t("Get contact, phone and email fields on records"),
            value: false,
        },
        use_responsible: {
            label: _t("User assignment"),
            help: _t("Assign a responsible to each record"),
            value: false,
        },
        use_date: {
            label: _t("Date & Calendar"),
            help: _t("Assign dates and visualize records in a calendar"),
            value: false,
        },
        use_double_dates: {
            label: _t("Date range & Gantt"),
            help: _t("Define start/end dates and visualize records in a Gantt chart"),
            value: false,
        },
        use_stages: {
            label: _t("Pipeline stages"),
            help: _t("Stage and visualize records in a custom pipeline"),
            value: false,
        },
        use_tags: {
            label: _t("Tags"),
            help: _t("Categorize records with custom tags"),
            value: false,
        },
        use_image: {
            label: _t("Picture"),
            help: _t("Attach a picture to a record"),
            value: false,
        },
        lines: {
            label: _t("Lines"),
            help: _t("Add details to your records with an embedded list view"),
            value: false,
        },
        use_notes: {
            label: _t("Notes"),
            help: _t("Write additional notes or comments"),
            value: false,
        },
        use_value: {
            label: _t("Monetary value"),
            help: _t("Set a price or cost on records"),
            value: false,
        },
        use_company: {
            label: _t("Company"),
            help: _t("Restrict a record to a specific company"),
            value: false,
        },
        use_sequence: {
            label: _t("Custom Sorting"),
            help: _t("Manually sort records in the list view"),
            value: true,
        },
        use_mail: {
            label: _t("Chatter"),
            help: _t("Send messages, log notes and schedule activities"),
            value: true,
        },
        use_active: {
            label: _t("Archiving"),
            help: _t("Archive deprecated records"),
            value: true,
        },
    };
    if (!session.display_switch_company_menu) {
        delete modelOptions.use_company;
    }
    return modelOptions;
}

const ModelConfigurator = __exports.ModelConfigurator = class ModelConfigurator extends Component {
    static template = "web_studio.ModelConfigurator";
    static components = {};
    static props = {
        embed: { type: Boolean, optional: true },
        label: { type: String },
        onConfirmOptions: Function,
        onPrevious: Function,
    };

    setup() {
        this.state = useState({ saving: false });
        this.options = useState(getModelOptions());
    }

    /**
     * Handle the confirmation of the dialog, just fires an event
     * to whoever instanciated it.
     */
    async onConfirm() {
        try {
            this.state.saving = true;

            const mappedOptions = Object.entries(this.options)
                .filter((opt) => opt[1].value)
                .map((opt) => opt[0]);

            await this.props.onConfirmOptions(mappedOptions);
        } finally {
            this.state.saving = false;
        }
    }
}

const ModelConfiguratorDialog = __exports.ModelConfiguratorDialog = class ModelConfiguratorDialog extends Component {
    static components = { Dialog, ModelConfigurator };
    static template = "web_studio.ModelConfiguratorDialog";

    static props = {
        confirm: { type: Function },
        close: { type: Function },
        confirmLabel: { type: String, optional: true },
    };

    async onConfirm(data) {
        await this.props.confirm(data);
        this.props.close();
    }

    onPrevious() {
        this.props.close();
    }
}

return __exports;
});
;

/*******************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/navbar/home_menu_customizer/home_menu_customizer.js  *
*  Lines: 103                                                                                          *
*******************************************************************************************************/
odoo.define('@web_studio/client_action/navbar/home_menu_customizer/home_menu_customizer', ['@web/core/l10n/translation', '@web/core/network/rpc', '@web/core/user', '@web/core/utils/hooks', '@web/core/browser/browser', '@web/core/confirmation_dialog/confirmation_dialog', '@web/core/file_input/file_input', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { useService } = require("@web/core/utils/hooks");
const { browser } = require("@web/core/browser/browser");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { FileInput } = require("@web/core/file_input/file_input");

const { Component } = require("@odoo/owl");

const HomeMenuCustomizer = __exports.HomeMenuCustomizer = class HomeMenuCustomizer extends Component {
    static template = "web_studio.HomeMenuCustomizer";
    static props = {};
    static components = { FileInput };

    setup() {
        this.ui = useService("ui");
        this.notification = useService("notification");
        this.company = useService("company");
        this.actionManager = useService("action");
        this.menus = useService("menu");
        this.dialogManager = useService("dialog");
    }

    setBackgroundImage(attachment_id) {
        return rpc("/web_studio/set_background_image", {
            attachment_id: attachment_id,
            context: user.context,
        });
    }
    /**
     * Export all customizations done by Studio in a zip file containing Odoo
     * modules.
     */
    exportCusto() {
        this.actionManager.doAction("web_studio.action_studio_export_wizard");
    }
    /**
     * Open a dialog allowing to import new modules
     * (e.g. exported customizations).
     */
    importCusto() {
        const action = {
            name: "Import modules",
            res_model: "base.import.module",
            views: [[false, "form"]],
            type: "ir.actions.act_window",
            target: "new",
            context: {
                dialog_size: "medium",
            },
        };
        const options = {
            onClose: () => this.menus.reload(),
        };
        this.actionManager.doAction(action, options);
    }

    async confirmReset() {
        this.ui.block();
        try {
            await rpc("/web_studio/reset_background_image", {
                context: user.context,
            });
            browser.location.reload();
        } finally {
            this.ui.unblock();
        }
    }

    resetBackground() {
        this.dialogManager.add(ConfirmationDialog, {
            body: _t("Are you sure you want to reset the background image?"),
            title: _t("Confirmation"),
            confirm: () => this.confirmReset(),
        });
    }

    async onBackgroundUpload([file]) {
        if (!file) {
            this.notification.add(_t("Could not change the background"), {
                sticky: true,
                type: "warning",
            });
        } else {
            this.ui.block();
            try {
                await this.setBackgroundImage(file.id);
                browser.location.reload();
            } finally {
                this.ui.unblock();
            }
        }
    }
}

return __exports;
});
;

/********************************************************************
*  Filepath: /web_studio/static/src/client_action/navbar/navbar.js  *
*  Lines: 77                                                        *
********************************************************************/
odoo.define('@web_studio/client_action/navbar/navbar', ['@web/core/l10n/translation', '@odoo/owl', '@web/core/registry', '@web/core/utils/hooks', '@web_enterprise/webclient/navbar/navbar', '@web_studio/client_action/navbar/home_menu_customizer/home_menu_customizer', '@web_studio/studio_service'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { onMounted, onWillUnmount } = require("@odoo/owl");

const { registry } = require("@web/core/registry");
const { useService } = require("@web/core/utils/hooks");
const { EnterpriseNavBar } = require("@web_enterprise/webclient/navbar/navbar");
const { HomeMenuCustomizer } = require("@web_studio/client_action/navbar/home_menu_customizer/home_menu_customizer");
const { useStudioServiceAsReactive, NotEditableActionError } = require("@web_studio/studio_service");

const menuButtonsRegistry = registry.category("studio_navbar_menubuttons");
const StudioNavbar = __exports.StudioNavbar = class StudioNavbar extends EnterpriseNavBar {
    static template = "web_studio.StudioNavbar";
    static components = {
        ...EnterpriseNavBar.components,
        HomeMenuCustomizer,
    };
    setup() {
        super.setup();
        this.studio = useStudioServiceAsReactive();
        this.actionManager = useService("action");
        this.dialogManager = useService("dialog");
        this.notification = useService("notification");
        onMounted(() => {
            this.env.bus.removeEventListener("HOME-MENU:TOGGLED", this._busToggledCallback);
            this._updateMenuAppsIcon();
        });

        const onMenuButtonsUpdate = () => this.render();
        menuButtonsRegistry.addEventListener("UPDATE", onMenuButtonsUpdate);
        onWillUnmount(() => menuButtonsRegistry.removeEventListener("UPDATE", onMenuButtonsUpdate));
    }
    onMenuToggle() {
        this.studio.toggleHomeMenu();
    }
    closeStudio() {
        this.studio.leave();
    }
    async onNavBarDropdownItemSelection(menu) {
        if (menu.actionID) {
            try {
                await this.studio.open(this.studio.MODES.EDITOR, menu.actionID);
            } catch (e) {
                if (e instanceof NotEditableActionError) {
                    const options = { type: "danger" };
                    this.notification.add(_t("This action is not editable by Studio"), options);
                    return;
                }
                throw e;
            }
        }
    }
    get hasBackgroundAction() {
        return this.studio.editedAction || this.studio.MODES.APP_CREATOR === this.studio.mode;
    }
    get isInApp() {
        return this.studio.mode === this.studio.MODES.EDITOR;
    }
    get menuButtons() {
        return Object.fromEntries(menuButtonsRegistry.getEntries());
    }
    _updateMenuAppsIcon() {
        super._updateMenuAppsIcon();
        const menuAppsEl = this.menuAppsRef.el;
        menuAppsEl.classList.toggle(
            "o_menu_toggle_studio_app_creator_back",
            this.studio.MODES.APP_CREATOR === this.studio.mode
        );
    }
}

return __exports;
});
;

/**********************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/error_display.js  *
*  Lines: 40                                                                      *
**********************************************************************************/
odoo.define('@web_studio/client_action/report_editor/error_display', ['@odoo/owl', '@web/core/browser/router', '@web/core/utils/hooks', '@web_studio/client_action/report_editor/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, onWillRender, useState } = require("@odoo/owl");
const { stateToUrl } = require("@web/core/browser/router");
const { useService } = require("@web/core/utils/hooks");
const { humanReadableError } = require("@web_studio/client_action/report_editor/utils");

const ErrorDisplay = __exports.ErrorDisplay = class ErrorDisplay extends Component {
    static template = "web_studio.ErrorDisplay";
    static props = { error: Object };

    setup() {
        this.state = useState({ showTrace: false });
        this.action = useService("action");
        onWillRender(() => {
            this.error = humanReadableError(this.props.error);
        });
    }
    openRecord(resModel, resId) {
        const action = {
            type: "ir.actions.act_window",
            target: "new",
            res_model: resModel,
            res_id: resId,
            views: [[false, "form"]],
            context: {
                studio: "0",
            },
        };
        this.action.doAction(action);
    }
    urlFor(model, resId, viewType = "form") {
        return stateToUrl({ action: "base.action_ui_view", model, resId });
    }
}

return __exports;
});
;

/**********************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor.js  *
*  Lines: 46                                                                      *
**********************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor', ['@odoo/owl', '@web/core/registry', '@web_studio/client_action/report_editor/report_editor_model', '@web_studio/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg', '@web_studio/client_action/report_editor/report_editor_xml/report_editor_xml', '@web_studio/client_action/report_editor/utils', '@web/webclient/actions/action_service'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");
const { registry } = require("@web/core/registry");

const { useReportEditorModel } = require("@web_studio/client_action/report_editor/report_editor_model");
const { ReportEditorWysiwyg } = require("@web_studio/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg");
const { ReportEditorXml } = require("@web_studio/client_action/report_editor/report_editor_xml/report_editor_xml");

const { getCssFromPaperFormat } = require("@web_studio/client_action/report_editor/utils");
const { standardActionServiceProps } = require("@web/webclient/actions/action_service");

class ReportEditor extends Component {
    static template = "web_studio.ReportEditor";
    static components = { ReportEditorWysiwyg, ReportEditorXml };
    static props = { ...standardActionServiceProps };

    setup() {
        this.reportEditorModel = useReportEditorModel();
    }

    get paperFormatStyle() {
        const {
            margin_top,
            margin_left,
            margin_right,
            print_page_height,
            print_page_width,
            header_spacing,
        } = this.reportEditorModel.paperFormat;
        const marginTop = Math.max(0, (margin_top || 0) - (header_spacing || 0));
        return getCssFromPaperFormat({
            margin_top: marginTop,
            margin_left,
            margin_right,
            print_page_height,
            print_page_width,
        });
    }
}
registry.category("actions").add("web_studio.report_editor", ReportEditor);

return __exports;
});
;

/*****************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_iframe.js  *
*  Lines: 124                                                                            *
*****************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_iframe', ['@odoo/owl', '@web_studio/client_action/report_editor/utils', '@web/core/utils/timing', '@web_studio/client_action/report_editor/error_display'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, useRef, useState } = require("@odoo/owl");
const { getCssFromPaperFormat } = require("@web_studio/client_action/report_editor/utils");
const { useThrottleForAnimation } = require("@web/core/utils/timing");
const { ErrorDisplay } = require("@web_studio/client_action/report_editor/error_display");

const ReportEditorIframe = __exports.ReportEditorIframe = class ReportEditorIframe extends Component {
    static components = { ErrorDisplay };
    static template = "web_studio.ReportEditor.Iframe";
    static props = {
        iframeKey: String,
        iframeSource: String,
        onIframeLoaded: Function,
    };

    setup() {
        this.reportEditorModel = useState(this.env.reportEditorModel);
        this.iframeRef = useRef("iframeRef");
        this.onContainerScroll = useThrottleForAnimation(() => {
            if (this.iframeRef.el?.contentDocument) {
                this.iframeRef.el.contentDocument.dispatchEvent(new Event("scroll"));
            }
        });
    }

    get paperFormatStyle() {
        const {
            margin_top,
            margin_left,
            margin_right,
            print_page_height,
            print_page_width,
            header_spacing,
        } = this.reportEditorModel.paperFormat;
        const marginTop = Math.max(0, (margin_top || 0) - (header_spacing || 0));
        return getCssFromPaperFormat({
            margin_top: marginTop,
            margin_left,
            margin_right,
            print_page_height,
            print_page_width,
        });
    }
    get iframeStyle() {
        const { print_page_height } = this.reportEditorModel.paperFormat;
        return getCssFromPaperFormat({ print_page_height });
    }

    get iframeSource() {
        return this.props.iframeSource;
    }

    get iframeKey() {
        return this.reportEditorModel.renderKey + "_" + (this.props.iframeKey || "");
    }

    async onIframeLoaded() {
        await this.resizeIframeContent({ iframeRef: this.iframeRef });
        this.props.onIframeLoaded({ iframeRef: this.iframeRef });
    }

    async resizeIframeContent({ iframeRef }) {
        const paperFormat = this.reportEditorModel.paperFormat;
        const iframeEl = iframeRef.el;
        const iframeContent = iframeEl.contentDocument;

        // zoom content from 96 (default browser DPI) to paperformat DPI
        const zoom = 96 / paperFormat.dpi;
        Array.from(iframeContent.querySelector("main")?.children || []).forEach((el) => {
            let sectionZoom = zoom;
            if (!paperFormat.disable_shrinking) {
                const { width } = el.getBoundingClientRect();
                sectionZoom = Math.min(zoom, width / el.scrollWidth);
            }
            el.setAttribute("oe-origin-style", el.getAttribute("style") || "");
            el.style.setProperty("zoom", sectionZoom);
        });
        // WHY --> so that after the load of the iframe, if there are images,
        // the iframe height is recomputed to the height of the content images included
        const computeIframeHeight = () =>
            (iframeEl.style.height = iframeContent.body.scrollHeight + "px");
        //computeIframeHeight();

        // TODO: it seems that the paperformat doesn't exactly do that
        // this.$content.find('.header').css({
        //     'margin-bottom': (this.paperFormat.header_spacing || 0) + 'mm',
        // });
        // TODO: won't be pretty if the content is larger than the format

        const footer = iframeContent.querySelector(".footer");
        const footerStyle = footer?.style;
        if (footerStyle) {
            const { width } = iframeContent.querySelector(".page")?.getBoundingClientRect() || {};
            if (!footer.hasAttribute("oe-origin-style")) {
                footer.setAttribute("oe-origin-style", footer.getAttribute("style") || "");
            }
            if (width) {
                footerStyle.setProperty("width", `${width}px`);
            }
        }

        iframeContent.querySelector("html").style.overflow = "hidden";

        // set the size of the iframe
        const proms = [];
        Array.from(iframeContent.querySelectorAll("img[src]") || []).forEach((img) => {
            if (img.complete) {
                return;
            }
            const prom = new Promise((resolve) => {
                img.onload = resolve;
            });
            proms.push(prom);
        });
        await Promise.all(proms);
        computeIframeHeight();
    }
}

return __exports;
});
;

/****************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_model.js  *
*  Lines: 411                                                                           *
****************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_model', ['@web_studio/client_action/utils', '@odoo/owl', '@web/core/network/rpc', '@web/core/utils/hooks', '@web/core/utils/objects', '@web/core/l10n/translation', '@web/core/user', '@web_studio/client_action/editor/edition_flow', '@web/core/utils/concurrency', '@web/core/utils/render', '@web/model/relational_model/utils', '@web_studio/client_action/report_editor/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Reactive } = require("@web_studio/client_action/utils");
const {
    EventBus,
    markRaw,
    onWillStart,
    reactive,
    toRaw,
    useEnv,
    useState,
    useSubEnv,
    onWillDestroy,
} = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { useService } = require("@web/core/utils/hooks");
const { omit, pick } = require("@web/core/utils/objects");
const { _t } = require("@web/core/l10n/translation");
const { user } = require("@web/core/user");
const { useEditorBreadcrumbs } = require("@web_studio/client_action/editor/edition_flow");
const { KeepLast } = require("@web/core/utils/concurrency");
const { renderToMarkup } = require("@web/core/utils/render");
const { makeActiveField } = require("@web/model/relational_model/utils");
const { humanReadableError } = require("@web_studio/client_action/report_editor/utils");

const notificationErrorTemplate = "web_studio.ReportEditor.NotificationError";
const errorQweb = `<html><div>The report could not be rendered due to an error</div><html>`;

const ReportEditorModel = __exports.ReportEditorModel = class ReportEditorModel extends Reactive {
    constructor({ services, debug }) {
        super();
        this.debug = debug;
        this.bus = markRaw(new EventBus());
        this.mode = "wysiwyg";
        this.warningMessage = "";
        this._isDirty = false;
        this._isInEdition = false;
        this._services = markRaw(services);
        this._errorMessage = false;
        this.paperFormat = {
            margin_top: 0,
            margin_left: 0,
            margin_right: 0,
            print_page_width: 210,
            print_page_height: 297,
        };
        this.reportFields = markRaw({
            id: { name: "id", type: "number" },
            name: { name: "name", type: "char" },
            model: { name: "model", type: "char" },
            report_name: { name: "report_name", type: "char" },
            groups_id: {
                name: "groups_id",
                type: "many2many",
                relation: "res.groups",
                relatedFields: {
                    display_name: { type: "char" },
                },
            },
            paperformat_id: {
                name: "paperformat_id",
                type: "many2one",
                relation: "report.paperformat",
            },
            binding_model_id: { name: "binding_model_id", type: "many2one", relation: "ir.model" },
            attachment_use: { name: "attachment_use", type: "boolean" },
            attachment: { name: "attachment", type: "char" },
            // fake field
            display_in_print_menu: { name: "display_in_print_menu", type: "boolean" },
        });
        this.reportActiveFields = markRaw({
            id: makeActiveField(),
            name: makeActiveField(),
            model: makeActiveField(),
            report_name: makeActiveField(),
            groups_id: {
                ...makeActiveField(),
                related: {
                    fields: { display_name: { name: "display_name", type: "char" } },
                    activeFields: { display_name: makeActiveField() },
                },
            },
            paperformat_id: makeActiveField(),
            binding_model_id: makeActiveField(),
            attachment_use: makeActiveField(),
            attachment: makeActiveField(),
            // fake field
            display_in_print_menu: makeActiveField(),
        });
        this.reportEnv = {};
        this.loadHtmlKeepLast = markRaw(new KeepLast());

        this._reportArchs = {};
        this.renderKey = 1;
        this.routesContext = pick(user.context, "allowed_company_ids");
    }

    get reportData() {
        return this._reportChanges || this._reportData;
    }

    set reportData(_data) {
        const fields = this.reportFields;
        const data = { ..._data };
        for (const [fName, value] of Object.entries(data)) {
            const field = fields[fName];
            if (field.type === "many2many") {
                data[fName] = [...value.currentIds];
            }
        }
        this._reportChanges = data;
    }

    get reportResModel() {
        return this._reportData.model;
    }

    get recordToDisplay() {
        return this.reportEnv.currentId || this.reportEnv.ids.find((i) => !!i) || false;
    }

    get editedReportId() {
        return this._services.studio.editedReport.res_id;
    }

    get reportQweb() {
        return this._reportArchs.reportQweb;
    }

    get reportHtml() {
        return this._reportArchs.reportHtml;
    }

    get isDirty() {
        return this._reportChanges || this._isDirty;
    }

    set isDirty(bool) {
        this._isDirty = bool;
    }

    get isInEdition() {
        return this._isInEdition;
    }

    get fullErrorDisplay() {
        return this.debug ? this._errorMessage : false;
    }

    setInEdition(value) {
        // Reactivity limitation: if we used a setter, the reactivity will trigger the getter
        // thus subscribing us to the key. This is not what we want here.
        value = !!value; // enforce boolean
        if (reactive(this)._isInEdition === value) {
            return;
        }
        this._isInEdition = value;
        if (value) {
            this._services.ui.block();
        } else {
            this._services.ui.unblock();
        }
    }

    _resetInternalArchs() {
        // We do this by explicitly bypassing reactivity, we don't want any re-render doing this.
        // _reportsArchs acts as flag, meaning that if one of the arch is not present
        // the relevant function will fetch them. see @loadReportQweb and @loadReportHtml
        toRaw(this)._reportArchs = {};
    }

    async loadReportEditor() {
        const loaders = [this.loadReportData.bind(this), this.loadModelEnv.bind(this)];
        for (const loader of loaders) {
            if (this.isDestroyed) {
                break;
            }
            await loader();
        }
    }

    async loadReportData() {
        // FIXME introduce alive?
        const data = await rpc("/web_studio/load_report_editor", {
            report_id: this.editedReportId,
            fields: Object.keys(omit(this.reportActiveFields, "display_in_print_menu")),
            context: this.routesContext,
        });
        this._reportData = this._parseFakeFields(data.report_data);
        Object.assign(this.paperFormat, data.paperformat);

        this._errorMessage = data.qweb_error;
        this._reportArchs.reportQweb = data.report_qweb || errorQweb;
        this._isLoaded = true;
    }

    async loadReportQweb() {
        if (!this._isLoaded) {
            return;
        }
        if (this._reportArchs.reportQweb) {
            return;
        }

        try {
            const reportQweb = await this.loadHtmlKeepLast.add(
                rpc("/web_studio/get_report_qweb", {
                    report_id: this.editedReportId,
                    context: this.routesContext,
                })
            );
            this._errorMessage = false;
            this._reportArchs.reportQweb = reportQweb;
        } catch (e) {
            this._errorMessage = e;
            this._reportArchs.reportQweb = errorQweb;
        }
        this.setInEdition(false);
    }

    async loadReportHtml({ resId } = {}) {
        if (!this._isLoaded) {
            return;
        }
        if (resId === undefined && this._reportArchs.reportHtml) {
            return;
        }
        this.reportEnv.currentId = resId !== undefined ? resId : this.reportEnv.currentId;
        try {
            const reportHtml = await this.loadHtmlKeepLast.add(
                rpc("/web_studio/get_report_html", {
                    report_id: this.editedReportId,
                    record_id: this.reportEnv.currentId || 0,
                    context: this.routesContext,
                })
            );
            this._errorMessage = false;
            this._reportArchs.reportHtml = reportHtml;
        } catch (e) {
            this._errorMessage = e;
            this._reportArchs.reportHtml = errorQweb;
        }
        this.setInEdition(false);
    }

    async saveReport({ htmlParts, urgent, xmlVerbatim } = {}) {
        const hasPartsToSave = htmlParts && Object.keys(htmlParts).length;
        const hasVerbatimToSave = xmlVerbatim && Object.keys(xmlVerbatim).length;
        const hasDataToSave = this.isDirty;
        this.warningMessage = "";
        if (hasVerbatimToSave && hasPartsToSave) {
            throw new Error(_t("Saving both some report's parts and full xml is not permitted."));
        }
        if (this._errorMessage && hasPartsToSave) {
            throw new Error(
                _t("The report is in error. Only editing the XML sources is permitted")
            );
        }
        if (!hasVerbatimToSave && !hasPartsToSave && !hasDataToSave) {
            return;
        }
        if (!urgent) {
            this.setInEdition(true);
        }

        let result;
        try {
            result = await rpc(
                "/web_studio/save_report",
                {
                    report_id: this.editedReportId,
                    report_changes: this._reportChanges || null,
                    html_parts: htmlParts || null,
                    xml_verbatim: xmlVerbatim || null,
                    record_id: this.reportEnv.currentId || null,
                    context: this.routesContext,
                },
                { silent: urgent }
            );
            this._errorMessage = false;
        } catch (e) {
            this.setInEdition(false);
            const message = renderToMarkup(notificationErrorTemplate, {
                reportName: this._reportData.name,
                recordId: this.reportEnv.currentId,
                error: humanReadableError(e),
            });
            this._services.unProtectedNotification.add(message, {
                type: "warning",
                title: _t("Report edition failed"),
            });
            this.warningMessage = _t("Report edition failed");

            if (this._errorMessage) {
                this._errorMessage = e;
            }

            return false;
        }

        if (hasPartsToSave || hasVerbatimToSave) {
            this._resetInternalArchs();
        }
        const { report_data, paperformat, report_html, report_qweb } = result || {};
        if (!urgent && report_data) {
            this._reportData = this._parseFakeFields(report_data);
            this._reportChanges = null;
            this.paperFormat = paperformat;
        }

        this.isDirty = false;
        if (!urgent) {
            this._reportArchs.reportHtml = report_html;
            this._reportArchs.reportQweb = report_qweb;
        }
        this.setInEdition(false);
    }

    discardReport() {
        this.setInEdition(true);
        this.warningMessage = "";
        this.isDirty = false;
        this.renderKey++;
    }

    /**
     * Load and set the report environment.
     *
     * If the report is associated to the same model as the Studio action, the
     * action ids will be used ; otherwise a search on the report model will be
     * performed.
     *
     * @private
     * @returns {Promise}
     */
    async loadModelEnv() {
        if (this.reportEnv.ids) {
            return;
        }
        const modelName = this.reportResModel;
        const result = await this._services.orm.search(modelName, this.getModelDomain(), {
            context: user.context,
        });

        this.reportEnv = {
            ids: result,
            currentId: result[0] || false,
        };
    }

    getModelDomain() {
        // TODO: Since 13.0, journal entries are also considered as 'account.move',
        // therefore must filter result to remove them; otherwise not possible
        // to print invoices and hard to lookup for them if lot of journal entries.
        const modelName = this.reportResModel;
        let domain = [];
        if (modelName === "account.move") {
            domain = [["move_type", "!=", "entry"]];
        }
        return domain;
    }

    async resetReport(includeHeaderFooter = true) {
        this.setInEdition(true);
        await rpc("/web_studio/reset_report_archs", {
            report_id: this.editedReportId,
            include_web_layout: includeHeaderFooter,
        });

        this._resetInternalArchs();
        await this.loadReportQweb();
    }

    _parseFakeFields(reportData) {
        reportData.display_in_print_menu = !!reportData.binding_model_id;
        return reportData;
    }
}

__exports.useReportEditorModel = useReportEditorModel; function useReportEditorModel() {
    const services = Object.fromEntries(
        ["orm", "ui"].map((name) => {
            return [name, useService(name)];
        })
    );
    const env = useEnv();
    services.studio = { ...env.services.studio };
    services.unProtectedNotification = env.services.notification;
    const reportEditorModel = new ReportEditorModel({ services, debug: env.debug });
    useSubEnv({ reportEditorModel });

    function getName(rem) {
        return rem.reportData?.name;
    }
    const crumb = reactive({});
    const rem = reactive(reportEditorModel, () => {
        crumb.name = getName(rem);
    });
    crumb.name = getName(rem);
    useEditorBreadcrumbs(crumb);

    onWillStart(() => reportEditorModel.loadReportEditor());
    onWillDestroy(() => reportEditorModel.isDestroyed = true);

    return useState(reportEditorModel);
}

return __exports;
});
;

/*******************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_snackbar.js  *
*  Lines: 17                                                                               *
*******************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_snackbar', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");

const ReportEditorSnackbar = __exports.ReportEditorSnackbar = class ReportEditorSnackbar extends Component {
    static template = "web_studio.ReportEditor.SnackBar";
    static props = {
        onSave: Function,
        state: Object,
        onDiscard: { type: Function, optional: true },
    };
}

return __exports;
});
;

/************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_wysiwyg/qweb_table_plugin.js  *
*  Lines: 516                                                                                               *
************************************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_wysiwyg/qweb_table_plugin', ['@html_editor/plugin', '@html_editor/utils/dom_traversal', '@odoo/owl', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/l10n/translation', '@web_studio/client_action/report_editor/utils'], function (require) {
'use strict';
let __exports = {};
const { Plugin } = require("@html_editor/plugin");
const { closestElement } = require("@html_editor/utils/dom_traversal");
const { Component, reactive } = require("@odoo/owl");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { _t } = require("@web/core/l10n/translation");
const { visitNode } = require("@web_studio/client_action/report_editor/utils");

/**
 * @typedef {Object} CellInfo
 * @property {number} length
 * @property {number} cellIndex
 */

class TableMenu extends Component {
    static template = "html_editor.TableMenu";
    static props = {
        type: String, // column or row
        overlay: Object,
        dropdownState: Object,
        target: { validate: (el) => el.nodeType === Node.ELEMENT_NODE },
        editable: { validate: (el) => el.nodeType === Node.ELEMENT_NODE },
        addColumn: Function,
        removeColumn: Function,
    };
    static components = { Dropdown, DropdownItem };

    setup() {
        this.items = this.props.type === "column" ? this.colItems() : [];
    }

    colItems() {
        return [
            {
                name: "insert_left",
                icon: "fa-plus",
                text: _t("Insert left"),
                action: this.insertColumn.bind(this, "before"),
            },
            {
                name: "insert_right",
                icon: "fa-plus",
                text: _t("Insert right"),
                action: this.insertColumn.bind(this, "after"),
            },
            {
                name: "delete",
                icon: "fa-trash",
                text: _t("Delete"),
                action: this.deleteColumn.bind(this),
            },
        ];
    }

    insertColumn(position, target) {
        this.props.addColumn({ position, reference: target });
        this.props.editable.focus();
    }

    deleteColumn(target) {
        this.props.removeColumn({ cell: target });
        this.props.editable.focus();
    }
    onSelected(item) {
        item.action(this.props.target);
        this.props.overlay.close();
    }
}

function setColspan(cell, colspan) {
    if (colspan < 1) {
        return;
    }
    if (colspan === 1) {
        cell.removeAttribute("colspan");
    } else {
        cell.setAttribute("colspan", `${colspan}`);
    }
}

function setStyleProperty(element, name, value) {
    const style = element.style;
    if (value === undefined) {
        style.removeProperty(name);
        if (!style.length) {
            element.removeAttribute("style");
        }
    } else {
        style.setProperty(name, value);
    }
}

function* getAllConditionalBlocks(el) {
    const previousBlocks = [...iterConditionalSiblings(el, true)];
    for (let index = previousBlocks.length - 1; index >= 0; index--) {
        const _el = previousBlocks[index];
        if (_el !== el) {
            yield _el;
        }
    }
    yield* iterConditionalSiblings(el);
}

function* iterConditionalSiblings(el, reverse = false) {
    const condition = ["t-if", "t-elif", "t-else"].find((attr) => el.hasAttribute(attr));
    if (!condition) {
        return;
    }
    const next = reverse ? "previousElementSibling" : "nextElementSibling";
    let includeTif = reverse ? true : condition === "t-if";
    while (el) {
        if (el.hasAttribute("t-if")) {
            if (includeTif && reverse) {
                yield el;
                return;
            }
            if (!includeTif) {
                return;
            }
            if (includeTif) {
                yield el;
                includeTif = false;
            }
        } else {
            yield el;
        }
        const sibl = el[next];
        el =
            sibl && ["t-if", "t-elif", "t-else"].some((attr) => sibl.hasAttribute(attr))
                ? sibl
                : null;
    }
}

const CELL_TAGS = ["Q-TH", "Q-TD"];
const CSS_COL_COUNT_PROP = "--q-table-col-count";
const CSS_COL_SIZE_PROP = "--q-cell-col-size";
const QWebTablePlugin = __exports.QWebTablePlugin = class QWebTablePlugin extends Plugin {
    static id = "qweb_table_plugin";
    static dependencies = ["baseContainer", "overlay", "selection", "history"];
    resources = {
        clean_for_save_handlers: ({ root }) => this.clean(root),
        normalize_handlers: this.normalize.bind(this),
    };

    setup() {
        for (const table of this.editable.querySelectorAll("q-table")) {
            visitNode(table, (node) => {
                if (node.tagName !== "T") {
                    node.classList.add("oe_unbreakable");
                }
                return !CELL_TAGS.includes(node.tagName);
            });
        }
        /** @type {import("@html_editor/core/overlay_plugin").Overlay} */
        this.colMenu = this.dependencies.overlay.createOverlay(
            TableMenu,
            {
                positionOptions: {
                    position: "top-fit",
                    offsetY: 0,
                },
            },
            { sequence: 30 }
        );

        this.isMenuOpened = false;
        const closeMenus = () => {
            if (this.isMenuOpened) {
                this.isMenuOpened = false;
                this.colMenu.close();
            }
        };
        this.addDomListener(this.document, "scroll", closeMenus, true);
        this.addDomListener(this.document, "pointermove", this.onMouseMove);
    }

    onMouseMove(ev) {
        const target = ev.target;
        if (this.isMenuOpened) {
            return;
        }
        if (
            CELL_TAGS.includes(target.tagName) &&
            target !== this.activeTd &&
            this.editable.contains(target)
        ) {
            if (ev.target.isContentEditable) {
                this.setActiveTd(target);
            }
        } else if (this.activeTd) {
            const isOverlay = target.closest(".o-overlay-container");
            if (isOverlay) {
                return;
            }
            const parentTd = closestElement(target, (el) => CELL_TAGS.includes(el.tagName));
            if (!parentTd) {
                this.setActiveTd(null);
            }
        }
    }

    setActiveTd(td) {
        this.activeTd = td;
        this.colMenu.close();
        if (!td) {
            return;
        }
        const table = closestElement(td, "q-table");
        if (table.querySelector("q-tr").contains(td)) {
            this.colMenu.open({
                target: td,
                props: {
                    editable: this.editable,
                    type: "column",
                    overlay: this.colMenu,
                    target: td,
                    dropdownState: this.createDropdownState(),
                    addColumn: this.addColumn.bind(this),
                    removeColumn: this.removeColumn.bind(this),
                },
            });
        }
    }

    createDropdownState(menuToClose) {
        const dropdownState = reactive({
            isOpen: false,
            open: () => {
                dropdownState.isOpen = true;
                menuToClose?.close();
                this.isMenuOpened = true;
            },
            close: () => {
                dropdownState.isOpen = false;
                this.isMenuOpened = false;
            },
        });
        return dropdownState;
    }

    addColumn(payload) {
        const insertedCells = this._addColumn(payload);
        this.dependencies.selection.setCursorStart(insertedCells[0]);
        this.dependencies.history.addStep();
    }

    _addColumn({ position, reference }) {
        const table = closestElement(reference, "q-table");

        const { cells } = new TableSizeComputer().compute(table);
        const { cellIndex, length } = cells.get(reference);
        const insertedCells = [];
        const done = new Set();
        for (const cellEl of cells.keys()) {
            let target = cellEl;
            for (const condition of iterConditionalSiblings(target, position === "before")) {
                target = condition;
            }
            if (done.has(target)) {
                continue;
            }
            done.add(target);
            const cellInfo = cells.get(target);
            if (cellInfo.cellIndex === cellIndex && cellInfo.length === length) {
                const newTd = this.createElementFrom(cellEl);
                target.insertAdjacentElement(
                    position === "before" ? "beforebegin" : "afterend",
                    newTd
                );
                insertedCells.push(newTd);
                continue;
            }
            if (TableSizeComputer.areOverlappingCellInfo(cellInfo, { cellIndex, length })) {
                const colspan = parseInt(target.getAttribute("colspan") || "1") + 1;
                setColspan(target, colspan);
                continue;
            }
        }
        this._normalize(table);
        return insertedCells;
    }

    clean(element) {
        const cleanTableNode = (node) => {
            if (node.tagName === "Q-TABLE") {
                setStyleProperty(node, CSS_COL_COUNT_PROP, undefined);
            }
            const isCell = CELL_TAGS.includes(node.tagName);
            if (isCell) {
                setStyleProperty(node, CSS_COL_SIZE_PROP, undefined);
            }
            node.classList.remove("oe_unbreakable");
            if (node.classList.length === 0) {
                node.removeAttribute("class");
            }
            return !isCell;
        };

        for (const table of element.querySelectorAll("q-table")) {
            visitNode(table, cleanTableNode);
        }
    }

    removeColumn(payload) {
        const table = closestElement(payload.cell, "q-table");
        this._removeColumn(payload);
        const firstCell = table.querySelector(CELL_TAGS.join(","));
        this.dependencies.selection.setCursorEnd(firstCell);
        this.dependencies.history.addStep();
    }

    _removeColumn({ cell }) {
        const table = closestElement(cell, "q-table");

        const { cells } = new TableSizeComputer().compute(table);
        const { cellIndex, length } = cells.get(cell);
        const removedCells = [];
        const done = new Set();
        for (const cellEl of cells.keys()) {
            if (done.has(cellEl)) {
                continue;
            }
            const cellInfo = cells.get(cellEl);

            if (cellIndex === cellInfo.cellIndex && length === cellInfo.length) {
                for (const removed of this._removeCell(cellEl)) {
                    removedCells.push(removed);
                    done.add(removed);
                }
                continue;
            }
            if (TableSizeComputer.areOverlappingCellInfo(cellInfo, { length, cellIndex })) {
                const colspan = parseInt(cellEl.getAttribute("colspan") || "1") - 1;
                if (colspan === 0) {
                    for (const removed of this._removeCell(cellEl)) {
                        removedCells.push(removed);
                        done.add(removed);
                    }
                    continue;
                }
                setColspan(cellEl, colspan);
            }
        }
        this._normalize(table);
        return removedCells;
    }

    _removeCell(cellEl) {
        const toRemove = [...getAllConditionalBlocks(cellEl)];
        if (!toRemove.length) {
            toRemove.push(cellEl);
        }
        for (const _el of toRemove) {
            _el.remove();
        }
        return toRemove;
    }

    createElementFrom(fromElement) {
        const tagName = fromElement.tagName.toLowerCase();
        const newElement = this.document.createElement(tagName);
        const baseContainer = this.dependencies.baseContainer.createBaseContainer();
        baseContainer.append(this.document.createElement("br"));
        newElement.append(baseContainer);
        newElement.classList.add("oe_unbreakable");
        return newElement;
    }

    normalize(el) {
        for (const table of el.querySelectorAll("q-table")) {
            this._normalize(table);
        }
    }
    _normalize(table) {
        const { cells, baseLineRow } = new TableSizeComputer().compute(table);

        setStyleProperty(table, CSS_COL_COUNT_PROP, `${baseLineRow.length}`);
        for (const [cellEl, info] of cells.entries()) {
            setStyleProperty(
                cellEl,
                CSS_COL_SIZE_PROP,
                info.length === 1 ? undefined : `${info.length}`
            );
        }
    }
}

/**
 * Recursively traverses a table-like tree in order to compute each cell's start position and length (colspan)
 * It stops traversing when encountering a table cell (q-th, q-td)
 * It handles qweb conditions (t-if/t-elif/t-else).
 * The algo goes:
 * - start traversing the table depth first.
 * - when encountering a row (q-tr), reset cellIndex and cellCount to 0
 * - when encountering a cell (q-td, q-th), increment cellIndex and cellCount
 * - don't traverse the cell itself
 * - a cell can have a colspan, increment cellIndex accordingly
 * - when encoutering a t-if: stop temporarly the depth first traversal
 * - store counters
 * - count cells in each mutually exclusive branch
 * - set counters to the maximum yield among the branches
 * - resume normal traversal.
 */
class TableSizeComputer {
    /**
     * @param {CellInfo} info1
     * @param {CellInfo} info2
     */
    static areOverlappingCellInfo(info1, info2) {
        if (info1.cellIndex <= info2.cellIndex) {
            return info1.cellIndex + info1.length > info2.cellIndex;
        }
        if (info1.cellIndex > info2.cellIndex) {
            return info2.cellIndex + info2.length > info1.cellIndex;
        }
    }

    compute(table) {
        this.cells = new Map();
        this.rows = new Map();
        this.rowIndex = 0;
        this.cellIndex = 0;
        this.cellCount = 0;
        this.maxCellLength = 0;
        this.processChildren(table);
        return {
            rows: this.rows,
            cells: this.cells,
            maxCellLength: this.maxCellLength,
            baseLineRow: this.baseLineRow,
        };
    }

    processCell(cell, params) {
        const cellLength = parseInt(cell.getAttribute("colspan") || "1");
        const cellIndex = this.cellIndex;
        this.cellCount++;
        this.cellIndex = this.cellIndex + cellLength;
        this.cells.set(cell, { length: cellLength, cellEl: cell, rowEl: params.rowEl, cellIndex });
    }

    processRow(el, params) {
        const row = { rowIndex: this.rowIndex++ };
        this.rows.set(el, row);
        for (const child of el.children) {
            this.processElement(child, { ...params, rowEl: el });
        }
        if (!this.baseLineRow) {
            this.baseLineRow = row;
        }
        row.length = this.cellIndex;
        row.cellCount = this.cellCount;
        this.maxCellLength = Math.max(this.cellIndex, this.maxCellLength);
        this.cellIndex = 0;
        this.cellCount = 0;
    }

    processConditions(el, params) {
        // we are about to compute the index of elements inside a t-if/t-elif/t-else
        // sequence of direct siblings.
        // These siblings are mutually exclusive. Hence, we store the current index,
        // go inside the branch, then reset the index to its value.
        // The resulting end index of these siblings in the maximum of them all.
        const cellIndex = this.cellIndex;
        let maxCellIndex = cellIndex;

        const cellCount = this.cellCount;
        let maxCellCount = cellCount;

        for (const conditional of iterConditionalSiblings(el)) {
            this.processElement(conditional, params, false);
            maxCellIndex = Math.max(maxCellIndex, this.cellIndex);
            maxCellCount = Math.max(maxCellCount, this.cellCount);
            this.cellIndex = cellIndex;
            this.cellCount = cellCount;
        }
        this.cellIndex = maxCellIndex;
        this.cellCount = maxCellCount;
    }

    processChildren(el, params = {}) {
        for (const child of el.children) {
            this.processElement(child, params);
        }
    }

    processElement(el, params = {}, processConditions = true) {
        if (el.hasAttribute("t-set")) {
            return;
        }

        if (processConditions) {
            const directive = ["t-if", "t-elif", "t-else"].find((attr) => el.hasAttribute(attr));
            if (directive === "t-if") {
                return this.processConditions(el, params);
            } else if (directive && el.tagName === "T") {
                // Don't plunge into t-elif/t-else: this has been done already
                return;
            }
        }
        if (CELL_TAGS.includes(el.tagName)) {
            return this.processCell(el, params);
        }
        if (el.tagName === "Q-TR") {
            return this.processRow(el, params);
        }
        return this.processChildren(el, params);
    }
}

return __exports;
});
;

/****************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg.js  *
*  Lines: 756                                                                                                   *
****************************************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg', ['@odoo/owl', '@web/core/assets', '@web/core/ensure_jquery', '@web/core/l10n/translation', '@web/core/network/rpc', '@web/core/utils/objects', '@web/core/popover/popover_hook', '@web/core/hotkeys/hotkey_hook', '@web/core/utils/arrays', '@web/core/utils/hooks', '@web/core/select_menu/select_menu', '@web_studio/client_action/report_editor/report_editor_wysiwyg/studio_dynamic_placeholder_popover', '@web/views/fields/many2many_tags/many2many_tags_field', '@web/views/fields/char/char_field', '@web/model/record', '@web/views/fields/many2one/many2one_field', '@web/views/fields/boolean/boolean_field', '@web/core/confirmation_dialog/confirmation_dialog', '@web_studio/client_action/report_editor/report_editor_snackbar', '@web_studio/client_action/editor/edition_flow', '@web_studio/client_action/utils', '@web_studio/client_action/report_editor/report_editor_iframe', '@html_editor/editor', '@html_editor/plugin_sets', '@html_editor/others/qweb_plugin', '@html_editor/utils/position', '@html_editor/utils/dom_traversal', '@web_studio/client_action/report_editor/report_editor_wysiwyg/qweb_table_plugin', '@web_studio/client_action/report_editor/utils', '@html_editor/main/table/table_plugin', '@html_editor/utils/resource'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const {
    Component,
    onWillStart,
    onMounted,
    onWillDestroy,
    onWillUnmount,
    reactive,
    useState,
} = require("@odoo/owl");
const { loadBundle } = require("@web/core/assets");
const { ensureJQuery } = require("@web/core/ensure_jquery");
const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { omit } = require("@web/core/utils/objects");
const { usePopover } = require("@web/core/popover/popover_hook");
const { useHotkey } = require("@web/core/hotkeys/hotkey_hook");
const { sortBy } = require("@web/core/utils/arrays");
const { useOwnedDialogs, useService } = require("@web/core/utils/hooks");
const { SelectMenu } = require("@web/core/select_menu/select_menu");

const { StudioDynamicPlaceholderPopover } = require("@web_studio/client_action/report_editor/report_editor_wysiwyg/studio_dynamic_placeholder_popover");
const { Many2ManyTagsField } = require("@web/views/fields/many2many_tags/many2many_tags_field");
const { CharField } = require("@web/views/fields/char/char_field");
const { Record: _Record } = require("@web/model/record");
const { Many2OneField } = require("@web/views/fields/many2one/many2one_field");
const { BooleanField } = require("@web/views/fields/boolean/boolean_field");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const { ReportEditorSnackbar } = require("@web_studio/client_action/report_editor/report_editor_snackbar");
const { useEditorMenuItem } = require("@web_studio/client_action/editor/edition_flow");
const { memoizeOnce } = require("@web_studio/client_action/utils");
const { ReportEditorIframe } = require("@web_studio/client_action/report_editor/report_editor_iframe");
const { Editor } = require("@html_editor/editor");
const { MAIN_PLUGINS } = require("@html_editor/plugin_sets");
const { QWebPlugin } = require("@html_editor/others/qweb_plugin");
const { nodeSize } = require("@html_editor/utils/position");
const { closestElement } = require("@html_editor/utils/dom_traversal");
const { QWebTablePlugin } = require("@web_studio/client_action/report_editor/report_editor_wysiwyg/qweb_table_plugin");
const { visitNode } = require("@web_studio/client_action/report_editor/utils");
const { TablePlugin } = require("@html_editor/main/table/table_plugin");
const { withSequence } = require("@html_editor/utils/resource");

class __Record extends _Record.components._Record {
    setup() {
        super.setup();
        const willSaveUrgently = () => this.model.bus.trigger("WILL_SAVE_URGENTLY");
        onMounted(() => {
            this.env.reportEditorModel.bus.addEventListener("WILL_SAVE_URGENTLY", willSaveUrgently);
        });

        onWillDestroy(() =>
            this.env.reportEditorModel.bus.removeEventListener(
                "WILL_SAVE_URGENTLY",
                willSaveUrgently
            )
        );
    }
}

class Record extends _Record {
    static components = { ..._Record.components, _Record: __Record };
}

function getOrderedTAs(node) {
    const results = [];
    while (node) {
        const closest = node.closest("[t-foreach]");
        if (closest) {
            results.push(closest.getAttribute("t-as"));
            node = closest.parentElement;
        } else {
            node = null;
        }
    }
    return results;
}

class FieldDynamicPlaceholder extends Component {
    static components = { StudioDynamicPlaceholderPopover, SelectMenu };
    static template = "web_studio.FieldDynamicPlaceholder";
    static props = {
        resModel: String,
        availableQwebVariables: Object,
        close: Function,
        validate: Function,
        isEditingFooterHeader: Boolean,
        initialQwebVar: { optional: true, type: String },
        showOnlyX2ManyFields: Boolean,
    };

    static defaultProps = {
        initialQwebVar: "",
    };

    setup() {
        this.state = useState({ currentVar: this.getDefaultVariable() });
        useHotkey("escape", () => this.props.close());
    }

    get currentResModel() {
        const currentVar = this.state.currentVar;
        const resModel = currentVar && this.props.availableQwebVariables[currentVar].model;
        return resModel || this.props.resModel;
    }

    get sortedVariables() {
        const entries = Object.entries(this.props.availableQwebVariables).filter(
            ([k, v]) => v.in_foreach && !this.props.isEditingFooterHeader
        );
        const resModel = this.props.resModel;
        const sortFn = ([k, v]) => {
            let score = 0;
            if (k === "doc") {
                score += 2;
            }
            if (k === "docs") {
                score -= 2;
            }
            if (k === "o") {
                score++;
            }
            if (v.model === resModel) {
                score++;
            }
            return score;
        };

        const mapFn = ([k, v]) => {
            return {
                value: k,
                label: `${k} (${v.name})`,
            };
        };
        return sortBy(entries, sortFn, "desc").map((e) => mapFn(e));
    }

    validate(...args) {
        this.props.validate(this.state.currentVar, ...args);
    }

    getDefaultVariable() {
        const initialQwebVar = this.props.initialQwebVar;
        if (initialQwebVar && initialQwebVar in this.props.availableQwebVariables) {
            return initialQwebVar;
        }
        if (this.props.isEditingFooterHeader) {
            const companyVar = Object.entries(this.props.availableQwebVariables).find(
                ([k, v]) => v.model === "res.company"
            );
            return companyVar && companyVar[0];
        }

        let defaultVar = this.sortedVariables.find((v) => {
            return ["doc", "o"].includes(v.value);
        });
        defaultVar =
            defaultVar ||
            this.sortedVariables.find(
                (v) => this.props.availableQwebVariables[v.value].model === this.props.resModel
            );
        return defaultVar && defaultVar.value;
    }
}

class UndoRedo extends Component {
    static template = "web_studio.ReportEditorWysiwyg.UndoRedo";
    static props = {
        state: Object,
    };
}

class ResetConfirmationPopup extends ConfirmationDialog {
    static template = "web_studio.ReportEditorWysiwyg.ResetConfirmationPopup";
    static props = {
        ...omit(ConfirmationDialog.props, "body"),
        state: Object,
    };
}

const CUSTOM_BRANDING_ATTR = [
    "ws-view-id",
    "ws-call-key",
    "ws-call-group-key",
    "ws-real-children",
    "o-diff-key",
];

class _TablePlugin extends TablePlugin {
    static id = TablePlugin.id;
    _insertTable() {
        const table = super._insertTable(...arguments);
        if (closestElement(table, "[t-call='web.external_layout']")) {
            table.removeAttribute("class");
            table.classList.add("table", "o_table", "table-borderless");
        }
        return table;
    }
}

const REPORT_EDITOR_PLUGINS_MAP = Object.fromEntries(MAIN_PLUGINS.map((cls) => [cls.id, cls]));
Object.assign(REPORT_EDITOR_PLUGINS_MAP, {
    [QWebPlugin.id]: QWebPlugin,
    [QWebTablePlugin.id]: QWebTablePlugin,
    [TablePlugin.id]: _TablePlugin,
});

const ReportEditorWysiwyg = __exports.ReportEditorWysiwyg = class ReportEditorWysiwyg extends Component {
    static components = {
        CharField,
        Record,
        Many2ManyTagsField,
        Many2OneField,
        BooleanField,
        UndoRedo,
        ReportEditorIframe,
    };
    static props = {
        paperFormatStyle: String,
    };
    static template = "web_studio.ReportEditorWysiwyg";

    setup() {
        this.action = useService("action");
        this.addDialog = useOwnedDialogs();
        this.notification = useService("notification");

        this._getReportQweb = memoizeOnce(() => {
            const tree = new DOMParser().parseFromString(
                this.reportEditorModel.reportQweb,
                "text/html"
            );
            return tree.firstElementChild;
        });

        const reportEditorModel = (this.reportEditorModel = useState(this.env.reportEditorModel));

        this.fieldPopover = usePopover(FieldDynamicPlaceholder);
        useEditorMenuItem({
            component: ReportEditorSnackbar,
            props: {
                state: reportEditorModel,
                onSave: this.save.bind(this),
                onDiscard: this.discard.bind(this),
            },
        });

        // This little reactive is to be bound to the editor, so we create it here.
        // This could have been a useState, but the current component doesn't use it.
        // Instead, it passes it to a child of his,
        this.undoRedoState = reactive({
            canUndo: false,
            canRedo: false,
            undo: () => this.editor?.shared.history.undo(),
            redo: () => this.editor?.shared.history.redo(),
        });

        onWillStart(async () => {
            await ensureJQuery();
            await Promise.all([
                loadBundle("web_editor.backend_assets_wysiwyg"),
                this.reportEditorModel.loadReportQweb(),
            ]);
        });

        onWillUnmount(() => {
            this.reportEditorModel.bus.trigger("WILL_SAVE_URGENTLY");
            this.save({ urgent: true });
            if (this.editor) {
                this.editor.destroy(true);
            }
        });
    }

    instantiateEditor({ editable } = {}) {
        this.undoRedoState.canUndo = false;
        this.undoRedoState.canRedo = false;
        const onEditorChange = () => {
            const canUndo = this.editor.shared.history.canUndo();
            this.reportEditorModel.isDirty = canUndo;
            Object.assign(this.undoRedoState, {
                canUndo: canUndo,
                canRedo: this.editor.shared.history.canRedo(),
            });
        };

        editable.querySelectorAll("[ws-view-id]").forEach((el) => {
            el.setAttribute("contenteditable", "true");
        });

        const editor = new Editor(
            {
                Plugins: Object.values(REPORT_EDITOR_PLUGINS_MAP),
                onChange: onEditorChange,
                getRecordInfo: () => {
                    const { anchorNode } = this.editor.shared.selection.getEditableSelection();
                    if (!anchorNode) {
                        return {};
                    }
                    const lastViewParent = closestElement(anchorNode, "[ws-view-id]");
                    if (!lastViewParent) {
                        return {};
                    }
                    return {
                        resModel: "ir.ui.view",
                        resId: parseInt(lastViewParent.getAttribute("ws-view-id")),
                        field: "arch",
                    };
                },
                resources: {
                    handleNewRecords: this.handleMutations.bind(this),
                    powerbox_categories: withSequence(5, {
                        id: "report_tools",
                        name: _t("Report Tools"),
                    }),
                    user_commands: this.getUserCommands(),
                    powerbox_items: this.getPowerboxCommands(),
                    unsplittable_node_predicates: (node) => {
                        return (
                            node.nodeType === Node.ELEMENT_NODE &&
                            node.matches(".page, .header, .footer")
                        );
                    },
                },
                disableVideo: true,
            },
            this.env.services
        );
        editor.attachTo(editable);
        // disable the qweb's plugin class: its style is too complex and confusing
        // in the case of reports
        editable.classList.remove("odoo-editor-qweb");
        return editor;
    }

    onIframeLoaded({ iframeRef }) {
        if (this.editor) {
            this.editor.destroy(true);
        }
        this.iframeRef = iframeRef;
        const doc = iframeRef.el.contentDocument;
        doc.body.classList.remove("container");

        if (odoo.debug) {
            ["t-esc", "t-out", "t-field"].forEach((tAtt) => {
                doc.querySelectorAll(`*[${tAtt}]`).forEach((e) => {
                    // Save the previous title to set it back before saving the report
                    if (e.hasAttribute("title")) {
                        e.setAttribute("data-oe-title", e.getAttribute("title"));
                    }
                    e.setAttribute("title", e.getAttribute(tAtt));
                });
            });
        }
        if (!this.reportEditorModel._errorMessage) {
            this.editor = this.instantiateEditor({ editable: doc.querySelector("#wrapwrap") });
        }
        this.reportEditorModel.setInEdition(false);
    }

    handleMutations(records) {
        for (const record of records) {
            if (record.type === "attributes") {
                if (record.attributeName === "contenteditable") {
                    continue;
                }
                if (record.attributeName.startsWith("data-oe-t")) {
                    continue;
                }
            }
            if (record.type === "childList") {
                Array.from(record.addedNodes).forEach((el) => {
                    if (el.nodeType !== 1) {
                        return;
                    }
                    visitNode(el, (node) => {
                        CUSTOM_BRANDING_ATTR.forEach((attr) => {
                            node.removeAttribute(attr);
                        });
                        node.classList.remove("o_dirty");
                    });
                });
                const realRemoved = [...record.removedNodes].filter(
                    (n) => n.nodeType !== Node.COMMENT_NODE
                );
                if (!realRemoved.length && !record.addedNodes.length) {
                    continue;
                }
            }

            let target = record.target;
            if (!target.isConnected) {
                continue;
            }
            if (target.nodeType !== Node.ELEMENT_NODE) {
                target = target.parentElement;
            }
            if (!target) {
                continue;
            }

            target = target.closest(`[ws-view-id]`);
            if (!target) {
                continue;
            }
            if (!target.classList.contains("o_dirty")) {
                target.classList.add("o_dirty");
            }
        }
    }

    get reportQweb() {
        const model = this.reportEditorModel;
        return this._getReportQweb(`${model.renderKey}_${model.reportQweb}`).outerHTML;
    }

    get reportRecordProps() {
        const model = this.reportEditorModel;
        return {
            fields: model.reportFields,
            activeFields: model.reportActiveFields,
            values: model.reportData,
        };
    }

    async save({ urgent = false } = {}) {
        if (!this.editor) {
            await this.reportEditorModel.saveReport({ urgent });
            return;
        }
        const htmlParts = {};
        const editable = this.editor.getElContent();

        // Clean technical title
        if (odoo.debug) {
            editable.querySelectorAll("*[t-field],*[t-out],*[t-esc]").forEach((e) => {
                if (e.hasAttribute("data-oe-title")) {
                    e.setAttribute("title", e.getAttribute("data-oe-title"));
                    e.removeAttribute("data-oe-title");
                } else {
                    e.removeAttribute("title");
                }
            });
        }

        editable.querySelectorAll("[ws-view-id].o_dirty").forEach((el) => {
            el.classList.remove("o_dirty");
            el.removeAttribute("contenteditable");
            const viewId = el.getAttribute("ws-view-id");
            if (!viewId) {
                return;
            }
            Array.from(el.querySelectorAll("[t-call]")).forEach((el) => {
                el.removeAttribute("contenteditable");
                el.replaceChildren();
            });

            Array.from(el.querySelectorAll("[oe-origin-t-out]")).forEach((el) => {
                el.replaceChildren();
            });
            if (!el.hasAttribute("oe-origin-class") && el.getAttribute("class") === "") {
                el.removeAttribute("class");
            }

            const callGroupKey = el.getAttribute("ws-call-group-key");
            const type = callGroupKey ? "in_t_call" : "full";

            const escaped_html = el.outerHTML;
            htmlParts[viewId] = htmlParts[viewId] || [];

            htmlParts[viewId].push({
                call_key: el.getAttribute("ws-call-key"),
                call_group_key: callGroupKey,
                type,
                html: escaped_html,
            });
        });
        await this.reportEditorModel.saveReport({ htmlParts, urgent });
    }

    async discard() {
        if (this.editor) {
            const selection = this.editor.document.getSelection();
            if (selection) {
                selection.removeAllRanges();
            }
        }
        this.env.services.dialog.add(ConfirmationDialog, {
            body: _t(
                "If you discard the current edits, all unsaved changes will be lost. You can cancel to return to edit mode."
            ),
            confirm: () => this.reportEditorModel.discardReport(),
            cancel: () => {},
        });
    }

    getUserCommands() {
        const isAvailable = (selection) => {
            const { anchorNode } = selection;
            const { availableQwebVariables } = this.getQwebVariables(
                anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement
            );
            return Object.keys(availableQwebVariables || {}).length > 0;
        };
        return [
            {
                id: "insertField",
                title: _t("Field"),
                description: _t("Insert a field"),
                icon: "fa-magic",
                run: this.insertField.bind(this),
                isAvailable,
            },
            {
                id: "insertDynamicTable",
                title: _t("Dynamic Table"),
                description: _t("Insert a table based on a relational field."),
                icon: "fa-magic",
                run: this.insertTableX2Many.bind(this),
                isAvailable,
            },
        ];
    }

    getPowerboxCommands() {
        return [
            withSequence(20, {
                categoryId: "report_tools",
                commandId: "insertField",
            }),
            withSequence(25, {
                categoryId: "report_tools",
                commandId: "insertDynamicTable",
            }),
        ];
    }

    getQwebVariables(element) {
        if (!element) {
            return {};
        }
        const nodeOeContext = element.closest("[oe-context]");
        let availableQwebVariables =
            nodeOeContext && JSON.parse(nodeOeContext.getAttribute("oe-context"));

        const isInHeaderFooter = closestElement(element, ".header,.footer");
        let initialQwebVar;
        if (isInHeaderFooter) {
            const companyVars = Object.entries(availableQwebVariables).filter(
                ([k, v]) => v.model === "res.company"
            );
            initialQwebVar = companyVars[0]?.[0];
            availableQwebVariables = Object.fromEntries(companyVars);
        } else {
            initialQwebVar = getOrderedTAs(element)[0] || "";
        }
        return {
            isInHeaderFooter,
            availableQwebVariables,
            initialQwebVar,
        };
    }

    getFieldPopoverParams() {
        const resModel = this.reportEditorModel.reportResModel;
        const odooEditor = this.editor;

        const { anchorNode } = odooEditor.shared.selection.getEditableSelection();
        const popoverAnchor = anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement;
        const { availableQwebVariables, initialQwebVar, isInHeaderFooter } =
            this.getQwebVariables(popoverAnchor);

        return {
            popoverAnchor,
            props: {
                availableQwebVariables,
                initialQwebVar,
                isEditingFooterHeader: !!isInHeaderFooter,
                resModel,
            },
        };
    }

    async insertTableX2Many() {
        const { popoverAnchor, props } = this.getFieldPopoverParams();
        await this.fieldPopover.open(popoverAnchor, {
            ...props,
            showOnlyX2ManyFields: true,
            validate: (
                qwebVar,
                fieldNameChain,
                defaultValue = "",
                is_image,
                relation,
                relationName
            ) => {
                const doc = this.editor.document;
                this.editor.editable.focus();

                const table = doc.createElement("table");
                table.classList.add("table", "table-sm");

                const tBody = table.createTBody();

                const topRow = tBody.insertRow();
                topRow.classList.add(
                    "border-bottom",
                    "border-top-0",
                    "border-start-0",
                    "border-end-0",
                    "border-2",
                    "border-dark",
                    "fw-bold"
                );
                const topTd = doc.createElement("td");
                topTd.appendChild(doc.createTextNode(defaultValue || "Column name"));
                topRow.appendChild(topTd);

                const tr = doc.createElement("tr");
                tr.setAttribute("t-foreach", `${qwebVar}.${fieldNameChain}`);
                tr.setAttribute("t-as", "x2many_record");
                tr.setAttribute(
                    "oe-context",
                    JSON.stringify({
                        x2many_record: {
                            model: relation,
                            in_foreach: true,
                            name: relationName,
                        },
                        ...props.availableQwebVariables,
                    })
                );
                tBody.appendChild(tr);

                const td = doc.createElement("td");
                td.textContent = _t("Insert a field...");
                tr.appendChild(td);

                this.editor.shared.dom.insert(table);
                this.editor.shared.selection.setSelection({
                    anchorNode: td,
                    focusOffset: nodeSize(td),
                });
                this.editor.shared.history.addStep();
            },
        });
    }

    async insertField() {
        const { popoverAnchor, props } = this.getFieldPopoverParams();
        await this.fieldPopover.open(popoverAnchor, {
            ...props,
            showOnlyX2ManyFields: false,
            validate: (
                qwebVar,
                fieldNameChain,
                defaultValue = "",
                is_image,
                relation,
                fieldString
            ) => {
                const doc = this.editor.document;

                const span = doc.createElement("span");
                span.setAttribute(
                    "oe-expression-readable",
                    fieldString || `field: "${qwebVar}.${fieldNameChain}"`
                );
                span.textContent = defaultValue;
                span.setAttribute("t-field", `${qwebVar}.${fieldNameChain}`);

                if (odoo.debug) {
                    span.setAttribute("title", `${qwebVar}.${fieldNameChain}`);
                }

                if (is_image) {
                    span.setAttribute("t-options-widget", "'image'");
                    span.setAttribute("t-options-qweb_img_raw_data", 1);
                }
                this.editor.shared.dom.insert(span);
                this.editor.editable.focus();
                this.editor.shared.history.addStep();
            },
        });
    }

    async printPreview() {
        const model = this.reportEditorModel;
        await this.save();
        const recordId = model.reportEnv.currentId || model.reportEnv.ids.find((i) => !!i) || false;
        if (!recordId) {
            this.notification.add(
                _t(
                    "There is no record on which this report can be previewed. Create at least one record to preview the report."
                ),
                {
                    type: "danger",
                    title: _t("Report preview not available"),
                }
            );
            return;
        }

        const action = await rpc("/web_studio/print_report", {
            record_id: recordId,
            report_id: model.editedReportId,
        });
        this.reportEditorModel.renderKey++;
        return this.action.doAction(action, { clearBreadcrumbs: true });
    }

    async resetReport() {
        const state = reactive({ includeHeaderFooter: true });
        this.addDialog(ResetConfirmationPopup, {
            title: _t("Reset report"),
            confirmLabel: _t("Reset report"),
            confirmClass: "btn-danger",
            cancelLabel: _t("Go back"),
            state,
            cancel: () => {},
            confirm: async () => {
                await this.reportEditorModel.saveReport();
                try {
                    await this.reportEditorModel.resetReport(state.includeHeaderFooter);
                } finally {
                    this.reportEditorModel.renderKey++;
                }
            },
        });
    }

    async openReportFormView() {
        await this.save();
        return this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "ir.actions.report",
                res_id: this.reportEditorModel.editedReportId,
                views: [[false, "form"]],
                target: "current",
            },
            { clearBreadcrumbs: true }
        );
    }

    async editSources() {
        await this.save();
        this.reportEditorModel.mode = "xml";
    }
}

return __exports;
});
;

/*****************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_wysiwyg/studio_dynamic_placeholder_popover.js  *
*  Lines: 50                                                                                                                 *
*****************************************************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_wysiwyg/studio_dynamic_placeholder_popover', ['@web/views/fields/dynamic_placeholder_popover', '@web/core/model_field_selector/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { DynamicPlaceholderPopover } = require("@web/views/fields/dynamic_placeholder_popover");
const { useLoadFieldInfo } = require("@web/core/model_field_selector/utils");

const StudioDynamicPlaceholderPopover = __exports.StudioDynamicPlaceholderPopover = class StudioDynamicPlaceholderPopover extends DynamicPlaceholderPopover {
    static template = "web_studio.StudioDynamicPlaceholderPopover";
    static props = [...DynamicPlaceholderPopover.props, "showOnlyX2ManyFields"];
    setup() {
        super.setup();
        this.loadFieldInfo = useLoadFieldInfo();
    }

    filter(fieldDef) {
        if (this.props.showOnlyX2ManyFields) {
            return ["one2many", "many2many"].includes(fieldDef.type);
        } else {
            /**
             * We don't want to display x2many fields inside a report as it would not make sense.
             * We also don't want to display boolean fields.
             * This override is necessary because we want to be able to select non-searchable fields.
             * There is no reason as to why this wouldn't be allowed inside a report as we don't search on those fields,
             * we simply render them.
             */
            return !["one2many", "boolean", "many2many"].includes(fieldDef.type);
        }
    }

    async validate() {
        const fieldInfo = (await this.loadFieldInfo(this.props.resModel, this.state.path)).fieldDef;
        const filename_exists = (
            await this.loadFieldInfo(this.props.resModel, this.state.path + "_filename")
        ).fieldDef;
        const is_image = fieldInfo.type == "binary" && !filename_exists;
        this.props.validate(
            this.state.path,
            this.state.defaultValue,
            is_image,
            fieldInfo.relation,
            fieldInfo.string
        );
        this.props.close();
    }
}

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_xml/report_editor_xml.js  *
*  Lines: 228                                                                                           *
********************************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_xml/report_editor_xml', ['@odoo/owl', '@web_studio/client_action/xml_resource_editor/xml_resource_editor', '@web_studio/client_action/editor/edition_flow', '@web_studio/client_action/report_editor/report_editor_snackbar', '@web_studio/client_action/report_editor/report_editor_xml/report_record_navigation', '@web/core/user', '@web/core/utils/hooks', '@web_studio/client_action/report_editor/report_editor_iframe', '@web/core/l10n/localization', '@web/views/fields/translation_dialog', '@web/views/view'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, onWillStart, onWillUnmount, toRaw, useState } = require("@odoo/owl");
const { XmlResourceEditor } = require("@web_studio/client_action/xml_resource_editor/xml_resource_editor");
const { useEditorMenuItem } = require("@web_studio/client_action/editor/edition_flow");
const { ReportEditorSnackbar } = require("@web_studio/client_action/report_editor/report_editor_snackbar");
const { ReportRecordNavigation } = require("@web_studio/client_action/report_editor/report_editor_xml/report_record_navigation");
const { user } = require("@web/core/user");
const { useBus, useOwnedDialogs } = require("@web/core/utils/hooks");
const { ReportEditorIframe } = require("@web_studio/client_action/report_editor/report_editor_iframe");
const { localization } = require("@web/core/l10n/localization");
const { TranslationDialog } = require("@web/views/fields/translation_dialog");
const { View } = require("@web/views/view");

class ReportResourceEditor extends XmlResourceEditor {
    static props = { ...XmlResourceEditor.props, slots: Object };
    setup() {
        super.setup();
        useBus(this.env.reportEditorModel.bus, "node-clicked", (ev) => {
            const { viewId } = ev.detail;
            const nextResource = this.state.resourcesOptions.find((opt) => opt.value === viewId);
            if (nextResource) {
                this.state.currentResourceId = nextResource.value;
            }
        });
    }
}

class TranslationButton extends Component {
    static template = "web.TranslationButton";
    static props = {
        resourceId: Number,
    };

    setup() {
        this.addDialog = useOwnedDialogs();
    }

    get isMultiLang() {
        return localization.multiLang;
    }
    get lang() {
        return new Intl.Locale(user.lang).language.toUpperCase();
    }
    onClick() {
        this.addDialog(TranslationDialog, {
            fieldName: "arch_db",
            resModel: "ir.ui.view",
            resId: this.props.resourceId,
            onSave: () => {
                const model = this.env.reportEditorModel;
                model.loadReportHtml({ resId: model.reportEnv.currentId });
            },
        });
    }
}

class _View extends View {
    async loadView() {
        const res = await super.loadView(...arguments);
        const Controller = this.Controller;
        if (
            !("afterExecuteActionButton" in Controller.props) &&
            "afterExecuteActionButton" in Controller.prototype
        ) {
            class _Controller extends Controller {
                afterExecuteActionButton(clickParams) {
                    const res = super.afterExecuteActionButton(...arguments);
                    this.props.afterExecuteActionButton(this.model, ...arguments);
                    return res;
                }
            }
            _Controller.props = {
                ...Controller.props,
                afterExecuteActionButton: { type: Function },
            };
            this.Controller = _Controller;
        }
        return res;
    }
}

const ReportEditorXml = __exports.ReportEditorXml = class ReportEditorXml extends Component {
    static components = {
        XmlResourceEditor: ReportResourceEditor,
        ReportRecordNavigation,
        ReportEditorIframe,
        TranslationButton,
        View: _View,
    };
    static template = "web_studio.ReportEditorXml";
    static props = {
        paperFormatStyle: String,
    };

    setup() {
        this.reportEditorModel = useState(this.env.reportEditorModel);
        this.state = useState({
            xmlChanges: null,
            reloadSources: 1,
            viewIdToDiff: false,
            warningMessage: "",
            get isDirty() {
                return !!this.xmlChanges;
            },
        });

        useEditorMenuItem({
            component: ReportEditorSnackbar,
            props: {
                state: this.state,
                onSave: this.save.bind(this),
                onDiscard: this.discardChanges.bind(this),
            },
        });

        onWillStart(() => this.reportEditorModel.loadReportHtml());

        onWillUnmount(() => {
            this.save({ urgent: true });
        });
    }

    get minWidth() {
        const factor = this.state.viewIdToDiff ? 0.2 : 0.4;
        return Math.floor(document.documentElement.clientWidth * factor);
    }

    async onCloseXmlEditor() {
        await this.save();
        this.reportEditorModel.mode = "wysiwyg";
    }

    onXmlChanged(changes) {
        this.state.xmlChanges = changes;
    }

    getDefaultResource(resourcesOptions, mainKey) {
        let mainResource;
        if (mainKey) {
            mainResource = resourcesOptions.find(opt => opt.resource.key === mainKey);
        }
        if (mainResource) {
            const studioExtension = resourcesOptions.find(opt => {
                const key = opt.resource.key;
                const parentId = opt.resource.inherit_id && opt.resource.inherit_id[0];
                return key.includes("web_studio.report_editor_customization") &&
                    parentId === mainResource.resource.id;
            })
            return studioExtension || mainResource;
        }
    }

    async save({ urgent = false } = {}) {
        const changes = { ...toRaw(this.state.xmlChanges) };
        const result = await this.reportEditorModel.saveReport({
            urgent,
            xmlVerbatim: changes,
        });
        this.state.warningMessage = this.reportEditorModel.warningMessage;
        if (result !== false) {
            this.state.xmlChanges = null;
            if (!urgent && Object.keys(changes).length) {
                this.state.reloadSources++;
            }
        }
    }

    async discardChanges() {
        this.state.xmlChanges = null;
        this.state.reloadSources++;
    }

    onIframeLoaded({ iframeRef }) {
        iframeRef.el.contentWindow.document.addEventListener("click", (ev) => {
            const target = ev.target;
            const brandingTarget = target.closest(
                `[data-oe-model="ir.ui.view"][data-oe-field="arch"]`
            );
            if (!brandingTarget) {
                return;
            }
            const viewId = parseInt(brandingTarget.getAttribute("data-oe-id"));
            this.reportEditorModel.bus.trigger("node-clicked", { viewId });
        });
        this.reportEditorModel.setInEdition(false);
    }

    async switchToDiff(viewId) {
        await this.save();
        this.state.viewIdToDiff = viewId;
    }

    get diffProps() {
        return {
            type: "form",
            resModel: "reset.view.arch.wizard",
            context: {
                studio: false,
                studio_report_diff: true,
                active_ids: [this.state.viewIdToDiff],
                active_model: "ir.ui.view",
            },
            afterExecuteActionButton: (model, clickParams) => {
                if (
                    model.root.resModel === "reset.view.arch.wizard" &&
                    clickParams.name === "reset_view_button"
                ) {
                    this.state.reloadSources++;
                    this.reportEditorModel._resetInternalArchs();
                    this.reportEditorModel.loadReportHtml();
                }
            },
            preventCreate: true,
        };
    }

    onResourceChanged(resource) {
        if (this.state.viewIdToDiff) {
            this.state.viewIdToDiff = resource.id;
        }
    }
}

return __exports;
});
;

/***************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/report_editor_xml/report_record_navigation.js  *
*  Lines: 50                                                                                                   *
***************************************************************************************************************/
odoo.define('@web_studio/client_action/report_editor/report_editor_xml/report_record_navigation', ['@odoo/owl', '@web/core/pager/pager', '@web/core/record_selectors/record_selector'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, useState } = require("@odoo/owl");

const { Pager } = require("@web/core/pager/pager");
const { RecordSelector } = require("@web/core/record_selectors/record_selector");

const ReportRecordNavigation = __exports.ReportRecordNavigation = class ReportRecordNavigation extends Component {
    static components = { RecordSelector, Pager };
    static template = "web_studio.ReportEditor.ReportRecordNavigation";
    static props = {};

    setup() {
        this.reportEditorModel = useState(this.env.reportEditorModel);
    }

    get multiRecordSelectorProps() {
        const currentId = this.reportEditorModel.reportEnv.currentId;
        return {
            resModel: this.reportEditorModel.reportResModel,
            update: (resId) => {
                this.reportEditorModel.loadReportHtml({ resId });
            },
            resId: currentId,
            domain: this.reportEditorModel.getModelDomain(),
            context: { studio: false },
        };
    }

    get pagerProps() {
        const { reportEnv } = this.reportEditorModel;
        const { ids, currentId } = reportEnv;
        return {
            limit: 1,
            offset: ids.indexOf(currentId),
            total: ids.length,
        };
    }

    updatePager({ offset }) {
        const ids = this.reportEditorModel.reportEnv.ids;
        const resId = ids[offset];
        this.reportEditorModel.loadReportHtml({ resId });
    }
}

return __exports;
});
;

/**************************************************************************
*  Filepath: /web_studio/static/src/client_action/report_editor/utils.js  *
*  Lines: 69                                                              *
**************************************************************************/
odoo.define('@web_studio/client_action/report_editor/utils', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const PAPER_TO_CSS = {
    margin_top: "padding-top",
    margin_left: "padding-left",
    margin_right: "padding-right",
    print_page_width: "width",
    print_page_height: "min-height",
};

__exports.getCssFromPaperFormat = getCssFromPaperFormat; function getCssFromPaperFormat(paperFormat, unit = "mm") {
    return Object.entries(paperFormat)
        .map((f) => `${PAPER_TO_CSS[f[0]]}:${f[1]}${unit}`)
        .join(";");
}

const RECORDSET_RE = /(?<resModel>(\w+.?)*)\((?<resIds>(\d*,?)*)\)/;
function recordSetReprToData(string) {
    const { resModel, resIds } = string.match(RECORDSET_RE).groups;
    return {
        resModel,
        resIds: resIds.split(",").flatMap((id) => (id ? parseInt(id) : [])),
    };
}

__exports.humanReadableError = humanReadableError; function humanReadableError(error) {
    if (error.code === 200 && error.data) {
        error = error.data;
    }
    let viewError;
    if (error.context?.view) {
        // see @ def _raise_view_error.
        const { resIds, resModel } = recordSetReprToData(error.context.view);
        const { resIds: parentIds } = recordSetReprToData(error.context["view.parent"]);
        const viewName = error.context.name;
        viewError = {
            viewModel: resModel,
            completeName: error.context.xml_id ? `${viewName} (${error.context.xml_id})` : viewName,
            resIds,
            resModel: error.context["view.model"],
            parentIds,
        };
    }
    return {
        ...error,
        traceback: error.debug,
        viewError,
    };
}

__exports.visitNode = visitNode; function visitNode(el, callback) {
    const iterators = [[el]];
    while (iterators.length) {
        const it = iterators.pop();
        for (const _el of it) {
            const doChildren = callback(_el);
            if (doChildren === false) {
                continue;
            }
            iterators.push(_el.children);
        }
    }
}

return __exports;
});
;

/***************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_client_action.js  *
*  Lines: 104                                                              *
***************************************************************************/
odoo.define('@web_studio/client_action/studio_client_action', ['@web/core/registry', '@web/core/user', '@web/core/utils/hooks', '@web/webclient/actions/action_service', '@web/webclient/menus/menu_helpers', '@web_studio/client_action/app_creator/app_creator', '@web_studio/client_action/editor/editor', '@web_studio/client_action/navbar/navbar', '@web_studio/client_action/studio_home_menu/studio_home_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { user: originalUser } = require("@web/core/user");
const { useBus, useService } = require("@web/core/utils/hooks");
const { standardActionServiceProps } = require("@web/webclient/actions/action_service");
const { computeAppsAndMenuItems, reorderApps } = require("@web/webclient/menus/menu_helpers");

const { AppCreator } = require("@web_studio/client_action/app_creator/app_creator");
const { Editor } = require("@web_studio/client_action/editor/editor");
const { StudioNavbar } = require("@web_studio/client_action/navbar/navbar");
const { StudioHomeMenu } = require("@web_studio/client_action/studio_home_menu/studio_home_menu");

const { Component, onWillStart, onMounted, onPatched, onWillUnmount } = require("@odoo/owl");

const StudioClientAction = __exports.StudioClientAction = class StudioClientAction extends Component {
    static template = "web_studio.StudioClientAction";
    static target = "fullscreen";
    static props = { ...standardActionServiceProps };
    static components = {
        StudioNavbar,
        StudioHomeMenu,
        Editor,
        AppCreator,
    };

    setup() {
        const homemenuConfig = JSON.parse(originalUser.settings?.homemenu_config || "null");
        this.studio = useService("studio");
        useBus(this.studio.bus, "UPDATE", () => {
            this.render();
        });

        this.menus = useService("menu");
        this.actionService = useService("action");
        let apps = computeAppsAndMenuItems(this.menus.getMenuAsTree("root")).apps;
        if (homemenuConfig) {
            reorderApps(apps, homemenuConfig);
        }
        this.homeMenuProps = {
            apps: apps,
        };
        useBus(this.env.bus, "MENUS:APP-CHANGED", () => {
            apps = computeAppsAndMenuItems(this.menus.getMenuAsTree("root")).apps;
            if (homemenuConfig) {
                reorderApps(apps, homemenuConfig);
            }
            this.homeMenuProps = {
                apps: apps,
            };
            this.render();
        });

        onWillStart(this.onWillStart);
        onMounted(this.onMounted);
        onPatched(this.onPatched);
        onWillUnmount(this.onWillUnmount);
    }

    onWillStart() {
        return this.studio.ready;
    }

    onMounted() {
        this.studio.pushState();
        document.body.classList.add("o_in_studio"); // FIXME ?
    }

    onPatched() {
        this.studio.pushState();
    }

    onWillUnmount() {
        document.body.classList.remove("o_in_studio");
    }

    async onNewAppCreated({ action_id, menu_id }) {
        await this.menus.reload();
        this.menus.setCurrentMenu(menu_id);
        const action = await this.actionService.loadAction(action_id);

        let initViewType = "form";
        if (!action.views.some((vTuple) => vTuple[1] === initViewType)) {
            initViewType = action.views[0][1];
        }

        this.studio.setParams({
            mode: this.studio.MODES.EDITOR,
            editorTab: "views",
            action,
            viewType: initViewType,
        });
    }
}

registry.category("lazy_components").add("StudioClientAction", StudioClientAction);
// force: true to bypass the studio lazy loading action next time and just use this one directly
registry.category("actions").add("studio", StudioClientAction, { force: true });

return __exports;
});
;

/***************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog.js  *
*  Lines: 79                                                                                                   *
***************************************************************************************************************/
odoo.define('@web_studio/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog', ['@web/core/dialog/dialog', '@web/core/network/rpc', '@web/core/user', '@web/core/utils/hooks', '@web_studio/client_action/icon_creator/icon_creator', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Dialog } = require("@web/core/dialog/dialog");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");
const { useService } = require("@web/core/utils/hooks");
const { IconCreator } = require("@web_studio/client_action/icon_creator/icon_creator");

const { Component, useState } = require("@odoo/owl");

const IconCreatorDialog = __exports.IconCreatorDialog = class IconCreatorDialog extends Component {
    static props = {
        editedAppData: Object,
        appId: Number,
        close: Function,
    };
    static template = "web_studio.IconCreatorDialog";
    static components = { Dialog, IconCreator };

    setup() {
        this.menus = useService("menu");
        this.initialAppData = { ...this.props.editedAppData };
        this.editedAppData = useState(this.props.editedAppData);
    }

    /**
     * @param {Object} icon
     */
    onIconChanged(icon) {
        for (const key in this.editedAppData) {
            delete this.editedAppData[key];
        }
        for (const key in icon) {
            this.editedAppData[key] = icon[key];
        }
    }

    async saveIcon() {
        const { type } = this.initialAppData;
        const appId = this.props.appId;
        let iconValue;
        if (this.editedAppData.type !== type) {
            // different type
            if (this.editedAppData.type === "base64") {
                iconValue = this.editedAppData.uploaded_attachment_id;
            } else {
                const { iconClass, color, backgroundColor } = this.editedAppData;
                iconValue = [iconClass, color, backgroundColor];
            }
        } else if (this.editedAppData.type === "custom_icon") {
            // custom icon changed
            const { iconClass, color, backgroundColor } = this.editedAppData;
            if (
                this.initialAppData.iconClass !== iconClass ||
                this.initialAppData.color !== color ||
                this.initialAppData.backgroundColor !== backgroundColor
            ) {
                iconValue = [iconClass, color, backgroundColor];
            }
        } else if (this.editedAppData.uploaded_attachment_id) {
            // new attachment
            iconValue = this.editedAppData.uploaded_attachment_id;
        }

        if (iconValue) {
            await rpc("/web_studio/edit_menu_icon", {
                context: user.context,
                icon: iconValue,
                menu_id: appId,
            });
            await this.menus.reload();
        }
        this.props.close();
    }
}

return __exports;
});
;

/****************************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_home_menu/studio_home_menu.js  *
*  Lines: 139                                                                           *
****************************************************************************************/
odoo.define('@web_studio/client_action/studio_home_menu/studio_home_menu', ['@web/core/l10n/translation', '@web_enterprise/webclient/home_menu/home_menu', '@web/core/utils/hooks', '@web_studio/studio_service', '@web_studio/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { HomeMenu } = require("@web_enterprise/webclient/home_menu/home_menu");
const { useService } = require("@web/core/utils/hooks");
const { NotEditableActionError } = require("@web_studio/studio_service");
const { IconCreatorDialog } = require("@web_studio/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog");

const { onMounted, onWillUnmount, useRef } = require("@odoo/owl");
const NEW_APP_BUTTON = {
    isNewAppButton: true,
    label: _t("New App"),
    webIconData: "/web_studio/static/src/img/default_icon_app.png",
};

/**
 * Studio home menu
 *
 * Studio version of the standard enterprise home menu. It has roughly the same
 * implementation, with the exception of the app icon edition and the app creator.
 * @extends HomeMenu
 */
const StudioHomeMenu = __exports.StudioHomeMenu = class StudioHomeMenu extends HomeMenu {
    static props = { apps: HomeMenu.props.apps };
    static template = "web_studio.StudioHomeMenu";

    /**
     * @param {Object} props
     * @param {Object[]} props.apps application icons
     * @param {string} props.apps[].action
     * @param {number} props.apps[].id
     * @param {string} props.apps[].label
     * @param {string} props.apps[].parents
     * @param {(boolean|string|Object)} props.apps[].webIcon either:
     *      - boolean: false (no webIcon)
     *      - string: path to Odoo icon file
     *      - Object: customized icon (background, class and color)
     * @param {string} [props.apps[].webIconData]
     * @param {string} props.apps[].xmlid
     */
    setup() {
        super.setup(...arguments);

        this.studio = useService("studio");
        this.notifications = useService("notification");
        this.dialog = useService("dialog");
        this.root = useRef("root");

        onMounted(() => {
            this.canEditIcons = true;
            document.body.classList.add("o_home_menu_background");
            document.body.classList.toggle(
                "o_home_menu_background_custom",
                this.menus.getMenu("root").backgroundImage
            );
        });

        onWillUnmount(() => {
            document.body.classList.remove(
                "o_home_menu_background",
                "o_home_menu_background_custom"
            );
        });
    }

    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------

    get displayedApps() {
        return [...super.displayedApps, NEW_APP_BUTTON];
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    async _openMenu(menu) {
        if (menu.isNewAppButton) {
            this.canEditIcons = false;
            return this.studio.open(this.studio.MODES.APP_CREATOR);
        } else {
            try {
                await this.studio.open(this.studio.MODES.EDITOR, menu.actionID);
                this.menus.setCurrentMenu(menu);
            } catch (e) {
                if (e instanceof NotEditableActionError) {
                    const options = { type: "danger" };
                    this.notifications.add(_t("This action is not editable by Studio"), options);
                    return;
                }
                throw e;
            }
        }
    }

    _enableAppsSorting() {
        return false;
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @param {Object} app
     */
    onEditIconClick(app) {
        if (!this.canEditIcons) {
            return;
        }
        const editedAppData = {};
        if (app.webIconData) {
            Object.assign(editedAppData, {
                webIconData: app.webIconData,
                type: "base64",
            });
        } else {
            Object.assign(editedAppData, {
                backgroundColor: app.webIcon.backgroundColor,
                color: app.webIcon.color,
                iconClass: app.webIcon.iconClass,
                type: "custom_icon",
            });
        }

        const dialogProps = {
            editedAppData,
            appId: app.id,
        };
        this.dialog.add(IconCreatorDialog, dialogProps);
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web_studio/static/src/client_action/utils.js  *
*  Lines: 167                                               *
************************************************************/
odoo.define('@web_studio/client_action/utils', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { reactive, useComponent, useEnv, useSubEnv } = require("@odoo/owl");

__exports.getFieldsInArch = getFieldsInArch; function getFieldsInArch(xmlDoc) {
    const res = [];
    const isInvisible = ["True", "1", "true"];
    xmlDoc.querySelectorAll("field").forEach((el) => {
        if (!el.parentElement.closest("field,groupby")) {
            const invisible = el.getAttribute("invisible") || el.getAttribute("column_invisible");
            const dataUsedBy = el.getAttribute("data-used-by");
            if (dataUsedBy) {
                return;
            }
            if (!invisible || !isInvisible.includes(invisible)) {
                res.push(el.getAttribute("name"));
            }
        }
    });
    return res;
}

__exports.useDialogConfirmation = useDialogConfirmation; function useDialogConfirmation({ confirm, cancel, before, close }) {
    before = before || (() => {});
    confirm = confirm || (() => {});
    cancel = cancel || (() => {});
    if (!close) {
        const component = useComponent();
        close = () => component.props.close();
    }

    let isProtected = false;
    async function canExecute() {
        if (isProtected) {
            return false;
        }
        isProtected = true;
        await before();
        return true;
    }

    async function execute(cb, ...args) {
        let succeeded = false;
        try {
            succeeded = await cb(...args);
        } catch (e) {
            close();
            throw e;
        }
        if (succeeded === undefined || succeeded) {
            return close();
        }
        isProtected = false;
    }

    async function _confirm(...args) {
        if (!(await canExecute())) {
            return;
        }
        return execute(confirm, ...args);
    }

    async function _cancel(...args) {
        if (!(await canExecute())) {
            return;
        }
        return execute(cancel, ...args);
    }

    const env = useEnv();
    env.dialogData.dismiss = () => _cancel();

    return { confirm: _confirm, cancel: _cancel };
}

const Reactive = __exports.Reactive = class Reactive {
    constructor() {
        const raw = this;
        // A function not bound to this returning the original not reactive object
        // This is usefull to be able to read stuff without subscribing the caller
        // eg: when reading internals just for checking
        this.raw = () => {
            return raw;
        };
        return reactive(this);
    }
}

// A custom memoize function that doesn't store all results
// First the core/function/memoize tool may yield incorrect result in our case.
// Second, the keys we use usually involve archs themselves that could be heavy in the long run.
__exports.memoizeOnce = memoizeOnce; function memoizeOnce(callback) {
    let key, value;
    return function (...args) {
        if (key === args[0]) {
            return value;
        }
        key = args[0];
        value = callback.call(this, ...args);
        return value;
    };
}

__exports.useSubEnvAndServices = useSubEnvAndServices; function useSubEnvAndServices(env) {
    const services = env.services;
    const bus = env.bus;
    useSubEnv(env);
    useSubEnv({ services, bus });
}

/**
 * Sorts a list topologically, each element's dependencies should be defined
 * with the getDependencies callback.
 * This is a copy of what is done in python: odoo.tools.misc.py:def topological_sort
 * @params [Array] elems
 * @params [Function] getDependencies
 */
function topologicalSort(elems, getDependencies) {
    const result = [];
    const visited = new Set();
    function visit(n) {
        if (visited.has(n)) {
            return;
        }
        visited.add(n);
        if (!elems.includes(n)) {
            return;
        }
        // first visit all dependencies of n, then append n to result
        for (const dep of getDependencies(n)) {
            visit(dep);
        }
        result.push(n);
    }

    for (const el of elems) {
        visit(el);
    }

    return result;
}

/**
 * Allows to override the services defined in the env with a new instance
 * of each one defined in "overrides".
 * This function assumes all services in overrides start synchronously
 * @params [Object] overrides: new instances of services to create
 *     the key is the service's name, the value is the service definition
 */
__exports.useServicesOverrides = useServicesOverrides; function useServicesOverrides(overrides) {
    let env = useEnv();
    const services = Object.create(env.services);

    useSubEnv({ services });
    env = useEnv();
    const getDependencies = (name) => overrides[name]?.dependencies || [];
    const topoSorted = topologicalSort(Object.keys(overrides), getDependencies);

    for (const servName of topoSorted) {
        services[servName] = overrides[servName].start(env, services);
    }
}

return __exports;
});
;

/************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/default_view_sidebar/default_view_sidebar.js  *
*  Lines: 26                                                                                                *
************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/default_view_sidebar/default_view_sidebar', ['@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, useState } = require("@odoo/owl");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");

const DefaultViewSidebar = __exports.DefaultViewSidebar = class DefaultViewSidebar extends Component {
    static template = "web_studio.ViewEditor.DefaultViewSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
    }
}

return __exports;
});
;

/***************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/calendar/calendar_editor.js  *
*  Lines: 78                                                                                       *
***************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/calendar/calendar_editor', ['@web/views/calendar/calendar_view', '@web/core/registry', '@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/editors/utils', '@web/views/calendar/calendar_controller', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { calendarView } = require("@web/views/calendar/calendar_view");
const { registry } = require("@web/core/registry");

const { Component, useState } = require("@odoo/owl");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");
const { SCALE_LABELS } = require("@web/views/calendar/calendar_controller");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const CalendarEditorSidebar = __exports.CalendarEditorSidebar = class CalendarEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.CalendarEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
    }

    get archInfo() {
        return this.viewEditorModel.controllerProps.archInfo;
    }

    onViewAttributeChanged(value, name) {
        return this.editArchAttributes({ [name]: value });
    }

    get quickCreateFields() {
        return fieldsToChoices(this.viewEditorModel.fields, ["char"], (field) => field.store);
    }

    get startDateFields() {
        return fieldsToChoices(this.viewEditorModel.fields, ["date", "datetime"]);
    }

    get delayFields() {
        return fieldsToChoices(this.viewEditorModel.fields, ["float", "integer"]);
    }

    get colorFields() {
        return fieldsToChoices(this.viewEditorModel.fields, ["many2one", "selection", "integer"]);
    }

    get allDayFields() {
        return fieldsToChoices(this.viewEditorModel.fields, ["boolean"]);
    }

    get modeChoices() {
        return this.viewEditorModel.controllerProps.archInfo.scales.map((value) => {
            return {
                value,
                label: SCALE_LABELS[value],
            };
        });
    }
}

registry.category("studio_editors").add("calendar", {
    ...calendarView,
    Sidebar: CalendarEditorSidebar,
});

return __exports;
});
;

/***********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/cohort/cohort_editor.js  *
*  Lines: 89                                                                                   *
***********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/cohort/cohort_editor', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/registry', '@web_cohort/cohort_view', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { cohortView } = require("@web_cohort/cohort_view");

const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const CohortEditorSidebar = __exports.CohortEditorSidebar = class CohortEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.CohortEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
    }

    onViewAttributeChanged(value, name) {
        value = value ? value : "";
        return this.editArchAttributes({ [name]: value });
    }

    get modelParams() {
        return this.env.viewEditorModel.controllerProps.modelParams;
    }

    get dateFields() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            ["date", "datetime"],
            (field) => field.store
        );
    }

    get measureFields() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            ["integer", "float", "monetary"],
            (field) => field.name !== "id" && field.store
        );
    }

    get intervalChoices() {
        return [
            { label: _t("Day"), value: "day" },
            { label: _t("Week"), value: "week" },
            { label: _t("Month"), value: "month" },
            { label: _t("Year"), value: "year" },
        ];
    }

    get modeChoices() {
        return [
            { label: _t("Retention"), value: "retention" },
            { label: _t("Churn"), value: "churn" },
        ];
    }

    get timelineChoices() {
        return [
            { label: _t("Forward"), value: "forward" },
            { label: _t("Backwards"), value: "backward" },
        ];
    }
}

registry.category("studio_editors").add("cohort", {
    ...cohortView,
    Sidebar: CohortEditorSidebar,
});

return __exports;
});
;

/***********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/field_content_overlay.js  *
*  Lines: 40                                                                                               *
***********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/field_content_overlay', ['@web/core/l10n/translation', '@odoo/owl', '@web_studio/studio_service'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { _t } = require("@web/core/l10n/translation");
const { Component, xml } = require("@odoo/owl");
const { viewTypeToString } = require("@web_studio/studio_service");

/*
 * Injected in the Field.js template
 * Allows to overlay the Field's Component widget to prompt
 * for editing a x2many subview
 */
const FieldContentOverlay = __exports.FieldContentOverlay = class FieldContentOverlay extends Component {
    static template = xml`
    <div class="position-relative">
      <t t-slot="default" />
      <div class="o-web-studio-edit-x2manys-buttons w-100 h-100 d-flex justify-content-center gap-3 position-absolute start-0 top-0 opacity-75 bg-dark" t-if="props.displayOverlay" style="z-index: 1000;">
          <button class="btn btn-primary btn-secondary o_web_studio_editX2Many align-self-center"
          t-foreach="['list', 'form']" t-as="vType" t-key="vType"
          t-on-click.stop="() => props.onEditViewType(vType)"
          t-att-data-type="vType">
          <t t-esc="getButtonText(vType)" />
          </button>
      </div>
    </div>`;

    static props = {
        displayOverlay: { type: Boolean },
        slots: { type: Object },
        onEditViewType: { type: Function },
    };

    getButtonText(viewType) {
        return _t("Edit %s view", viewTypeToString(viewType));
    }
}

return __exports;
});
;

/***********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/field_selector_dialog.js  *
*  Lines: 36                                                                                               *
***********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/field_selector_dialog', ['@web/core/dialog/dialog', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Dialog } = require("@web/core/dialog/dialog");

const { Component, useRef } = require("@odoo/owl");

const FieldSelectorDialog = __exports.FieldSelectorDialog = class FieldSelectorDialog extends Component {
    static template = "web_studio.FieldSelectorDialog";
    static components = { Dialog };
    static props = {
        close: { type: Function },
        onConfirm: { type: Function },
        fields: { type: Array },
        showNew: { type: Boolean, optional: true },
    };
    static defaultProps = {
        showNew: false,
    };
    setup() {
        this.selectRef = useRef("select");
    }
    onConfirm() {
        const field = this.selectRef.el.value;
        this.props.onConfirm(field);
        this.props.close();
    }
    onCancel() {
        this.props.close();
    }
}

return __exports;
});
;

/**************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/field_studio.js  *
*  Lines: 102                                                                                     *
**************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/field_studio', ['@web/views/fields/field', '@web_studio/client_action/view_editor/editors/components/field_content_overlay', '@web_studio/client_action/view_editor/editors/utils', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Field } = require("@web/views/fields/field");
const { FieldContentOverlay } = require("@web_studio/client_action/view_editor/editors/components/field_content_overlay");

const { useStudioRef, studioIsVisible } = require("@web_studio/client_action/view_editor/editors/utils");

const { useState } = require("@odoo/owl");

/*
 * Field:
 * - Displays an Overlay for X2Many fields
 * - handles invisible
 */
const FieldStudio = __exports.FieldStudio = class FieldStudio extends Field {
    static components = { ...Field.components, FieldContentOverlay };
    static template = "web_studio.Field";
    setup() {
        super.setup();
        this.state = useState({
            displayOverlay: false,
        });
        useStudioRef("rootRef", this.onClick);
    }
    get fieldComponentProps() {
        const fieldComponentProps = super.fieldComponentProps;
        if (this.type === "kanban.many2one_avatar_user") {
            // This field must be visible, even when dealing without a record
            fieldComponentProps.isEditable = true;
        }
        delete fieldComponentProps.studioXpath;
        delete fieldComponentProps.hasEmptyPlaceholder;
        delete fieldComponentProps.hasLabel;
        delete fieldComponentProps.studioIsVisible;
        return fieldComponentProps;
    }
    get classNames() {
        const classNames = super.classNames;
        classNames["o_web_studio_show_invisible"] = !studioIsVisible(this.props);
        classNames["o-web-studio-editor--element-clickable"] = !!this.props.studioXpath;
        if (this.studioIsEmpty()) {
            delete classNames["o_field_empty"];
            classNames["o_web_studio_widget_empty"] = true;
            classNames["text-muted"] = true;
        }
        return classNames;
    }

    studioIsEmpty() {
        const { name, record, hasLabel } = this.props;
        if (hasLabel) {
            return false;
        }
        if (this.type === "kanban.many2one_avatar_user") {
            return false; // The widget has its own visibility when empty
        }
        return "isEmpty" in this.field ? this.field.isEmpty(record, name) : !record.data[name];
    }

    getEmptyPlaceholder() {
        const { hasEmptyPlaceholder, name, record, fieldInfo } = this.props;
        if (!hasEmptyPlaceholder) {
            return false;
        }
        return this.studioIsEmpty() && (fieldInfo.string || record.fields[name].string);
    }

    isX2ManyEditable(props) {
        const { name, record } = props;
        const field = record.fields[name];
        if (!["one2many", "many2many"].includes(field.type)) {
            return false;
        }
        return !!this.props.fieldInfo.field.useSubView;
    }

    onEditViewType(viewType) {
        const { name, record, studioXpath } = this.props;
        this.env.viewEditorModel.editX2ManyView({
            viewType,
            fieldName: name,
            record,
            xpath: studioXpath,
            fieldContext: this.fieldComponentProps.context,
        });
    }

    onClick(ev) {
        if (ev.target.classList.contains("o_web_studio_editX2Many")) {
            return;
        }
        ev.stopPropagation();
        ev.preventDefault();
        this.env.config.onNodeClicked(this.props.studioXpath);
        this.state.displayOverlay = !this.state.displayOverlay;
    }
}

return __exports;
});
;

/***********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/studio_hook_component.js  *
*  Lines: 62                                                                                               *
***********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/studio_hook_component', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Component, xml } = require("@odoo/owl");

const formGrid = xml`
    <div class="o_web_studio_hook"
        t-attf-class="g-col-sm-{{ props.colSpan }}"
        t-att-data-xpath="props.xpath"
        t-att-data-position="props.position"
        t-att-data-type="props.type">
            <span class="o_web_studio_hook_separator" />
    </div>
`;

const kanbanAsideHook = xml`
    <div t-attf-class="o_web_studio_hook mx-1 o_web_studio_hook position-absolute top-0 h-100 pe-none w-0 {{ props.position === 'before' ? 'start-0' : 'end-0'}}" t-att-data-type="props.type" t-att-data-xpath="props.xpath" t-att-data-position="props.position" data-structures="aside" />
`;

const kanbanRibbon = xml`
    <div class="o_web_studio_hook position-absolute top-0 start-0 h-100 overflow-hidden m-0 p-0 pe-none w-0" t-att-data-type="props.type" t-att-data-xpath="props.xpath" data-position="inside" data-structures="ribbon">
        <div class="bg-primary opacity-0 position-absolute" style="transform:rotate(45deg); height: 25px; width: 140px; top: 10px; right: -30px;" />
    </div>
`;

const kanbanInline = xml`
    <span class="o_web_studio_hook" t-att-data-xpath="props.xpath" t-att-data-position="props.position" t-att-data-type="props.type" t-att-data-infos="props.infos" t-att-data-structures="props.structures" />
`;

const defaultTemplate = xml`
<div class="o_web_studio_hook" t-att-data-xpath="props.xpath" t-att-data-position="props.position" t-att-data-type="props.type" t-att-data-infos="props.infos" t-att-data-structures="props.structures">
    <span class="o_web_studio_hook_separator" />
</div>
`;

const StudioHook = __exports.StudioHook = class StudioHook extends Component {
    static template = xml`<t t-call="{{ getTemplate(props.subTemplate) }}" />`;
    static props = [
        "xpath?",
        "position?",
        "type?",
        "colSpan?",
        "subTemplate?",
        "width?",
        "infos?",
        "structures?",
    ];
    static subTemplates = {
        formGrid,
        defaultTemplate,
        kanbanInline,
        kanbanAsideHook,
        kanbanRibbon,
    };

    getTemplate(templateName) {
        return this.constructor.subTemplates[templateName || "defaultTemplate"];
    }
}

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/view_button_studio.js  *
*  Lines: 54                                                                                            *
********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/view_button_studio', ['@web/views/view_button/view_button', '@web_studio/client_action/view_editor/editors/utils', '@web/core/utils/hooks'], function (require) {
'use strict';
let __exports = {};
const { ViewButton } = require("@web/views/view_button/view_button");
const { useStudioRef, studioIsVisible } = require("@web_studio/client_action/view_editor/editors/utils");
const { useBus } = require("@web/core/utils/hooks");

/*
 * ViewButton:
 * - Deals with invisible
 * - Click is overriden not to trigger the bound action
 */
const ViewButtonStudio = __exports.ViewButtonStudio = class ViewButtonStudio extends ViewButton {
    static template = "web_studio.ViewButton";
    static props = [...ViewButton.props, "studioIsVisible?", "studioXpath?"];

    setup() {
        super.setup();
        useStudioRef("rootRef");

        useBus(this.env.viewEditorModel.env.bus, "approval-update", () => {
            this.approval.fetchApprovals();
        });
    }
    getClassName() {
        let className = super.getClassName();
        if (!studioIsVisible(this.props)) {
            className += " o_web_studio_show_invisible";
        }
        if (this.props.studioXpath) {
            className += " o-web-studio-editor--element-clickable";
        }
        return className;
    }

    onClick(ev) {
        if (this.props.tag === "a") {
            ev.preventDefault();
        }
        const target = ev.target.classList.contains("o-web-studio-editor--element-clickable")
            ? ev.target
            : ev.target.closest("o-web-studio-editor--element-clickable");
        this.env.config.onNodeClicked(
            target?.getAttribute("studioxpath") || this.props.studioXpath
        );
    }

    _shouldUseApproval() {
        return true;
    }
}

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/view_fields.js  *
*  Lines: 132                                                                                    *
*************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/view_fields', ['@odoo/owl', '@web/core/l10n/translation', '@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { SidebarDraggableItem } = require("@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item");

const ExistingFields = __exports.ExistingFields = class ExistingFields extends Component {
    static components = { SidebarDraggableItem };
    static props = {
        fieldsInArch: { type: Array },
        fields: { type: Object },
        filterFields: { type: Boolean, optional: true },
        folded: { type: Boolean, optional: true },
        resModel: { type: String, optional: true },
    };
    static defaultProps = {
        folded: true,
        filterFields: true,
        resModel: "",
    };
    static template = "web_studio.ViewFields.ExistingFields";

    setup() {
        this.state = useState({
            folded: this.props.folded,
            searchValue: "",
        });
    }

    isMatchingSearch(field) {
        if (!this.state.searchValue) {
            return true;
        }
        const search = this.state.searchValue.toLowerCase();
        let matches = field.string.toLowerCase().includes(search);
        if (!matches && this.env.debug && field.name) {
            matches = field.name.toLowerCase().includes(search);
        }
        return matches;
    }

    get existingFields() {
        const fieldsInArch = this.props.fieldsInArch;
        const resModel = this.props.resModel;
        const filtered = Object.entries(this.props.fields).filter(([fName, field]) => {
            if (
                resModel === "res.users" &&
                (fName.startsWith("in_group_") || fName.startsWith("sel_groups_"))
            ) {
                // These fields are virtual and represent res.groups hierarchy.
                // If the hierarchy changes, the field is replaced by another one and the view will be
                // broken, so, here we prevent adding them.
                return false;
            }
            if (
                !this.isMatchingSearch(field) ||
                (this.props.filterFields && fieldsInArch.includes(fName))
            ) {
                return false;
            }
            return true;
        });

        return filtered.map(([fName, field]) => {
            return {
                ...field,
                name: fName,
                classType: field.type,
                dropData: JSON.stringify({ fieldName: fName }),
            };
        });
    }

    getDropInfo(field) {
        return {
            structure: "field",
            fieldName: field.name,
            isNew: false,
        };
    }
}

const newFields = [
    { type: "char", string: _t("Text") },
    { type: "text", string: _t("Multine Text") },
    { type: "integer", string: _t("Integer") },
    { type: "float", string: _t("Decimal") },
    { type: "html", string: _t("HTML") },
    { type: "monetary", string: _t("Monetary") },
    { type: "date", string: _t("Date") },
    { type: "datetime", string: _t("Datetime") },
    { type: "boolean", string: _t("CheckBox") },
    { type: "selection", string: _t("Selection") },
    { type: "binary", string: _t("File"), widget: "file" },
    { type: "one2many", string: _t("Lines"), special: "lines" },
    { type: "one2many", string: _t("One2Many") },
    { type: "many2one", string: _t("Many2One") },
    { type: "many2many", string: _t("Many2Many") },
    { type: "binary", string: _t("Image"), widget: "image", name: "picture" },
    { type: "many2many", string: _t("Tags"), widget: "many2many_tags", name: "tags" },
    { type: "selection", string: _t("Priority"), widget: "priority" },
    { type: "binary", string: _t("Signature"), widget: "signature" },
    { type: "related", string: _t("Related Field") },
];

const NewFields = __exports.NewFields = class NewFields extends Component {
    static components = { SidebarDraggableItem };
    static props = {};
    static template = "web_studio.ViewFields.NewFields";

    get newFieldsComponents() {
        return newFields.map((f) => {
            const classType = f.special || f.name || f.widget || f.type;
            return {
                ...f,
                name: classType,
                classType,
                dropData: JSON.stringify({
                    fieldType: f.type,
                    widget: f.widget,
                    name: f.name,
                    special: f.special,
                    string: f.string,
                }),
            };
        });
    }
}

return __exports;
});
;

/*****************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/view_structures.js  *
*  Lines: 21                                                                                         *
*****************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/view_structures', ['@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { SidebarDraggableItem } = require("@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item");
const { Component } = require("@odoo/owl");

const ViewStructures = __exports.ViewStructures = class ViewStructures extends Component {
    static components = { SidebarDraggableItem };
    static template = "web_studio.ViewStructures";
    static props = {
        structures: { type: Object },
    };
    get isVisible() {
        return Object.values(this.props.structures).filter(
            (e) => !e.isVisible || e.isVisible(this.env.viewEditorModel)
        ).length;
    }
}

return __exports;
});
;

/***************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/components/widget_studio.js  *
*  Lines: 35                                                                                       *
***************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/components/widget_studio', ['@web/views/widgets/widget', '@web_studio/client_action/view_editor/editors/utils'], function (require) {
'use strict';
let __exports = {};
const { Widget } = require("@web/views/widgets/widget");
const { studioIsVisible, useStudioRef } = require("@web_studio/client_action/view_editor/editors/utils");

const WidgetStudio = __exports.WidgetStudio = class WidgetStudio extends Widget {
    static template = "web_studio.Widget";
    setup() {
        super.setup();
        useStudioRef("rootRef", this.onClick);
    }
    get classNames() {
        const classNames = super.classNames;
        classNames["o_web_studio_show_invisible"] = !studioIsVisible(this.props);
        classNames["o-web-studio-editor--element-clickable"] = !!this.props.studioXpath;
        return classNames;
    }
    get widgetProps() {
        const widgetProps = super.widgetProps;
        delete widgetProps.studioXpath;
        delete widgetProps.hasEmptyPlaceholder;
        delete widgetProps.hasLabel;
        delete widgetProps.studioIsVisible;
        return widgetProps;
    }
    onClick(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        this.env.config.onNodeClicked(this.props.studioXpath);
    }
}

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/chatter_container.js  *
*  Lines: 37                                                                                     *
*************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/chatter_container', ['@mail/chatter/web_portal/chatter', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Chatter } = require("@mail/chatter/web_portal/chatter");

const { Component } = require("@odoo/owl");

const ChatterContainer = __exports.ChatterContainer = class ChatterContainer extends Chatter {
    static template = "web_studio.ChatterContainer";
    static props = [...Chatter.props, "studioXpath?"];

    onClick(ev) {
        this.env.config.onNodeClicked(this.props.studioXpath);
    }
}

const ChatterContainerHook = __exports.ChatterContainerHook = class ChatterContainerHook extends Component {
    static template = "web_studio.ChatterContainerHook";
    static components = { Chatter };
    static props = {
        chatterData: Object,
        threadModel: String,
    };

    onClick() {
        this.env.viewEditorModel.doOperation({
            type: "chatter",
            model: this.env.viewEditorModel.resModel,
            ...this.props.chatterData,
        });
    }
}

return __exports;
});
;

/*******************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor.js  *
*  Lines: 161                                                                              *
*******************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor', ['@web/views/form/form_view', '@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer', '@web_studio/client_action/view_editor/editors/form/form_editor_controller/form_editor_controller', '@web_studio/client_action/view_editor/editors/form/form_editor_compiler', '@web/core/registry', '@web/core/utils/objects', '@web_studio/client_action/view_editor/editors/utils', '@web/views/view_compiler', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/form_editor_sidebar'], function (require) {
'use strict';
let __exports = {};
const { formView } = require("@web/views/form/form_view");
const { FormEditorRenderer } = require("@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer");
const { FormEditorController } = require("@web_studio/client_action/view_editor/editors/form/form_editor_controller/form_editor_controller");
const { FormEditorCompiler } = require("@web_studio/client_action/view_editor/editors/form/form_editor_compiler");
const { registry } = require("@web/core/registry");
const { omit } = require("@web/core/utils/objects");
const {
    makeModelErrorResilient,
    randomName,
} = require("@web_studio/client_action/view_editor/editors/utils");
const { getModifier } = require("@web/views/view_compiler");
const { FormEditorSidebar } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/form_editor_sidebar");
const { getStudioNoFetchFields } = require("@web_studio/client_action/view_editor/editors/utils");

class EditorArchParser extends formView.ArchParser {
    parse() {
        const archInfo = super.parse(...arguments);
        this.omitStudioNoFetchFields(archInfo);
        return archInfo;
    }

    omitStudioNoFetchFields(archInfo) {
        const noFetch = getStudioNoFetchFields(archInfo.fieldNodes);
        archInfo.fieldNodes = omit(archInfo.fieldNodes, ...noFetch.fieldNodes);

        for (const fieldNode of Object.values(archInfo.fieldNodes)) {
            if (fieldNode.views) {
                for (const fieldArchInfo of Object.values(fieldNode.views)) {
                    this.omitStudioNoFetchFields(fieldArchInfo);
                }
            }
        }
    }
}

class Model extends formView.Model {}
Model.Record = class RecordNoEdit extends formView.Model.Record {
    get isInEdition() {
        return false;
    }
    _save() {
        return true
    }
};

const formEditor = __exports.formEditor = {
    ...formView,
    ArchParser: EditorArchParser,
    Compiler: FormEditorCompiler,
    Renderer: FormEditorRenderer,
    Controller: FormEditorController,
    props(genericProps, editor, config) {
        const arch = genericProps.arch;
        Array.from(arch.querySelectorAll("field > list, field > form, field > kanban")).forEach(
            (el) => {
                // Inline subviews sometimes have a "groups" attribute, allowing to have different
                // x2many views depending on access rights. Outside Studio, this has no impact
                // client side, because the view processing in python would remove nodes with groups
                // the user doesn't belong to. However, when there's a "studio" key in the context,
                // nodes are no longer removed but they are set as invisible="1" instead. This means
                // that in Studio, we can have several x2many subviews for the same view type (even
                // tough, only one of them should be visible). Here, we're only interested in the
                // views that are visible (the ones the user has access to), so we remove the others.
                if (getModifier(el, "invisible")) {
                    el.remove();
                }
            }
        );
        const props = formView.props(genericProps, editor, config);
        props.Model = makeModelErrorResilient(Model);
        props.preventEdit = true;
        return props;
    },
    Sidebar: FormEditorSidebar,
};
registry.category("studio_editors").add("form", formEditor);

/**
 *  Drag/Drop Validation
 */
const HOOK_CLASS_WHITELIST = [
    "o_web_studio_field_signature",
    "o_web_studio_field_html",
    "o_web_studio_field_many2many",
    "o_web_studio_field_one2many",
    "o_web_studio_field_tabs",
    "o_web_studio_field_columns",
    "o_web_studio_field_lines",
];
const HOOK_TYPE_BLACKLIST = ["genericTag", "afterGroup", "afterNotebook", "insideSheet"];

const isBlackListedHook = (draggedEl, hookEl) =>
    !HOOK_CLASS_WHITELIST.some((cls) => draggedEl.classList.contains(cls)) &&
    HOOK_TYPE_BLACKLIST.some((t) => hookEl.dataset.type === t);

function canDropNotebook(hookEl) {
    if (hookEl.dataset.type === "page") {
        return false;
    }
    if (hookEl.closest(".o_group") || hookEl.closest(".o_inner_group")) {
        return false;
    }
    return true;
}

function canDropGroup(hookEl) {
    if (hookEl.dataset.type === "insideGroup") {
        return false;
    }
    if (hookEl.closest(".o_group") || hookEl.closest(".o_inner_group")) {
        return false;
    }
    return true;
}

function isValidFormHook({ hook, element }) {
    const draggingStructure = element.dataset.structure;
    switch (draggingStructure) {
        case "notebook": {
            if (!canDropNotebook(hook)) {
                return false;
            }
            break;
        }
        case "group": {
            if (!canDropGroup(hook)) {
                return false;
            }
            break;
        }
    }
    if (isBlackListedHook(element, hook)) {
        return false;
    }

    return true;
}
formEditor.isValidHook = isValidFormHook;

function addFormViewStructure(structure) {
    switch (structure) {
        case "notebook":
        case "group": {
            return {
                node: {
                    tag: structure,
                    attrs: {
                        name: randomName(`studio_${structure}`),
                    },
                },
            };
        }
    }
}
formEditor.addViewStructure = addFormViewStructure;

return __exports;
});
;

/****************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_compiler.js  *
*  Lines: 272                                                                                       *
****************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_compiler', ['@web/views/view_compiler', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/core/utils/xml', '@web/views/form/form_view', '@web/views/form/form_compiler'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { isComponentNode } = require("@web/views/view_compiler");
const {
    computeXpath,
    applyInvisible,
} = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { createElement } = require("@web/core/utils/xml");
const { formView } = require("@web/views/form/form_view");
const { objectToString } = require("@web/views/form/form_compiler");

const interestingSelector = [
    ":not(field) sheet", // A hook should be present to add elements in the sheet
    ":not(field) field", // should be clickable and draggable
    ":not(field) notebook", // should be able to add pages
    ":not(field) page", // should be clickable
    ":not(field) button", // should be clickable
    ":not(field) label", // should be clickable
    ":not(field) group", // any group: outer or inner
    ":not(field) group:not(:has(> group)) > *", // content of inner groups serves as main dropzone
    ":not(field) chatter",
    ":not(field) .oe_avatar",
    ":not(field) widget", // should be clickable
].join(", ");

const FormEditorCompiler = __exports.FormEditorCompiler = class FormEditorCompiler extends formView.Compiler {
    compile(key, params = {}) {
        const xml = this.templates[key];

        // One pass to compute and add the xpath for the arch's node location
        // onto that node.
        for (const el of xml.querySelectorAll(interestingSelector)) {
            const xpath = computeXpath(el);
            el.setAttribute("studioXpath", xpath);
        }

        // done after construction of xpaths
        this.addChatter = true;
        this.chatterData = {
            remove_message_ids: false,
            remove_follower_ids: false,
            remove_activity_ids: false,
        };
        this.avatars = [];

        const mainSheet = xml.querySelector("sheet:not(field sheet)");
        const isSheetEmpty = !mainSheet || !mainSheet.firstElementChild;

        const compiled = super.compile(key, params);

        const sheetBg = compiled.querySelector(".o_form_sheet_bg");
        if (sheetBg) {
            let studioHook;
            if (isSheetEmpty) {
                studioHook = createElement("StudioHook", {
                    xpath: `"${sheetBg.getAttribute("studioXpath")}"`,
                    position: "'inside'",
                    type: "'insideSheet'",
                });
            } else {
                studioHook = createElement("StudioHook", {
                    xpath: `"${sheetBg.getAttribute("studioXpath")}/*[1]"`,
                    position: "'before'",
                    type: "'insideSheet'",
                });
            }

            sheetBg.querySelector(".o_form_sheet").prepend(studioHook);
        }

        if (this.addChatter) {
            const chatterContainerHook = createElement("ChatterContainerHook", {
                threadModel: `__comp__.props.record.resModel`,
                chatterData: objectToString(this.chatterData),
            });
            const el = compiled.querySelector(".o_form_sheet") || compiled;
            el.after(chatterContainerHook);
        } else {
            const parent = compiled.querySelector(".o-mail-Form-chatter");
            parent.removeAttribute("t-attf-class"); // avoid class o-aside
            parent.removeAttribute("t-if");
        }

        const checkStatusBarButtons = compiled.querySelector("StatusBarButtons");
        if (!checkStatusBarButtons) {
            const addButtonAction = createElement("AddButtonAction");
            const el = compiled.querySelector(".o_form_sheet_bg") || compiled;
            el.prepend(addButtonAction);
        }

        const fieldStatus = compiled.querySelector(`Field[type="'statusbar'"]`); // change selector at some point
        if (!fieldStatus) {
            const addStatusBar = !compiled.querySelector(".o_form_statusbar");
            const statusBarFieldHook = createElement("StatusBarFieldHook", { addStatusBar });
            const el = compiled.querySelector(".o_form_sheet_bg") || compiled;
            el.prepend(statusBarFieldHook);
        }

        // the button box is included in the control panel, which is not visible in Studio
        // re-add it to the form view
        const buttonBoxXml = xml.querySelector("div[name='button_box']:not(field div)");
        let buttonBox;
        if (buttonBoxXml) {
            for (const child of [...buttonBoxXml.children]) {
                if (child.matches("span,field")) {
                    buttonBoxXml.removeChild(child);
                }
            }
            buttonBox = this.compileNode(buttonBoxXml, params);
        } else {
            buttonBox = createElement("ButtonBox");
        }
        const el = compiled.querySelector(".o_form_sheet_bg") || compiled;
        el.prepend(buttonBox);

        const buttonHook = createElement(
            "t",
            [createElement("ButtonHook", { add_buttonbox: !buttonBoxXml })],
            { "t-set-slot": `slot_button_hook` }
        );

        buttonBox.insertAdjacentElement("afterbegin", buttonHook);

        // Note: the ribon does not allow to remove an existing avatar!
        const title = compiled.querySelector(".oe_title");
        if (title) {
            if (
                !title.querySelector(":scope > h1 > [isAvatar]") && // check it works with <field class="oe_avatar" ... />
                !title.parentElement.querySelector(":scope > [isAvatar]")
            ) {
                const avatarHook = createElement("AvatarHook", {
                    fields: `__comp__.props.record.fields`,
                });
                title.before(avatarHook);
            }
        }
        for (const el of this.avatars) {
            el.removeAttribute("isAvatar");
        }

        compiled.querySelectorAll(":not(.o_form_statusbar) Field").forEach((el) => {
            el.setAttribute("hasEmptyPlaceholder", "true");
        });

        compiled
            .querySelectorAll(`InnerGroup > t[t-set-slot][subType="'item_component'"] Field`)
            .forEach((el) => {
                el.setAttribute("hasLabel", "true");
            });

        return compiled;
    }

    applyInvisible(invisible, compiled, params) {
        return applyInvisible(invisible, compiled, params);
    }

    createLabelFromField(fieldId, fieldName, fieldString, label, params) {
        const studioXpath = label.getAttribute("studioXpath");
        const formLabel = super.createLabelFromField(...arguments);
        formLabel.setAttribute("studioXpath", `"${studioXpath}"`);
        if (formLabel.hasAttribute("t-if")) {
            formLabel.setAttribute("studioIsVisible", formLabel.getAttribute("t-if"));
            formLabel.removeAttribute("t-if");
        }
        return formLabel;
    }

    compileNode(node, params = {}, evalInvisible = true) {
        const nodeType = node.nodeType;
        // Put a xpath on the currentSlot containing the future compiled element.
        // Do it early not to be bothered by recursive call to compileNode.
        const currentSlot = params.currentSlot;
        if (nodeType === 1 && currentSlot && !currentSlot.hasAttribute("studioXpath")) {
            const parentElement = node.parentElement;
            if (parentElement && parentElement.tagName === "page") {
                const xpath = computeXpath(node.parentElement);
                currentSlot.setAttribute("studioXpath", `"${xpath}"`);
                // If the page has an OuterGroup as last child, don't add a page studioHook
                if (!parentElement.querySelector(":scope > group:last-child > group")) {
                    const pageHookProps = {
                        position: "'inside'",
                        type: "'page'",
                        xpath: `"${xpath}"`,
                    };
                    currentSlot.setAttribute("studioHookProps", objectToString(pageHookProps));
                }
            } else {
                const xpath = node.getAttribute("studioXpath");
                currentSlot.setAttribute("studioXpath", `"${xpath}"`);
            }
        }

        if (nodeType === 1 && node.getAttribute("studio_no_fetch")) {
            return;
        }

        const compiled = super.compileNode(node, { ...params, compileInvisibleNodes: true }, true); // always evalInvisible

        if (nodeType === 1) {
            // Put a xpath on anything of interest.
            if (node.hasAttribute("studioXpath")) {
                const xpath = node.getAttribute("studioXpath");
                if (isComponentNode(compiled)) {
                    compiled.setAttribute("studioXpath", `"${xpath}"`);
                } else if (!compiled.hasAttribute("studioXpath")) {
                    compiled.setAttribute("studioXpath", xpath);
                }
            }

            if (node.tagName === "notebook") {
                // Since empty pages are not compiled, this compiler has not applied the studioXpath attribute.
                // We must need to add one as well as the other pages, to make sure we can edit its content properly.
                const originalChildren = Array.from(node.children).filter(
                    (e) => e.tagName === "page"
                );
                Array.from(compiled.children).forEach((elem, index) => {
                    if (!elem.hasAttribute("studioXpath")) {
                        const studioXpath = originalChildren[index].getAttribute("studioXpath");
                        elem.setAttribute("studioXpath", `"${studioXpath}"`);
                        const pageHookProps = {
                            position: "'inside'",
                            type: "'page'",
                            xpath: `"${studioXpath}"`,
                        };
                        elem.setAttribute("studioHookProps", objectToString(pageHookProps));
                    }
                });
            }

            if (node.tagName === "chatter") {
                this.addChatter = false;
                const chatterNode = compiled.querySelector(
                    "t[t-component='__comp__.mailComponents.Chatter']"
                );
                const xpath = node.getAttribute("studioXpath");
                chatterNode.setAttribute("studioXpath", `"${xpath}"`);
                compiled.setAttribute("data-studio-xpath", xpath);
                compiled.classList.add("o-web-studio-editor--element-clickable");
            }
            if (node.classList.contains("oe_avatar")) {
                compiled.setAttribute("isAvatar", true);
                this.avatars.push(compiled);
            }

            if (node.classList.contains("o_td_label") && !node.children.length && !node.textContent.trim()) {
                compiled.classList.add("o-web-studio-editor--element-clickable");
                const xpath = node.getAttribute("studioXpath");
                compiled.setAttribute(
                    "t-on-click",
                    `(ev) => __comp__.env.config.onNodeClicked("${xpath}")`
                );
            }

            const name = node.getAttribute("name"); // not sure that part works
            if (name === "message_ids") {
                this.chatterData.remove_message_ids = true;
            } else if (name === "message_follower_ids") {
                this.chatterData.remove_follower_ids = true;
            } else if (name === "activity_ids") {
                this.chatterData.remove_activity_ids = true;
            }
        }
        return compiled;
    }
}

return __exports;
});
;

/*****************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_controller/form_editor_controller.js  *
*  Lines: 88                                                                                                                 *
*****************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_controller/form_editor_controller', ['@odoo/owl', '@web/views/form/form_view', '@web_studio/client_action/view_editor/editors/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useState, onMounted, onPatched } = require("@odoo/owl");
const { formView } = require("@web/views/form/form_view");
const { useModelConfigFetchInvisible } = require("@web_studio/client_action/view_editor/editors/utils");

/**
 * This hook ensures that a record datapoint has the "parent" key in its evalContext, allowing
 * to access to field values of the parent record. This is useful in Studio because an x2many
 * record can be opened, but in a standalone fashion. It will be the root of its model, even
 * though, in practice, there's a parent record and a parent form view. This allows snippets like
 * `<field name="..." invisible="not parent.id" />` in the child view to work.
 */
function useExternalParentInModel(model, parentRecord) {
    model._createRoot = (config, data) => {
        return new model.constructor.Record(model, config, data, { parentRecord });
    };
}

const FormEditorController = __exports.FormEditorController = class FormEditorController extends formView.Controller {
    static props = {
        ...formView.Controller.props,
        parentRecord: { type: [Object, { value: null }], optional: true },
    };

    setup() {
        super.setup();
        useModelConfigFetchInvisible(this.model);
        this.mailTemplate = null;
        this.hasFileViewerInArch = false;

        this.viewEditorModel = useState(this.env.viewEditorModel);

        if (this.props.parentRecord) {
            useExternalParentInModel(this.model, this.props.parentRecord);
        }

        onMounted(() => {
            const xpath = this.viewEditorModel.lastActiveNodeXpath;
            if (xpath && xpath.includes("notebook")) {
                const tabXpath = xpath.match(/.*\/page\[\d+\]/)[0];
                const tab = document.querySelector(`[data-studio-xpath='${tabXpath}'] a`);
                if (tab) {
                    // store the targetted element to restore it after being patched
                    this.notebookElementData = {
                        xpath,
                        restore: Boolean(this.viewEditorModel.activeNodeXpath),
                        sidebarTab: this.viewEditorModel.sidebarTab,
                        isTab: xpath.length === tabXpath.length,
                    };
                    tab.click();
                }
            } else {
                this.notebookElementData = null;
            }
        });

        onPatched(() => {
            if (this.notebookElementData) {
                if (
                    this.notebookElementData.isTab &&
                    this.viewEditorModel.lastActiveNodeXpath !== this.notebookElementData.xpath
                ) {
                    return;
                }
                if (this.notebookElementData.restore) {
                    this.env.config.onNodeClicked(this.notebookElementData.xpath);
                } else {
                    // no element was currently highlighted, the editor sidebar must display the stored tab
                    this.viewEditorModel.resetSidebar(this.notebookElementData.sidebarTab);
                }
                this.notebookElementData = null;
            }
        });
    }

    beforeUnload() {}

    _shouldUseSubEnv() {
        return false;
    }
}

return __exports;
});
;

/***********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_groups.js  *
*  Lines: 199                                                                                                          *
***********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_groups', ['@web/views/form/form_view', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { formView } = require("@web/views/form/form_view");
const { studioIsVisible } = require("@web_studio/client_action/view_editor/editors/utils");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");

const { Component, useEffect, useRef, useState } = require("@odoo/owl");

const components = formView.Renderer.components;

/*
 * Overrides for FormGroups: Probably the trickiest part of all, especially InnerGroup
 * - Append droppable hooks below every visible field, or on empty OuterGroup
 * - Elements deal with invisible themselves
 */

// An utility function that extends the common API parts of groups
function extendGroup(GroupClass) {
    class Group extends GroupClass {
        static props = [...GroupClass.props, "studioXpath?", "studioIsVisible?"];
        static components = { ...GroupClass.components, StudioHook };
        setup() {
            super.setup();
            this.viewEditorModel = useState(this.env.viewEditorModel);
            this.rootRef = useRef("rootRef");
        }
        get allClasses() {
            let classes = super.allClasses;
            if (!studioIsVisible(this.props)) {
                classes = `${classes || ""} o_web_studio_show_invisible`;
            }
            if (this.props.studioXpath) {
                classes = `${classes || ""} o-web-studio-editor--element-clickable`;
            }
            return classes;
        }
        _getItems() {
            const items = super._getItems();
            return items.map(([k, v]) => {
                v = Object.assign({}, v);
                v.studioIsVisible = v.isVisible;
                v.isVisible = v.isVisible || this.viewEditorModel.showInvisible;
                if (v.subType === "item_component") {
                    v.props.studioIsVisible = v.studioIsVisible;
                    v.props.studioXpath = v.studioXpath;
                }
                return [k, v];
            });
        }

        onGroupClicked(ev) {
            if (ev.target.closest(".o-web-studio-editor--element-clickable") !== this.rootRef.el) {
                return;
            }
            this.env.config.onNodeClicked(this.props.studioXpath);
        }
    }
    return Group;
}

// A component to display fields with an automatic label.
// Those are the only ones (for now), to be draggable internally
// It should shadow the Field and its Label below
class InnerGroupItemComponent extends Component {
    static template = "web_studio.Form.InnerGroup.ItemComponent";
    static props = {
        cell: { type: Object },
        slots: { type: Object },
    };
    setup() {
        const labelRef = useRef("labelRef");
        const fieldRef = useRef("fieldRef");

        this.labelRef = labelRef;

        useEffect(
            (studioIsVisible, labelEl, fieldEl) => {
                // Only label act as the business unit for studio
                if (labelEl) {
                    const clickable = labelEl.querySelector(
                        ".o-web-studio-editor--element-clickable"
                    );
                    if (clickable) {
                        clickable.classList.remove("o-web-studio-editor--element-clickable");
                    }
                    labelEl.classList.add("o-web-studio-editor--element-clickable");
                    const invisible = labelEl.querySelector(".o_web_studio_show_invisible");
                    if (invisible) {
                        invisible.classList.remove("o_web_studio_show_invisible");
                    }
                    labelEl.classList.toggle("o_web_studio_show_invisible", !studioIsVisible);
                    labelEl.classList.add("o-draggable");
                }

                if (fieldEl) {
                    const clickable = fieldEl.querySelector(
                        ".o-web-studio-editor--element-clickable"
                    );
                    if (clickable) {
                        clickable.classList.remove("o-web-studio-editor--element-clickable");
                    }
                    const invisible = fieldEl.querySelector(".o_web_studio_show_invisible");
                    if (invisible) {
                        invisible.classList.remove("o_web_studio_show_invisible");
                    }
                    fieldEl.classList.add("o-web-studio-element-ghost");
                }
            },
            () => [this.cell.studioIsVisible, labelRef.el, fieldRef.el]
        );

        this.onMouseFieldIO = (ev) => {
            labelRef.el.classList.toggle("o-web-studio-ghost-hovered", ev.type === "mouseover");
        };
    }
    get cell() {
        return this.props.cell;
    }

    onClicked(ev) {
        if (ev.target.closest(".o-web-studio-element-ghost")) {
            ev.stopPropagation();
        }
        this.env.config.onNodeClicked(this.cell.studioXpath);
    }
}

const _InnerGroup = extendGroup(components.InnerGroup);
const InnerGroup = __exports.InnerGroup = class InnerGroup extends _InnerGroup {
    static template = "web_studio.Form.InnerGroup";
    getRows() {
        const rows = super.getRows();
        if (!this.viewEditorModel.showInvisible) {
            rows.forEach((row) => {
                row.isVisible = row.some((cell) => cell.studioIsVisible);
            });
        }
        return rows;
    }

    getStudioHooks() {
        const hooks = new Map();
        const rows = this.getRows();
        const hasRows = rows.length >= 1 && rows[0].length;

        if (!hasRows) {
            hooks.set("inside", {
                xpath: this.props.studioXpath,
                position: "inside",
                subTemplate: "formGrid",
                colSpan: this.props.maxCols,
            });
        }

        for (const rowIdx in rows) {
            const row = rows[rowIdx];
            const colSpan = row.reduce((acc, val) => acc + val.itemSpan || 1, 0);
            if (!hooks.has("beforeFirst")) {
                const cell = row[0];
                if (cell) {
                    hooks.set("beforeFirst", {
                        xpath: cell.studioXpath,
                        position: "before",
                        subTemplate: "formGrid",
                        width: cell.width,
                        colSpan,
                    });
                }
            }

            if (row.every((cell) => !cell.studioIsVisible) && !this.viewEditorModel.showInvisible) {
                continue;
            }
            const cell = row[row.length - 1];
            if (cell) {
                hooks.set(`afterRow ${rowIdx}`, {
                    xpath: cell.studioXpath,
                    position: "after",
                    subTemplate: "formGrid",
                    width: cell.width,
                    colSpan,
                });
            }
        }
        return hooks;
    }
}

InnerGroup.components.InnerGroupItemComponent = InnerGroupItemComponent;

// Simple override for OuterGroups
const OuterGroup = __exports.OuterGroup = extendGroup(components.OuterGroup);
OuterGroup.template = "web_studio.Form.OuterGroup";

return __exports;
});
;

/*************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer.js  *
*  Lines: 89                                                                                                             *
*************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer', ['@odoo/owl', '@web/views/form/form_view', '@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components', '@web_studio/client_action/view_editor/editors/form/chatter_container', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@web_studio/client_action/view_editor/editors/components/field_studio', '@web_studio/client_action/view_editor/editors/components/widget_studio', '@web_studio/client_action/view_editor/editors/components/view_button_studio', '@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_groups', '@web_studio/client_action/view_editor/interactive_editor/action_button/action_button'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useRef, useEffect, useState } = require("@odoo/owl");
const { formView } = require("@web/views/form/form_view");
const formEditorRendererComponents = require("@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components");

const { ChatterContainer, ChatterContainerHook } = require("@web_studio/client_action/view_editor/editors/form/chatter_container");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");
const { FieldStudio } = require("@web_studio/client_action/view_editor/editors/components/field_studio");
const { WidgetStudio } = require("@web_studio/client_action/view_editor/editors/components/widget_studio");
const { ViewButtonStudio } = require("@web_studio/client_action/view_editor/editors/components/view_button_studio");
const { InnerGroup, OuterGroup } = require("@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_groups");
const { AddButtonAction } = require("@web_studio/client_action/view_editor/interactive_editor/action_button/action_button");

class Setting extends formView.Renderer.components.Setting {
    static props = {
        ...formView.Renderer.components.Setting.props,
        studioXpath: { type: String, optional: true },
        studioIsVisible: { type: Boolean, optional: true },
    };
}
const FormEditorRenderer = __exports.FormEditorRenderer = class FormEditorRenderer extends formView.Renderer {
    static components = {
        ...formView.Renderer.components,
        ...formEditorRendererComponents,
        Field: FieldStudio,
        Widget: WidgetStudio,
        ViewButton: ViewButtonStudio,
        ChatterContainerHook,
        InnerGroup,
        OuterGroup,
        StudioHook,
        Setting,
        AddButtonAction,
    };
    setup() {
        super.setup();
        const rootRef = useRef("compiled_view_root");
        this.rootRef = rootRef;
        const viewEditorModel = this.env.viewEditorModel;
        this.viewEditorModel = useState(viewEditorModel);
        this.mailComponents.Chatter = ChatterContainer;

        // Deals with invisible modifier by reacting to config.studioShowVisible.
        useEffect(
            (rootEl, showInvisible) => {
                if (!rootEl) {
                    return;
                }
                rootEl.classList.add("o_web_studio_form_view_editor");
                if (showInvisible) {
                    rootEl
                        .querySelectorAll(":not(.o-mail-Form-chatter) .o_invisible_modifier")
                        .forEach((el) => {
                            el.classList.add("o_web_studio_show_invisible");
                            el.classList.remove("o_invisible_modifier");
                        });
                } else {
                    rootEl
                        .querySelectorAll(":not(.o-mail-Form-chatter) .o_web_studio_show_invisible")
                        .forEach((el) => {
                            el.classList.remove("o_web_studio_show_invisible");
                            el.classList.add("o_invisible_modifier");
                        });
                }
            },
            () => [rootRef.el, viewEditorModel.showInvisible]
        );

        // do this in another way?
        useEffect(
            (rootEl) => {
                if (rootEl) {
                    const optCols = rootEl.querySelectorAll("i.o_optional_columns_dropdown_toggle");
                    for (const col of optCols) {
                        col.classList.add("text-muted");
                    }
                }
            },
            () => [rootRef.el]
        );
    }
}

return __exports;
});
;

/************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components.js  *
*  Lines: 265                                                                                                                       *
************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components', ['@web/views/form/form_view', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog', '@web_studio/client_action/view_editor/editors/components/field_selector_dialog', '@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog', '@web_studio/client_action/view_editor/editors/utils', '@web/core/l10n/translation', '@web/core/utils/hooks', '@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/action_button/action_button'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { formView } = require("@web/views/form/form_view");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");
const { NewButtonBoxDialog } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog");
const { FieldSelectorDialog } = require("@web_studio/client_action/view_editor/editors/components/field_selector_dialog");
const { SelectionContentDialog } = require("@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog");
const {
    randomName,
    studioIsVisible,
    useStudioRef,
} = require("@web_studio/client_action/view_editor/editors/utils");
const { _t } = require("@web/core/l10n/translation");
const { useOwnedDialogs } = require("@web/core/utils/hooks");

const { Component, useState, useRef } = require("@odoo/owl");
const { AddButtonAction } = require("@web_studio/client_action/view_editor/interactive_editor/action_button/action_button");

/**
 * Overrides and extensions of components used by the FormRenderer
 * As a rule of thumb, elements should be able to handle the props
 * - studioXpath: the xpath to the node in the form's arch to which the component
 *   refers
 * - They generally be clicked on to change their characteristics (in the Sidebar)
 * - The click doesn't trigger default behavior (the view is inert)
 * - They can be draggable (FormLabel referring to a field)
 * - studioIsVisible: all components whether invisible or not, are compiled and rendered
 *   this props allows to toggle the class o_invisible_modifier
 * - They can have studio hooks, that are placeholders for dropping content (new elements, field, or displace elements)
 */

const components = formView.Renderer.components;

/*
 * FormLabel:
 * - Can be draggable if in InnerGroup
 */
const FormLabel = __exports.FormLabel = class FormLabel extends components.FormLabel {
    static template = "web_studio.FormLabel";
    static props = {
        ...components.FormLabel.props,
        studioXpath: String,
        studioIsVisible: { type: Boolean, optional: true },
    };
    setup() {
        super.setup();
        useStudioRef("rootRef", this.onClick);
    }
    get className() {
        let className = super.className;
        if (!studioIsVisible(this.props)) {
            className += " o_web_studio_show_invisible";
        }
        className += " o-web-studio-editor--element-clickable";
        return className;
    }
    onClick(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.env.config.onNodeClicked(this.props.studioXpath);
    }
}

/*
 * Notebook:
 * - Display every page, the elements in the page handle whether they are invisible themselves
 * - Push a droppable hook on every empty page
 * - Can add a new page
 */
const Notebook = __exports.Notebook = class Notebook extends components.Notebook {
    static template = "web_studio.Notebook.Hook";
    static components = { ...components.Notebook.components, StudioHook };
    static props = {
        ...components.Notebook.props,
        studioIsVisible: { type: Boolean, optional: true },
        studioXpath: String,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        super.setup();
    }
    computePages(props) {
        const pages = super.computePages(props);
        pages.forEach((p) => {
            p[1].studioIsVisible = p[1].isVisible;
            p[1].isVisible = p[1].isVisible || this.viewEditorModel.showInvisible;
        });
        return pages;
    }
    onNewPageClicked() {
        const vem = this.viewEditorModel;
        const node = {
            tag: "page",
            attrs: {
                string: _t("New Page"),
                name: randomName("studio_page"),
            },
        };
        vem.doOperation({
            type: "add",
            node,
            target: vem.getFullTarget(this.props.studioXpath),
            position: "inside",
        });
    }
}

const StatusBarButtons = __exports.StatusBarButtons = class StatusBarButtons extends components.StatusBarButtons {
    static template = `web_studio.FormViewAddButtonAction`;
    static components = {
        ...components.StatusBarButtons.components,
        AddButtonAction,
    };
}

const StatusBarFieldHook = __exports.StatusBarFieldHook = class StatusBarFieldHook extends Component {
    static template = "web_studio.AddElementHook";
    static props = {
        addStatusBar: { type: Boolean },
    };
    setup() {
        this.addDialog = useOwnedDialogs();
    }
    get classNames() {
        return "o_web_studio_statusbar_hook";
    }
    get title() {
        return _t("Add a pipeline status bar");
    }
    onClick() {
        this.addDialog(SelectionContentDialog, {
            defaultChoices: [
                ["status1", _t("First Status")],
                ["status2", _t("Second Status")],
                ["status3", _t("Third Status")],
            ],
            onConfirm: (choices) => {
                const viewEditorModel = this.env.viewEditorModel;
                if (this.props.addStatusBar) {
                    viewEditorModel.pushOperation({ type: "statusbar" });
                }

                const target = {
                    tag: "header",
                };
                const subViewXpath = viewEditorModel.getSubviewXpath();
                if (subViewXpath) {
                    target.subview_xpath = subViewXpath;
                }

                viewEditorModel.doOperation({
                    type: "add",
                    target,
                    position: "inside",
                    node: {
                        attrs: {
                            widget: "statusbar",
                            options: "{'clickable': '1'}",
                        },
                        field_description: {
                            default_value: true,
                            field_description: _t("Pipeline status bar"),
                            model_name: viewEditorModel.resModel,
                            name: randomName(`x_studio_selection_field`),
                            selection: JSON.stringify(choices),
                            type: "selection",
                        },
                        tag: "field",
                    },
                });
            },
        });
    }
}

const AvatarHook = __exports.AvatarHook = class AvatarHook extends Component {
    static template = "web_studio.AddElementHook";
    static props = { fields: Object };
    setup() {
        this.addDialog = useOwnedDialogs();
    }
    get classNames() {
        return "oe_avatar ms-3 o_web_studio_avatar";
    }
    get title() {
        return _t("Add Picture");
    }
    onClick() {
        const fields = [];
        for (const field of Object.values(this.props.fields)) {
            if (field.type === "binary") {
                fields.push(field);
            }
        }
        this.addDialog(FieldSelectorDialog, {
            fields,
            showNew: true,
            onConfirm: (field) => {
                this.env.viewEditorModel.doOperation({
                    type: "avatar_image",
                    field,
                });
            },
        });
    }
}

const ButtonHook = __exports.ButtonHook = class ButtonHook extends Component {
    static template = "web_studio.AddElementHook";
    static props = {
        add_buttonbox: { type: Boolean, optional: true },
        studioIsVisible: { type: Boolean, optional: true },
    };
    setup() {
        this.addDialog = useOwnedDialogs();
    }
    get classNames() {
        return "oe_stat_button o_web_studio_button_hook flex-grow-1 flex-lg-grow-0 fa fa-plus-square";
    }
    get tooltip() {
        return _t("Add a button");
    }
    onClick() {
        this.addDialog(NewButtonBoxDialog, {
            model: this.env.viewEditorModel,
            isAddingButtonBox: Boolean(this.props.add_buttonbox),
        });
    }
}

const ButtonBox = __exports.ButtonBox = class ButtonBox extends components.ButtonBox {
    static template = "web_studio.ButtonBox";
    static components = {};
    static props = {
        ...components.ButtonBox.props,
        studioIsVisible: { type: Boolean, optional: true },
    };

    setup() {
        super.setup();
        this.togglerRef = useRef("toggleRef");
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.expanded = useState({ value: false });
    }

    toggle() {
        this.expanded.value = !this.expanded.value;
        this.togglerRef.el.classList.toggle("show", this.expanded.value);
        this.togglerRef.el.ariaExpanded = this.expanded.value;
    }

    isSlotVisible(slot) {
        if (this.viewEditorModel.isEditingSubview) {
            return false;
        }
        return this.viewEditorModel.showInvisible || super.isSlotVisible(slot);
    }
}

return __exports;
});
;

/***********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/form_editor_sidebar.js  *
*  Lines: 106                                                                                                          *
***********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/form_editor_sidebar', ['@odoo/owl', '@web/core/utils/hooks', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/editors/components/view_fields', '@web_studio/client_action/view_editor/editors/components/view_structures', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties', '@web/core/l10n/translation', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/o_td_label_properties/o_td_label_properties'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { useService } = require("@web/core/utils/hooks");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const {
    ExistingFields,
    NewFields,
} = require("@web_studio/client_action/view_editor/editors/components/view_fields");
const { ViewStructures } = require("@web_studio/client_action/view_editor/editors/components/view_structures");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { Properties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/properties");
const { ButtonProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties");
const { FieldProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties");
const { GroupProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties");
const { LabelProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties");
const { PageProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties");
const { _t } = require("@web/core/l10n/translation");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { ChatterProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { WidgetProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties");
const { OTdLabelProperties } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/o_td_label_properties/o_td_label_properties");

const FormEditorSidebar = __exports.FormEditorSidebar = class FormEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.FormEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        NewFields,
        ExistingFields,
        Property,
        Properties,
        ViewStructures,
        SidebarViewToolbox,
    };
    static get viewStructures() {
        return {
            notebook: {
                name: _t("Tabs"),
                class: "o_web_studio_field_tabs",
            },
            group: {
                name: _t("Column"),
                class: "o_web_studio_field_columns",
            },
        };
    }

    setup() {
        this.dialog = useService("dialog");
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
        this.propertiesComponents = {
            button: {
                component: ButtonProperties,
                props: {
                    availableOptions: ["invisible"],
                },
            },
            field: {
                component: FieldProperties,
                props: {
                    availableOptions: ["invisible", "required", "readonly", "string", "help"],
                },
            },
            group: {
                component: GroupProperties,
            },
            label: {
                component: LabelProperties,
            },
            page: {
                component: PageProperties,
            },
            chatter: {
                component: ChatterProperties,
            },
            widget: {
                component: WidgetProperties,
            },
            div: {
                component: OTdLabelProperties,
            },
        };
    }

    get activeActions() {
        return this.viewEditorModel.controllerProps.archInfo.activeActions;
    }

    getActiveAction(name) {
        return this.activeActions[name] === true;
    }

    onAttributeChanged(value, name) {
        return this.editArchAttributes({ [name]: value });
    }
}

return __exports;
});
;

/**************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties.js  *
*  Lines: 215                                                                                                                                     *
**************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties', ['@odoo/owl', '@web/core/checkbox/checkbox', '@web/core/domain_selector_dialog/domain_selector_dialog', '@web/core/network/rpc', '@web/core/select_menu/select_menu', '@web_studio/client_action/view_editor/property/property', '@web/core/utils/hooks', '@web/model/record', '@web/views/fields/many2one/many2one_field', '@web/views/fields/many2many_tags/many2many_tags_field', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/rainbow_effect', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/view_editor_hook', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', '@web_studio/approval/approval_hook'], function (require) {
'use strict';
let __exports = {};
const { Component, onWillStart, onWillUpdateProps, useState } = require("@odoo/owl");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { DomainSelectorDialog } = require("@web/core/domain_selector_dialog/domain_selector_dialog");
const { rpc } = require("@web/core/network/rpc");
const { SelectMenu } = require("@web/core/select_menu/select_menu");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { useService } = require("@web/core/utils/hooks");
const { Record } = require("@web/model/record");
const { Many2OneField } = require("@web/views/fields/many2one/many2one_field");
const { Many2ManyTagsField } = require("@web/views/fields/many2many_tags/many2many_tags_field");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { RainbowEffect } = require("@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/rainbow_effect");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { useSnackbarWrapper } = require("@web_studio/client_action/view_editor/view_editor_hook");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");
const { buildApprovalKey } = require("@web_studio/approval/approval_hook");

const ButtonProperties = __exports.ButtonProperties = class ButtonProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Button";
    static props = {
        node: { type: Object },
        availableOptions: { type: Array, optional: true },
    };
    static components = {
        CheckBox,
        ClassAttribute,
        Many2OneField,
        Many2ManyTagsField,
        RainbowEffect,
        Record,
        SelectMenu,
        Property,
        ViewStructureProperties,
        ModifiersProperties,
    };

    setup() {
        this.dialog = useService("dialog");
        this.orm = useService("orm");
        this.actionService = useService("action");
        this.state = useState({});
        this.editNodeAttributes = useEditNodeAttributes();

        this.decoratedOrmCall = useSnackbarWrapper(this.orm.call.bind(this.orm));
        this.decoratedOrmWrite = useSnackbarWrapper(this.orm.write.bind(this.orm));

        this.domainResUsers = [
            ["id", "not in", [1]],
            ["share", "=", false],
        ];
        const m2mFieldsToFetch = {
            display_name: { type: "char" },
        };
        const approvalRecordDefinition = {
            approval_group_id: {
                type: "many2one",
                relation: "res.groups",
                domain: [["share", "=", false]],
            },
            approver_ids: {
                type: "many2many",
                relation: "res.users",
                related: { activeFields: m2mFieldsToFetch, fields: m2mFieldsToFetch },
            },
            users_to_notify: {
                type: "many2many",
                relation: "res.users",
                related: { activeFields: m2mFieldsToFetch, fields: m2mFieldsToFetch },
            },
        };
        this.recordProps = {
            resModel: "studio.approval.rule",
            fields: approvalRecordDefinition,
            activeFields: approvalRecordDefinition,
        };

        onWillStart(() => {
            this.updateApprovalSpec();
        });

        onWillUpdateProps((nextProps) => {
            this.updateApprovalSpec(this.getApprovalParams(nextProps.node));
        });
    }

    isValid(fieldName, record) {
        if (["approver_ids", "approval_group_id"].includes(fieldName)) {
            const evalContext = record.evalContext;
            return evalContext.approver_ids.length || evalContext.approval_group_id;
        }
        return true;
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }

    async onChangeApprovalRecord(record, changes, id) {
        await this.decoratedOrmWrite("studio.approval.rule", [id], changes);
        this.updateApprovalSpec();
    }

    get showRainbowMan() {
        const attrs = this.props.node.attrs;
        return attrs.class !== "oe_stat_button" && attrs.type === "object";
    }

    async createApprovalRule() {
        const params = this.getApprovalParams();
        if (this.state.approvalSpec?.rules.length) {
            const orders = this.state.approvalSpec.rules.map((id) =>
                parseInt(this.state.allRules[id]["notification_order"])
            );
            params.push(Math.min(Math.max(...orders) + 1, 9).toString());
        }
        await this.decoratedOrmCall("studio.approval.rule", "create_rule", params);
        this.updateApprovalSpec();
    }

    getApprovalParams(node = this.props.node) {
        let method,
            action = false;
        if (node.attrs.type === "object") {
            method = node.attrs.name;
        } else {
            action = node.attrs.name;
        }
        return [this.env.viewEditorModel.resModel, method, action];
    }

    async getApprovalSpec(approvalParams) {
        const approvalParamsObject = {
            model: approvalParams[0],
            method: approvalParams[1],
            action_id: approvalParams[2],
        };
        const approvals = await this.env.services["web_studio.get_approval_spec_batched"](
            approvalParamsObject
        );
        return approvals;
    }

    async onApprovalArchive(id) {
        await this.decoratedOrmWrite("studio.approval.rule", [id], {
            active: false,
        });
        this.updateApprovalSpec();
    }

    async onApprovalEdit(name, id, value) {
        const isMethod = this.props.node.attrs.type === "object";
        await rpc("/web_studio/edit_approval", {
            model: this.env.viewEditorModel.resModel,
            method: isMethod ? this.props.node.attrs.name : false,
            action: isMethod ? false : this.props.node.attrs.name,
            operations: [[name, id, value]],
        });
        this.updateApprovalSpec();
    }

    onApprovalSelectDomain(id) {
        const rule = this.state.allRules[id];
        const domain = rule.domain;
        this.dialog.add(DomainSelectorDialog, {
            resModel: this.env.viewEditorModel.resModel,
            domain: JSON.stringify(domain || []),
            isDebugMode: !!this.env.debug,
            onConfirm: async (domain) => {
                await this.decoratedOrmWrite("studio.approval.rule", [id], {
                    domain,
                });
                this.updateApprovalSpec();
            },
        });
    }

    async onChangeNotificationOrder(ev, id) {
        await this.decoratedOrmWrite("studio.approval.rule", [id], {
            notification_order: ev.target.value,
        });
    }

    async updateApprovalSpec(params = this.getApprovalParams()) {
        this.env.viewEditorModel.env.bus.trigger("approval-update");
        const approvalSpec = await this.getApprovalSpec(params);
        this.state.allRules = approvalSpec.all_rules;
        const approvalKey = buildApprovalKey(false, params[1] || false, params[2] || false);
        this.state.approvalSpec = approvalSpec[params[0]][approvalKey] || {
            rules: [],
            entries: [],
        };
    }

    async openKanbanApprovalRules() {
        const [resModel, method, action] = this.getApprovalParams();
        return this.actionService.doActionButton({
            context: {
                studio: true,
            },
            type: "object",
            name: "open_kanban_rules",
            resModel: "studio.approval.rule",
            resIds: [],
            args: JSON.stringify([resModel, method, action]),
            stackPosition: "replaceCurrentAction",
        });
    }
}

return __exports;
});
;

/******************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog.js  *
*  Lines: 80                                                                                                                                          *
******************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog', ['@odoo/owl', '@web/core/dialog/dialog', '@web/views/fields/relational_utils', '@web/core/l10n/translation', '@web/core/utils/hooks', '@web_studio/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");
const { Many2XAutocomplete } = require("@web/views/fields/relational_utils");
const { _t } = require("@web/core/l10n/translation");
const { useService } = require("@web/core/utils/hooks");
const { FontAwesomeIconSelector } = require("@web_studio/client_action/components/font_awesome_icon_selector/font_awesome_icon_selector");

const NewButtonBoxDialog = __exports.NewButtonBoxDialog = class NewButtonBoxDialog extends Component {
    static template = "web_studio.NewButtonBoxDialog";
    static components = {
        Dialog,
        FontAwesomeIconSelector,
        Many2XAutocomplete,
    };
    static props = {
        isAddingButtonBox: { type: Boolean },
        model: { type: Object },
        close: { type: Function },
    };
    setup() {
        this.orm = useService("orm");
        this.notification = useService("notification");
        this.state = useState({
            icon: "fa fa-diamond",
            field: undefined,
        });
        this.text = undefined;
    }
    async update(selection) {
        if (!selection[0].display_name) {
            const resId = selection[0].id;
            const fields = ["display_name"];
            const record = await this.orm.read("ir.model.fields", [resId], fields);
            selection[0].display_name = record[0].display_name;
        }
        this.state.field = selection[0];
    }
    getDomain() {
        return [
            ["relation", "=", this.props.model.resModel],
            ["ttype", "in", ["many2one", "many2many"]],
            ["store", "=", true],
        ];
    }
    onConfirm() {
        if (!this.state.field?.id) {
            return this.notification.add(_t("Select a related field."));
        }
        if (this.props.isAddingButtonBox) {
            this.props.model.pushOperation({ type: "buttonbox" });
        }
        this.props.model.doOperation({
            type: "add",
            target: {
                tag: "div",
                attrs: {
                    class: "oe_button_box",
                },
            },
            position: "inside",
            node: {
                tag: "button",
                field: this.state.field.id,
                string: this.text || _t("New button"),
                attrs: {
                    class: "oe_stat_button",
                    // we don't need the 'fa' class here, but only the icon class
                    icon: this.state.icon.slice(3),
                },
            },
        });
        this.props.close();
    }
}

return __exports;
});
;

/***********************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/rainbow_effect.js  *
*  Lines: 63                                                                                                                                   *
***********************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/rainbow_effect', ['@odoo/owl', '@web/core/user', '@web/core/file_input/file_input', '@web/core/select_menu/select_menu', '@web_studio/client_action/view_editor/property/property', '@web/core/l10n/translation', '@web/core/py_js/py'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { user } = require("@web/core/user");
const { FileInput } = require("@web/core/file_input/file_input");
const { SelectMenu } = require("@web/core/select_menu/select_menu");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { _t } = require("@web/core/l10n/translation");
const { evaluateExpr } = require("@web/core/py_js/py");

const RainbowEffect = __exports.RainbowEffect = class RainbowEffect extends Component {
    static template = "web_studio.ViewEditorSidebar.RainbowEffect";
    static props = {
        effect: { type: true, optional: true },
        onChange: { type: Function },
    };
    static components = {
        FileInput,
        SelectMenu,
        Property,
    };
    setup() {
        this.user = user;
    }
    get choices() {
        return [
            { label:  _t("Fast"), value: "fast" },
            { label:  _t("Medium"), value: "medium" },
            { label:  _t("Slow"), value: "slow" },
            { label:  _t("None"), value: "no" },
        ];
    }
    get rainbowEffect() {
        const effect = this.props.effect;
        if (effect === undefined) {
            return null;
        }
        if (effect === "True") {
            return {};
        }
        return evaluateExpr(effect);
    }
    onRainbowEffectChange(name, value) {
        const effect = this.rainbowEffect;
        if (!value || !value.length) {
            delete effect[name];
        } else {
            effect[name] = value;
        }
        this.props.onChange(effect, "effect");
    }
    toggleRainbowMan() {
        const effect = this.rainbowEffect;
        const newValue = effect ? "False" : "{}";
        this.props.onChange(newValue, "effect");
    }
}

return __exports;
});
;

/****************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties.js  *
*  Lines: 48                                                                                                                                        *
****************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties', ['@odoo/owl', '@web/core/network/rpc', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, useState, onWillStart, onWillUpdateProps } = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");

const ChatterProperties = __exports.ChatterProperties = class ChatterProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Chatter";
    static components = { Property, SidebarPropertiesToolbox };
    static props = ["node"];

    setup() {
        this.state = useState({});

        onWillStart(async () => {
            const alias = await this.getMailAlias(this.props.node);
            this.state.mailAlias = alias.email_alias;
            this.state.aliasDomain = alias.alias_domain;
        });

        onWillUpdateProps(async (nextProps) => {
            const alias = await this.getMailAlias(nextProps.node);
            this.state.mailAlias = alias.email_alias;
            this.state.aliasDomain = alias.alias_domain;
        });
    }

    async getMailAlias(node) {
        const mailAliasObj = await rpc("/web_studio/get_email_alias", {
            model_name: this.env.viewEditorModel.resModel,
        });
        return mailAliasObj;
    }

    onChangeMailAlias(value) {
        rpc("/web_studio/set_email_alias", {
            model_name: this.env.viewEditorModel.resModel,
            value,
        });
    }
}

return __exports;
});
;

/************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties.js  *
*  Lines: 31                                                                                                                                    *
************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const GroupProperties = __exports.GroupProperties = class GroupProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Group";
    static components = {
        ModifiersProperties,
        Property,
        ViewStructureProperties,
    };
    static props = ["node"];

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties.js  *
*  Lines: 26                                                                                                                                    *
************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const LabelProperties = __exports.LabelProperties = class LabelProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Label";
    static components = { Property, SidebarPropertiesToolbox };
    static props = ["node"];

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/**********************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/o_td_label_properties/o_td_label_properties.js  *
*  Lines: 16                                                                                                                                              *
**********************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/o_td_label_properties/o_td_label_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");

const OTdLabelProperties = __exports.OTdLabelProperties = class OTdLabelProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.OTdLabelProperties";
    static components = { SidebarPropertiesToolbox };
    static props = ["node"];
}

return __exports;
});
;

/**********************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties.js  *
*  Lines: 48                                                                                                                                  *
**********************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { LimitGroupVisibility } = require("@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

class PageNodeToolbox extends SidebarPropertiesToolbox {
    removeNodeFromArch() {
        const node = this.node;
        let xpathToRemove = node.xpath;
        if (node.arch.parentElement.children.length <= 1) {
            // retarget to the parent notebook
            xpathToRemove = node.xpath.split("/").slice(0, -1).join("/");
        }
        return super.removeNodeFromArch(xpathToRemove);
    }
}

const PageProperties = __exports.PageProperties = class PageProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Page";
    static components = {
        Property,
        LimitGroupVisibility,
        PageNodeToolbox,
        ModifiersProperties,
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }

    static props = {
        node: { type: Object },
    }
}

return __exports;
});
;

/*****************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/gantt/gantt_editor_sidebar.js  *
*  Lines: 151                                                                                        *
*****************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/gantt/gantt_editor_sidebar', ['@web_gantt/gantt_view', '@web/core/registry', '@odoo/owl', '@web/core/l10n/translation', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { ganttView } = require("@web_gantt/gantt_view");
const { registry } = require("@web/core/registry");

const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const GanttEditorSidebar = __exports.GanttEditorSidebar = class GanttEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.GanttEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
    }

    get colorChoices() {
        return this.modelParams.decorationFields.map((value) => {
            return {
                label: this.modelParams.fields[value].string,
                value,
            };
        });
    }

    get currentDayPrecision() {
        return this.dayPrecisionChoices.find((e) => e.value === this.precisionValues.day)?.value;
    }

    get currentWeekPrecision() {
        return this.weekAndMonthPrecisionChoices.find((e) => e.value === this.precisionValues.week)
            ?.value;
    }

    get currentMonthPrecision() {
        return this.weekAndMonthPrecisionChoices.find((e) => e.value === this.precisionValues.month)
            ?.value;
    }

    get dayPrecisionChoices() {
        return [
            { label: _t("Quarter Hour"), value: "hour:quarter" },
            { label: _t("Half Hour"), value: "hour:half" },
            { label: _t("Hour"), value: "hour:full" },
        ];
    }

    get defaultOrderChoices() {
        return [
            { value: "asc", label: _t("Ascending") },
            { value: "desc", label: _t("Descending") },
        ];
    }

    get defaultScalesChoices() {
        const allowedScales = Object.keys(this.modelParams.scales);
        return [
            { value: "day", label: _t("Day") },
            { value: "week", label: _t("Week") },
            { value: "week_2", label: _t("Week (expanded)") },
            { value: "month", label: _t("Month") },
            { value: "month_3", label: _t("Month (expanded)") },
            { value: "year", label: _t("Year") },
        ].filter((e) => allowedScales.includes(e.value));
    }

    get displayModeChoices() {
        return [
            { label: _t("Dense"), value: "dense" },
            { label: _t("Sparse"), value: "sparse" },
        ];
    }

    get fieldsChoices() {
        return Object.values(this.modelParams.fields)
            .filter((f) => f.store && this.viewEditorModel.GROUPABLE_TYPES.includes(f.type))
            .map((f) => {
                return {
                    label: f.string,
                    value: f.name,
                };
            });
    }

    get fieldsDateChoices() {
        return Object.values(this.modelParams.fields)
            .filter((f) => f.store && ["date", "datetime"].includes(f.type))
            .map((f) => {
                return {
                    label: f.string,
                    value: f.name,
                };
            });
    }

    get modelParams() {
        return this.viewEditorModel.controllerProps.modelParams.metaData;
    }

    get weekAndMonthPrecisionChoices() {
        return [
            { label: _t("Half Day"), value: "day:half" },
            { label: _t("Day"), value: "day:full" },
        ];
    }

    get precisionValues() {
        const precision =
            this.viewEditorModel.xmlDoc
                .querySelector("gantt")
                .getAttribute("precision")
                ?.replace(/'/g, '"') || "{}";
        return JSON.parse(precision);
    }

    onDefaultGroupByChanged(selection) {
        this.onViewAttributeChanged(selection.join(","), "default_group_by");
    }

    onPrecisionChanged(value, name) {
        const precision = this.precisionValues;
        precision[name] = value;
        this.onViewAttributeChanged(JSON.stringify(precision), "precision");
    }

    onViewAttributeChanged(value, name) {
        return this.editArchAttributes({ [name]: value });
    }
}

registry.category("studio_editors").add("gantt", {
    ...ganttView,
    Sidebar: GanttEditorSidebar,
});

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/graph/graph_editor.js  *
*  Lines: 104                                                                                *
*********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/graph/graph_editor', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/registry', '@web/views/graph/graph_view', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/operations_utils', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, onWillPatch, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");

const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const operationUtils = require("@web_studio/client_action/view_editor/operations_utils");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const GraphEditorSidebar = __exports.GraphEditorSidebar = class GraphEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.GraphEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });

        onWillPatch(() => {
            this.oldFieldValues = {
                firstDimension: this.modelParams.groupBy[0],
                secondDimension: this.modelParams.groupBy[1],
                measure:
                    this.modelParams.measure === "__count" ? undefined : this.modelParams.measure,
            };
        });
    }

    onViewAttributeChanged(value, name) {
        value = value ? value : "";
        return this.editArchAttributes({ [name]: value });
    }

    onGroupByChanged(type, newField, oldField) {
        const operation = operationUtils.viewGroupByOperation("graph", type, newField, oldField);
        this.viewEditorModel.doOperation(operation);
    }

    get modelParams() {
        return this.viewEditorModel.controllerProps.modelParams;
    }

    get typeChoices() {
        return [
            { label: _t("Bar"), value: "bar" },
            { label: _t("Line"), value: "line" },
            { label: _t("Pie"), value: "pie" },
        ];
    }

    get orderChoices() {
        return [
            { label: _t("Ascending"), value: "asc" },
            { label: _t("Descending"), value: "desc" },
        ];
    }

    get firstGroupbyChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) => field.store && field.name !== this.modelParams.groupBy[1]
        );
    }

    get secondGroupbyChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) => field.store && field.name !== this.modelParams.groupBy[0]
        );
    }

    get mesureChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            ["integer", "float", "monetary"],
            (field) => field.store && field.name !== "id"
        );
    }
}

registry.category("studio_editors").add("graph", {
    ...graphView,
    Sidebar: GraphEditorSidebar,
});

return __exports;
});
;

/***********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor.js  *
*  Lines: 212                                                                                  *
***********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor', ['@web/core/registry', '@web/core/utils/objects', '@web/views/kanban/kanban_view', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_renderer', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/kanban_editor_sidebar', '@web/views/kanban/kanban_arch_parser'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { omit } = require("@web/core/utils/objects");
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { KanbanEditorCompiler } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler");
const { KanbanEditorRecord } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record");
const { KanbanEditorRenderer } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_renderer");
const { makeModelErrorResilient } = require("@web_studio/client_action/view_editor/editors/utils");
const { KanbanEditorSidebar } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/kanban_editor_sidebar");
const { getStudioNoFetchFields, useModelConfigFetchInvisible } = require("@web_studio/client_action/view_editor/editors/utils");
const { KANBAN_CARD_ATTRIBUTE } = require("@web/views/kanban/kanban_arch_parser");

class EditorArchParser extends kanbanView.ArchParser {
    parse(arch, models, modelName) {
        const parsed = super.parse(...arguments);
        const noFetch = getStudioNoFetchFields(parsed.fieldNodes);
        parsed.fieldNodes = omit(parsed.fieldNodes, ...noFetch.fieldNodes);
        return parsed;
    }
}
class OneRecordModel extends kanbanView.Model {
    async load() {
        this.progressAttributes = false;
        await super.load(...arguments);
        let list = this.root;
        let hasRecords;
        const isGrouped = list.isGrouped;
        if (!isGrouped) {
            hasRecords = list.records.length;
        } else {
            hasRecords = list.groups.some((g) => g.list.records.length);
        }
        if (!hasRecords) {
            if (isGrouped) {
                const commonConfig = {
                    resModel: list.config.resModel,
                    fields: list.config.fields,
                    activeFields: list.config.activeFields,
                    groupByFieldName: list.groupByField.name,
                    context: list.context,
                    list: {
                        resModel: list.config.resModel,
                        fields: list.config.fields,
                        activeFields: list.config.activeFields,
                        groupBy: [],
                        context: list.context,
                    },
                };

                const data = {
                    count: 0,
                    length: 0,
                    records: [],
                    __domain: [],
                    value: "fake",
                    displayName: "Fake Group",
                    groups: [
                        {
                            display_name: false,
                            count: 0,
                        },
                    ],
                };

                list.config.groups.fake = commonConfig;

                const group = list._createGroupDatapoint(data);
                list.groups.push(group);
                list = group.list;
            }
            await list.addNewRecord();
        }
    }
}

class KanbanEditorController extends kanbanView.Controller {
    setup() {
        super.setup();
        useModelConfigFetchInvisible(this.model);
    }

    get modelParams() {
        const params = super.modelParams;
        params.groupsLimit = 1;
        return params;
    }
}

function isValidKanbanHook({ hook, element }) {
    const draggingStructure = element.dataset.structure;
    return hook.dataset.structures.split(",").includes(draggingStructure);
}

async function addKanbanViewStructure(structure) {
    switch (structure) {
        case "aside": {
            if (!this.viewEditorModel.xmlDoc.querySelector("main")) {
                this.env.viewEditorModel.pushOperation({
                    type: "kanban_wrap_main",
                    wrap_type: "aside",
                });
            }
            return {
                node: {
                    tag: "aside",
                    attrs: {
                        class: "col-2",
                    },
                },
                target: {
                    tag: "main",
                },
            };
        }
        case "footer": {
            if (!this.viewEditorModel.xmlDoc.querySelector("main")) {
                this.env.viewEditorModel.pushOperation({
                    type: "kanban_wrap_main",
                    wrap_type: "footer",
                });
            }
            return {
                node: {
                    tag: "footer",
                },
                target: {
                    tag: "main",
                },
                position: "inside",
            };
        }
        case "t": {
            return { type: "kanban_menu" };
        }
        case "ribbon": {
            const cardTemplate = this.viewEditorModel.xmlDoc.querySelector(`[t-name="${KANBAN_CARD_ATTRIBUTE}"]`);
            let ribbonTarget;
            if (cardTemplate.children.length) {
                ribbonTarget = [`//kanban//t[@t-name="${KANBAN_CARD_ATTRIBUTE}"]/*[1]`, "before"];
            } else {
                ribbonTarget = [`//kanban//t[@t-name="${KANBAN_CARD_ATTRIBUTE}"]`, "inside"];
            }
            return {
                node: {
                    tag: "widget",
                    attrs: {
                        name: "web_ribbon",
                        title: "Demo",
                    },
                },

                target: this.env.viewEditorModel.getFullTarget(
                    ribbonTarget[0],
                    { isXpathFullAbsolute: false }
                ),
                position: ribbonTarget[1],
            };
        }
        case "kanban_colorpicker": {
            if (!this.viewEditorModel.xmlDoc.querySelector("t[t-name=menu]")) {
                this.env.viewEditorModel.pushOperation({
                    type: "kanban_menu",
                });
            }
            return {
                type: "kanban_colorpicker",
                view_id: this.env.viewEditorModel.mainView.id,
            };
        }
    }
}

function prepareForKanbanDrag({ element, ref }) {
    const hooksToStylize = [...ref.el.querySelectorAll(".o_web_studio_hook")].filter((e) =>
        e.dataset.structures?.split(",").includes(element.dataset.structure)
    );
    hooksToStylize.forEach((e) => e.classList.add("o_web_studio_hook_visible"));
    return () => {
        ref.el
            .querySelectorAll(".o_web_studio_hook_visible")
            .forEach((el) => el.classList.remove("o_web_studio_hook_visible"));
    };
}

const kanbanEditor = {
    ...kanbanView,
    Compiler: KanbanEditorCompiler,
    Controller: KanbanEditorController,
    ArchParser: EditorArchParser,
    Renderer: KanbanEditorRenderer,
    Record: KanbanEditorRecord,
    Model: OneRecordModel,
    Sidebar: KanbanEditorSidebar,
    isValidHook: isValidKanbanHook,
    addViewStructure: addKanbanViewStructure,
    prepareForDrag: prepareForKanbanDrag,
    props(genericProps, editor, config) {
        const props = kanbanView.props(genericProps, editor, config);
        props.defaultGroupBy = props.archInfo.defaultGroupBy;
        props.Model = makeModelErrorResilient(OneRecordModel);
        props.limit = 1;
        props.Renderer = KanbanEditorRenderer;
        return props;
    },
};

registry.category("studio_editors").add("kanban", kanbanEditor);

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_compiler.js  *
*  Lines: 230                                                                                           *
********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler', ['@web/views/kanban/kanban_compiler', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/core/utils/xml', '@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
const { KanbanCompiler } = require("@web/views/kanban/kanban_compiler");
const { computeXpath, applyInvisible } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { createElement, getTag } = require("@web/core/utils/xml");
const { isComponentNode } = require("@web/views/view_compiler");

const interestingSelector = [
    "div",
    "aside",
    "footer",
    "field",
    "main",
    "kanban",
    "widget",
    "a",
    "button",
].join(", ");

/**
 * @param {Element} el
 * @returns {string}
 */
function getElementXpath(el) {
    const xpath = el.getAttribute("studioXpath");
    if (isComponentNode(el)) {
        return xpath;
    }
    return `"${xpath}"`;
}

/**
 * @param {Element} el
 * @param {string} xpath
 */
function setElementXpath(el, xpath) {
    if (isComponentNode(el)) {
        el.setAttribute("studioXpath", `'${xpath}'`);
    } else {
        el.setAttribute("studioXpath", xpath);
    }
}

const KanbanEditorCompiler = __exports.KanbanEditorCompiler = class KanbanEditorCompiler extends KanbanCompiler {
    applyInvisible(invisible, compiled, params) {
        return applyInvisible(invisible, compiled, params);
    }

    /**
     * Wrap the given node with a <t> element containing hooks before and after it.
     * @param {Element} node - The node to wrap with hooks
     * @param {string} type - The type of the hook
     * @param {string} template - The template to use for the hook
     * @param {boolean} insertBefore - Whether to insert the before hook
     * @returns {Element} The wrapped node
     */
    addStudioHook(node, type, template, { structures, wrap = false } = {}) {
        const xpath = getElementXpath(node);
        if (wrap) {
            const studioHookBefore = createElement("StudioHook", {
                xpath,
                position: "'before'",
                type: `'${type}'`,
                subTemplate: `'${template}'`,
                structures,
            });
            node.insertAdjacentElement("beforebegin", studioHookBefore);
        }
        const studioHookAfter = createElement("StudioHook", {
            xpath,
            position: "'after'",
            type: `'${type}'`,
            subTemplate: `'${template}'`,
            structures,
        });
        node.insertAdjacentElement("afterend", studioHookAfter);
    }

    wrapNodesInMain(node) {
        const elementsToWrap = Array.from(node.children).filter((e) => {
            if (e.tagName === "widget") {
                return e.getAttribute("name") !== "web_ribbon";
            }
            if (e.tagName === "t" && e.getAttribute("t-name") === "menu") {
                return false;
            }
            return !["aside"].includes(e.tagName);
        });
        return createElement("main", elementsToWrap);
    }

    compile(key, params = {}) {
        const xml = this.templates[key];
        const interestingArchNodes = [...xml.querySelectorAll(interestingSelector)];
        for (const el of interestingArchNodes) {
            const xpath = computeXpath(el, "kanban");
            setElementXpath(el, xpath);
        }
        const compiled = super.compile(key, params);
        return compiled;
    }

    compileButton(el, params) {
        const compiled = super.compileButton(...arguments);
        setElementXpath(compiled, el.getAttribute("studioXpath"));
        return compiled;
    }

    compileCard(node, params) {
        const mainNode = node.querySelector("main");
        if (!mainNode) {
            // to ease the addition of studio hooks in the UI, we make sure the kanban card contains a <main> node,
            // which wraps the content of the card, even if the original template didn't compile this node
            const mainEl = this.wrapNodesInMain(node);
            setElementXpath(mainEl, "kanban");
            node.append(mainEl);
        }
        const asideNode = node.querySelector("aside");
        const ribbonNode = node.querySelector("widget[name='web_ribbon']");
        const compiledCard = super.compileNode(node, params);
        const compiledMain = compiledCard.querySelector("main");
        if (!ribbonNode) {
            this.addStudioHook(compiledMain, "ribbon", "kanbanRibbon");
        }
        if (!asideNode) {
            this.addStudioHook(compiledMain, "kanbanAsideHook", "kanbanAsideHook", { wrap: true });
        }
        return compiledCard;
    }

    compileField(el, params) {
        const compiled = super.compileField(...arguments);
        if (!el.hasAttribute("widget")) {
            compiled.classList.add("o-web-studio-editor--element-clickable");

            // Set empty class
            const fieldName = el.getAttribute("name");
            const recordValueExpr = `__comp__.props.record.data["${fieldName}"]`;
            const isEmptyExpr = `__comp__.isFieldValueEmpty(${recordValueExpr})`;
            compiled.setAttribute(
                "t-attf-class",
                `{{ ${isEmptyExpr} ? "o_web_studio_widget_empty" : "" }}`
            );
            const fieldNameExpr = `__comp__.props.record.fields["${fieldName}"].string`;
            const originalTOut = compiled.getAttribute("t-out");
            compiled.setAttribute("t-out", `${isEmptyExpr} ? ${fieldNameExpr} : ${originalTOut}`);
        } else {
            compiled.setAttribute("hasEmptyPlaceholder", true);
        }
        return compiled;
    }

    compileInnerSection(compiled) {
        const interestingNodes = [...compiled.querySelectorAll("[studioXpath]")].filter(
            (e) => e.getAttribute("studioXpath") !== "null" && !e.closest("ViewButton")
        );
        const otherNodes = [...compiled.querySelectorAll("div[studioXpath]")].filter(
            (e) => !e.getAttribute("t-out")
        );
        for (const child of otherNodes) {
            // add a visual indication around structuring elements of the main element
            child.classList.add("o_inner_section");
            child.classList.add("o-web-studio-editor--element-clickable");
        }
        for (const child of interestingNodes) {
            if (
                [...child.getAttributeNames()].filter((e) =>
                    ["t-if", "t-elif", "t-else"].includes(e)
                ).length
            ) {
                // Don't append a studio hook if a condition is on the tag itself
                // otherwise it may cause inconsistencies in the arch itself
                // ie `<field t-elif="someConditon" /><field name="newField" /><t t-else=""/>` would be invalid
                continue;
            }
            this.addStudioHook(
                child,
                "field",
                // for inline display, the studio hook must be a span to keep the current look
                child.tagName === "span" ? "kanbanInline" : "defaultTemplate",
                { structures: `'field'`, wrap: true }
            );
        }
        if (!interestingNodes.length) {
            const hook = createElement("StudioHook", {
                xpath: `"${compiled.getAttribute("studioXpath")}"`,
                position: "'inside'",
                type: "'field'",
                subTemplate: "defaultTemplate",
                structures: `'field'`,
            });
            compiled.appendChild(hook);
        }
    }

    compileNode(node, params) {
        let compiled;
        if (node.getAttribute?.("t-name") === "card") {
            compiled = this.compileCard(node);
        } else {
            compiled = super.compileNode(node, { ...params, compileInvisibleNodes: true });
        }
        if (["aside", "footer"].includes(getTag(node))) {
            compiled.classList.add("o_inner_section");
            compiled.classList.add("o-web-studio-editor--element-clickable");
            this.compileInnerSection(compiled);
        } else if (getTag(node) === "main") {
            this.compileInnerSection(compiled);
            if (!compiled.querySelector("footer")) {
                const footerHook = createElement("StudioHook", {
                    xpath: `"${compiled.getAttribute("studioXpath")}"`,
                    position: "'after'",
                    type: `'footer'`,
                    subTemplate: `'defaultTemplate'`,
                    structures: `'footer'`,
                });
                compiled.appendChild(footerHook);
            }
        }
        // Propagate the xpath to the compiled template for most nodes.
        if (node.nodeType === 1 && compiled && !compiled.attributes.studioXpath) {
            setElementXpath(compiled, node.getAttribute("studioXpath"));
        }
        return compiled;
    }
}

return __exports;
});
;

/******************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_record.js  *
*  Lines: 120                                                                                         *
******************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record', ['@web/views/kanban/kanban_view', '@web_studio/client_action/view_editor/editors/components/field_studio', '@web_studio/client_action/view_editor/editors/components/widget_studio', '@web_studio/client_action/view_editor/editors/xml_utils', '@web_studio/client_action/view_editor/editors/components/view_button_studio', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@web/core/utils/hooks', '@odoo/owl', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler'], function (require) {
'use strict';
let __exports = {};
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { FieldStudio } = require("@web_studio/client_action/view_editor/editors/components/field_studio");
const { WidgetStudio } = require("@web_studio/client_action/view_editor/editors/components/widget_studio");
const { computeXpath } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { ViewButtonStudio } = require("@web_studio/client_action/view_editor/editors/components/view_button_studio");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");
const { useService } = require("@web/core/utils/hooks");

const { Component, toRaw, useEnv, useState, xml, onError } = require("@odoo/owl");
const { KanbanEditorCompiler } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler");

class FieldStudioKanbanRecord extends FieldStudio {
    isX2ManyEditable() {
        return false;
    }
}

const KanbanRecord = kanbanView.Renderer.components.KanbanRecord;

class KanbanEditorRecordMenu extends Component {
    static props = {
        slots: Object,
        studioXpath: String,
    };
    static template = xml`
        <div class="o_dropdown_kanban bg-transparent position-absolute end-0 top-0 o-web-studio-editor--element-clickable" t-att-studioXpath="props.studioXpath">
            <button class="btn o-no-caret rounded-0 pe-none" title="Dropdown menu">
                <span class="fa fa-ellipsis-v"/>
            </button>
        </div>
    `;
}

function useSafeKanban() {
    const state = useState({ hasError: false });
    const viewEditorModel = toRaw(useEnv().viewEditorModel);
    onError((error) => {
        const hasError = state.hasError;
        if (hasError || viewEditorModel.isInEdition) {
            throw error;
        }
        state.hasError = true;
    });
    return state;
}

class SafeKanbanRecord extends KanbanRecord {
    static template = "web_studio.SafeKanbanRecord";
    setup() {
        super.setup();
        this.safe = useSafeKanban();
    }
    onGlobalClick() {
        // prevent click handling by the component
    }
}

class _KanbanEditorRecord extends KanbanRecord {
    static template = "web_studio.SafeKanbanRecord";
    static menuTemplate = "web_studio.SafeKanbanRecordMenu";
    static components = {
        ...KanbanRecord.components,
        Field: FieldStudioKanbanRecord,
        Widget: WidgetStudio,
        StudioHook,
        ViewButton: ViewButtonStudio,
        KanbanRecordMenu: KanbanEditorRecordMenu,
    };
    setup() {
        super.setup();
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.dialogService = useService("dialog");
        this.safe = useSafeKanban();
    }
    onGlobalClick(ev) {
        const el = ev.target.closest(".o-web-studio-editor--element-clickable");
        if (el) {
            this.env.config.onNodeClicked(el.getAttribute("studioxpath"));
        }
    }
    isFieldValueEmpty(value) {
        if (value === null) {
            return true;
        }
        if (Array.isArray(value)) {
            return !value.length;
        }
        return !value;
    }
    get dropdownXpath() {
        const compiledTemplateMenu = this.props.templates[this.constructor.KANBAN_MENU_ATTRIBUTE];
        return computeXpath(compiledTemplateMenu, "kanban");
    }
}

const KanbanEditorRecord = __exports.KanbanEditorRecord = class KanbanEditorRecord extends Component {
    static props = [...KanbanRecord.props];
    static template = xml`<t t-component="KanbanRecord" t-props="kanbanRecordProps" />`;

    get KanbanRecord() {
        if (this.env.viewEditorModel.mode !== "interactive") {
            return SafeKanbanRecord;
        } else {
            return _KanbanEditorRecord;
        }
    }
    get kanbanRecordProps() {
        const props = { ...this.props };
        if (this.env.viewEditorModel.mode === "interactive") {
            props.Compiler = KanbanEditorCompiler;
        }
        return props;
    }
}

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_renderer.js  *
*  Lines: 63                                                                                            *
********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_renderer', ['@web/views/kanban/kanban_view', '@web/views/kanban/kanban_header', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { KanbanHeader } = require("@web/views/kanban/kanban_header");
const { KanbanEditorRecord } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record");
const { useRef, useEffect } = require("@odoo/owl");

class KanbanEditorHeader extends KanbanHeader {
    static template = "web_studio.KanbanEditorHeader";
}

const KanbanEditorRenderer = __exports.KanbanEditorRenderer = class KanbanEditorRenderer extends kanbanView.Renderer {
    static template = "web_studio.KanbanEditorRenderer";
    static components = {
        ...kanbanView.Renderer.components,
        KanbanRecord: KanbanEditorRecord,
        KanbanHeader: KanbanEditorHeader,
    };

    setup() {
        super.setup();
        const rootRef = useRef("root");
        useEffect(
            (el) => {
                if (!el) {
                    return;
                }
                el.classList.add("o_web_studio_kanban_view_editor");
            },
            () => [rootRef.el]
        );
    }

    get canUseSortable() {
        return false;
    }

    get showNoContentHelper() {
        return false;
    }

    getGroupsOrRecords() {
        const { list } = this.props;
        const groupsOrRec = super.getGroupsOrRecords(...arguments);
        if (list.isGrouped) {
            return [groupsOrRec.filter((el) => el.group.list.records.length)[0]];
        } else {
            return [groupsOrRec[0]];
        }
    }

    canCreateGroup() {
        return false;
    }

    getGroupUnloadedCount() {
        return 0;
    }
}

return __exports;
});
;

/*****************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/kanban_editor_sidebar.js  *
*  Lines: 211                                                                                                                *
*****************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/kanban_editor_sidebar', ['@odoo/owl', '@web/core/l10n/translation', '@web_studio/client_action/view_editor/editors/components/view_structures', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/editors/components/view_fields', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/interactive_editor/properties/properties', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_button_properties/kanban_button_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/aside_properties/aside_properties', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/footer_properties/footer_properties', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/menu_properties/menu_properties', '@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/div_properties/div_properties'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { ViewStructures } = require("@web_studio/client_action/view_editor/editors/components/view_structures");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { ExistingFields } = require("@web_studio/client_action/view_editor/editors/components/view_fields");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { Properties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/properties");
const { KanbanButtonProperties } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_button_properties/kanban_button_properties");
const { FieldProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties");
const { WidgetProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");
const { AsideProperties } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/aside_properties/aside_properties");
const { FooterProperties } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/footer_properties/footer_properties");
const { MenuProperties } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/menu_properties/menu_properties");
const { DivProperties } = require("@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/div_properties/div_properties");

class KanbanFieldProperties extends FieldProperties {
    onChangeAttribute(value, name) {
        if (name === "bold") {
            let cls = this.props.node.attrs.class;
            if (value) {
                cls = cls ? `fw-bold ${cls}` : "fw-bold";
            } else {
                cls = cls
                    .split(" ")
                    .filter((c) => c !== "fw-bold" && c !== "fw-bolder")
                    .join(" ");
            }
            return this.editNodeAttributes({ class: cls });
        }
        return super.onChangeAttribute(...arguments);
    }
}

const KanbanEditorSidebar = __exports.KanbanEditorSidebar = class KanbanEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.KanbanEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        ExistingFields,
        Property,
        Properties,
        ViewStructures,
        SidebarViewToolbox,
    };
    static get viewStructures() {
        return {
            aside: {
                name: _t("Side panel"),
                class: "o_web_studio_field_aside",
                isVisible: (vem) => !vem.controllerProps.arch.querySelector("aside"),
            },
            footer: {
                name: _t("Footer"),
                class: "o_web_studio_field_footer",
                isVisible: (vem) => !vem.controllerProps.arch.querySelector("footer"),
            },
            t: {
                name: _t("Menu"),
                class: "o_web_studio_field_menu",
                isVisible: (vem) => !vem.controllerProps.arch.querySelector("t[t-name=menu]"),
            },
            ribbon: {
                name: _t("Ribbon"),
                class: "o_web_studio_field_ribbon",
                isVisible: (vem) =>
                    !vem.controllerProps.arch.querySelector("widget[name=web_ribbon]"),
            },
            kanban_colorpicker: {
                name: _t("Color Picker"),
                class: "o_web_studio_field_color_picker",
                isVisible: (vem) =>
                    !vem.controllerProps.arch.querySelector("field[widget=kanban_color_picker]"),
            },
        };
    }

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
        this.propertiesComponents = {
            a: {
                component: KanbanButtonProperties,
            },
            button: {
                component: KanbanButtonProperties,
            },
            field: {
                component: KanbanFieldProperties,
                props: {
                    availableOptions: ["invisible", "string", "bold"],
                },
            },
            aside: {
                component: AsideProperties,
            },
            div: {
                component: DivProperties,
            },
            footer: {
                component: FooterProperties,
            },
            t: {
                component: MenuProperties,
            },
            widget: {
                component: WidgetProperties,
            },
        };
    }

    get archInfo() {
        return this.viewEditorModel.controllerProps.archInfo;
    }

    get colorField() {
        return {
            choices: fieldsToChoices(this.viewEditorModel.fields, ["integer"]),
            required: false,
        };
    }

    get defaultGroupBy() {
        return {
            choices: fieldsToChoices(
                this.viewEditorModel.fields,
                this.viewEditorModel.GROUPABLE_TYPES,
                (field) => field.store
            ),
            required: false,
        };
    }

    get defaultOrder() {
        if (this.archInfo.defaultOrder.length >= 1) {
            return this.archInfo.defaultOrder[0];
        } else {
            return { name: "", asc: true };
        }
    }

    get sortChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) => field.store
        );
    }

    get orderChoices() {
        return [
            { value: "asc", label: _t("Ascending") },
            { value: "desc", label: _t("Descending") },
        ];
    }

    setSortBy(value) {
        this.onSortingChanged(value, this.defaultOrder.asc ? "asc" : "desc");
    }

    setOrder(value) {
        this.onSortingChanged(this.defaultOrder.name, value);
    }

    onSortingChanged(sortBy, order) {
        if (sortBy) {
            this.editAttribute(`${sortBy} ${order}`, "default_order");
        } else {
            this.editAttribute("", "default_order");
        }
    }

    editAttribute(value, name) {
        return this.editArchAttributes({ [name]: value });
    }

    editDefaultGroupBy(value) {
        this.editAttribute(value || "", "default_group_by");
    }

    editColor(value) {
        if (value && !this.viewEditorModel.fieldsInArch.includes(value)) {
            this.viewEditorModel.doOperation({
                type: "add",
                target: {
                    tag: "kanban",
                },
                position: "inside",
                node: {
                    attrs: {
                        name: value,
                        invisible: "1",
                    },
                    tag: "field",
                },
            });
        }
        this.editAttribute(value || "", "highlight_color");
    }
}

return __exports;
});
;

/****************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/aside_properties/aside_properties.js  *
*  Lines: 31                                                                                                                                        *
****************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/aside_properties/aside_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const AsideProperties = __exports.AsideProperties = class AsideProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Aside";
    static components = {
        ClassAttribute,
        Property,
        ViewStructureProperties,
    };
    static props = {
        node: { type: Object },
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/div_properties/div_properties.js  *
*  Lines: 33                                                                                                                                    *
************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/div_properties/div_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");

const DivProperties = __exports.DivProperties = class DivProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Div";
    static components = {
        ClassAttribute,
        ModifiersProperties,
        Property,
        ViewStructureProperties,
    };
    static props = {
        node: { type: Object },
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/******************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/footer_properties/footer_properties.js  *
*  Lines: 31                                                                                                                                          *
******************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/footer_properties/footer_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const FooterProperties = __exports.FooterProperties = class FooterProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Footer";
    static components = {
        ClassAttribute,
        Property,
        ViewStructureProperties,
    };
    static props = {
        node: { type: Object },
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/********************************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_button_properties/kanban_button_properties.js  *
*  Lines: 36                                                                                                                                                        *
********************************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_button_properties/kanban_button_properties', ['@web/core/l10n/translation', '@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { LimitGroupVisibility } = require("@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const KanbanButtonProperties = __exports.KanbanButtonProperties = class KanbanButtonProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.KanbanButton";
    static props = {
        node: { type: Object },
    };
    static components = {
        ClassAttribute,
        LimitGroupVisibility,
        ModifiersProperties,
        Property,
        SidebarPropertiesToolbox,
    };
    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
        // We don't want to display a in the sidebar.
        this.env.viewEditorModel.activeNode.humanName = _t("Button");
    }
    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/**************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/menu_properties/menu_properties.js  *
*  Lines: 28                                                                                                                                      *
**************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/menu_properties/menu_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");

const MenuProperties = __exports.MenuProperties = class MenuProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Menu";
    static components = {
        Property,
        SidebarPropertiesToolbox,
    };
    static props = {
        node: { type: Object },
    };
    get colorPicker() {
        return this.env.viewEditorModel.controllerProps.arch.querySelector(
            "field[widget=kanban_color_picker]"
        );
    }
    editColorPicker() {
        this.env.viewEditorModel.activeNodeXpath = this.colorPicker.getAttribute("studioXpath");
    }
}

return __exports;
});
;

/**********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_compiler_legacy.js  *
*  Lines: 263                                                                                                         *
**********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_compiler_legacy', ['@web/views/kanban/kanban_arch_parser', '@web/views/kanban/kanban_compiler', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/views/view_compiler', '@web/core/utils/xml', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { LEGACY_KANBAN_MENU_ATTRIBUTE } = require("@web/views/kanban/kanban_arch_parser");
const { KanbanCompiler } = require("@web/views/kanban/kanban_compiler");
const { computeXpath, applyInvisible } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { isComponentNode } = require("@web/views/view_compiler");
const { createElement } = require("@web/core/utils/xml");
const { _t } = require("@web/core/l10n/translation");

const interestingSelector = [
    "field",
    "widget",
    ".dropdown",
    "img.oe_kanban_avatar",
    ".o_kanban_record_body",
    ".o_kanban_record_bottom",
].join(", ");

const hookBaseClass = "o_web_studio_kanban_hook cursor-pointer text-primary fw-bolder ";

const KanbanEditorCompilerLegacy = __exports.KanbanEditorCompilerLegacy = class KanbanEditorCompilerLegacy extends KanbanCompiler {
    constructor() {
        super(...arguments);
        const kanbanBox = this.templates["kanban-box"];
        this.isDashboard = kanbanBox.closest("kanban").classList.contains("o_kanban_dashboard");
    }

    applyInvisible(invisible, compiled, params) {
        return applyInvisible(invisible, compiled, params);
    }

    compile(key, params = {}) {
        const xml = this.templates[key];

        // One pass to compute and add the xpath for the arch's node location
        // onto that node.
        const mainDiv = xml.querySelector("div");
        const interestingArchNodes = [...xml.querySelectorAll(interestingSelector)];
        if (mainDiv) {
            interestingArchNodes.push(mainDiv);
        }
        for (const el of interestingArchNodes) {
            const xpath = computeXpath(el, "kanban");
            el.setAttribute("studioXpath", xpath);
        }

        const compiled = super.compile(key, params);

        const isKanbanBox = key === "kanban-box";

        if (isKanbanBox && !this.isDashboard && mainDiv) {
            const tagsWidget = xml.querySelector("field[widget='many2many_tags']");
            if (!tagsWidget) {
                this.addTagsWidgetHook(compiled);
            }

            const priorityWidget = xml.querySelector("field[widget='priority']");
            const favoriteWidget = xml.querySelector("field[widget='boolean_favorite']");
            if (!priorityWidget && !favoriteWidget) {
                this.addPriorityHook(compiled);
            }

            const dropdown = this.templates[LEGACY_KANBAN_MENU_ATTRIBUTE];
            if (!dropdown) {
                this.addDropdownHook(compiled);
            }

            const avatarImg = xml.querySelector("img.oe_kanban_avatar");
            if (!avatarImg) {
                this.addAvatarHook(compiled);
            }
        }

        compiled.querySelectorAll(".oe_kanban_avatar").forEach((el) => {
            const tIf = el.closest("[t-if]");
            if (tIf) {
                const tElse = createElement("t", {
                    "t-else": "",
                    "t-call": "web_studio.KanbanEditorRecord.AvatarPlaceholder",
                });
                tIf.insertAdjacentElement("afterend", tElse);
            }
        });

        return compiled;
    }

    compileField(node) {
        const compiled = super.compileField(...arguments);
        if (compiled.tagName === "span") {
            const fieldName = node.getAttribute("name");
            compiled.setAttribute("data-field-name", fieldName);
        } else {
            compiled.setAttribute("hasEmptyPlaceholder", true);
        }

        return compiled;
    }

    addStudioHook(node, compiled) {
        const tNode = createElement("t");
        if (compiled.hasAttribute("t-if")) {
            // t-if from the invisible modifier
            tNode.setAttribute("t-if", compiled.getAttribute("t-if"));
            compiled.removeAttribute("t-if");
        }
        tNode.appendChild(compiled);
        const xpath = node.getAttribute("studioXpath");
        const studioHook = createElement("StudioHook", {
            xpath: `"${xpath}"`,
            position: "'after'",
        });
        tNode.appendChild(studioHook);
        return tNode;
    }

    compileNode(node, params) {
        const nodeType = node.nodeType;
        if (nodeType === 1 && (isComponentNode(node) || node.getAttribute("studio_no_fetch"))) {
            return;
        }

        let compiled = super.compileNode(node, { ...params, compileInvisibleNodes: true });

        if (nodeType === 1 && compiled) {
            // Put a xpath on anything of interest.
            if (node.hasAttribute("studioXpath")) {
                const xpath = node.getAttribute("studioXpath");
                if (isComponentNode(compiled)) {
                    compiled.setAttribute("studioXpath", `"${xpath}"`);
                } else if (!compiled.hasAttribute("studioXpath")) {
                    compiled.setAttribute("studioXpath", xpath);
                }

                if (node.classList.contains("oe_kanban_avatar")) {
                    compiled.setAttribute(
                        "t-on-click",
                        `(ev) => __comp__.env.config.onNodeClicked("${xpath}")`
                    );
                    compiled.classList.add("o-web-studio-editor--element-clickable");
                }
                if (node.tagName === "field" && !isComponentNode(compiled)) {
                    compiled.setAttribute(
                        "t-on-click",
                        `(ev) => __comp__.env.config.onNodeClicked("${xpath}")`
                    );
                    compiled.classList.add("o-web-studio-editor--element-clickable");

                    const fieldName = node.getAttribute("name");
                    const isEmptyExpr = `__comp__.isFieldValueEmpty(record["${fieldName}"].value)`;

                    // Set empty class
                    const tattfClassEmpty = `{{ ${isEmptyExpr} ? "o_web_studio_widget_empty" : "" }}`;

                    const tattfClass = compiled.getAttribute("t-attf-class");

                    const nextAttfClass = tattfClass
                        ? `${tattfClass} ${tattfClassEmpty}`
                        : tattfClassEmpty;
                    compiled.setAttribute("t-attf-class", nextAttfClass);

                    // Set field name on empty
                    const fieldId = node.getAttribute("field_id");
                    const tOut = compiled.getAttribute("t-out");
                    compiled.setAttribute(
                        "t-out",
                        `${isEmptyExpr} ? __comp__.props.archInfo.fieldNodes['${fieldId}'].string : ${tOut}`
                    );
                }
                if (node.tagName === "field" || node.tagName === "widget") {
                    // Don't append a studio hook if a condition is on the tag itself
                    // otherwise it may cause inconsistencies in the arch itself
                    // ie `<field t-elif="someCondifiton" /><field name="newField" /><t t-else=""/>` would be invalid
                    if (
                        !Array.from(node.getAttributeNames()).filter((att) =>
                            ["t-if", "t-elif", "t-else"].includes(att)
                        )[0]
                    ) {
                        compiled = this.addStudioHook(node, compiled);
                    }
                }
            }
        }
        return compiled;
    }

    addTagsWidgetHook(compiled) {
        const parentElement =
            compiled.querySelector(".o_kanban_record_body") || compiled.querySelector("div");
        const tagsHook = createElement("span", {
            class: hookBaseClass + "o_web_studio_add_kanban_tags",
            "t-on-click": `() => __comp__.onAddTagsWidget({
                xpath: "${parentElement.getAttribute("studioXpath")}"
            })`,
        });
        tagsHook.textContent = _t("Add tags");

        if (parentElement.firstChild) {
            parentElement.insertBefore(tagsHook, parentElement.firstChild);
        } else {
            parentElement.appendChild(tagsHook);
        }
    }

    addDropdownHook(compiled) {
        const rootSibling = compiled.querySelector("div");
        const dropdownHook = createElement(
            "div",
            [
                createElement("a", {
                    class: "btn fa fa-ellipsis-v",
                }),
            ],
            {
                class:
                    hookBaseClass +
                    "o_web_studio_add_dropdown o_dropdown_kanban dropdown position-absolute end-0",
                style: "z-index: 1;",
                "t-on-click": "() => __comp__.onAddDropdown()",
            }
        );
        rootSibling.insertAdjacentElement("afterend", dropdownHook);
    }

    addPriorityHook(compiled) {
        const parentElement = compiled.querySelector("div");
        const priorityHook = createElement("div", {
            class:
                hookBaseClass +
                "o_web_studio_add_priority oe_kanban_bottom_left align-self-start flex-grow-0",
            style: "z-index: 1;",
            "t-on-click": "() => __comp__.onAddPriority()",
        });
        priorityHook.textContent = _t("Add a priority");
        parentElement.appendChild(priorityHook);
    }

    addAvatarHook(compiled) {
        const parentElement =
            compiled.querySelector(".o_kanban_record_bottom") || compiled.querySelector("div");
        const avatarHook = createElement("div", {
            class: hookBaseClass + "o_web_studio_add_kanban_image oe_kanban_bottom_right pe-auto",
            style: "z-index: 1;",
            "t-on-click": "() => __comp__.onAddAvatar()",
        });
        avatarHook.textContent = _t("Add an avatar");
        parentElement.appendChild(avatarHook);
    }

    /**
     * In v16, some views use forbidden owl directives (t-on) directly
     * in the arch. In master, they will be removed. The validation is deactivated
     * in the js_class used to render those archs, but as in studio we do not use
     * the js_class, we have to disable the validation in the editor.
     * @override
     */
    validateNode() {}
}

return __exports;
});
;

/*************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_legacy.js  *
*  Lines: 110                                                                                                *
*************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_legacy', ['@web/core/registry', '@web/core/utils/objects', '@web/views/kanban/kanban_view', '@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_renderer_legacy', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/kanban_editor_sidebar_legacy'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { registry } = require("@web/core/registry");
const { omit } = require("@web/core/utils/objects");
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { KanbanEditorRendererLegacy } = require("@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_renderer_legacy");
const { makeModelErrorResilient } = require("@web_studio/client_action/view_editor/editors/utils");
const { KanbanEditorSidebarLegacy } = require("@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/kanban_editor_sidebar_legacy");
const { getStudioNoFetchFields, useModelConfigFetchInvisible } = require("@web_studio/client_action/view_editor/editors/utils");

class EditorArchParser extends kanbanView.ArchParser {
    parse(arch, models, modelName) {
        const parsed = super.parse(...arguments);
        const noFetch = getStudioNoFetchFields(parsed.fieldNodes);
        parsed.fieldNodes = omit(parsed.fieldNodes, ...noFetch.fieldNodes);
        parsed.progressAttributes = false;
        parsed.canOpenRecords = false;
        return parsed;
    }
}
class OneRecordModel extends kanbanView.Model {
    async load() {
        this.progressAttributes = false;
        await super.load(...arguments);
        let list = this.root;
        let hasRecords;
        const isGrouped = list.isGrouped;
        if (!isGrouped) {
            hasRecords = list.records.length;
        } else {
            hasRecords = list.groups.some((g) => g.list.records.length);
        }
        if (!hasRecords) {
            if (isGrouped) {
                const commonConfig = {
                    resModel: list.config.resModel,
                    fields: list.config.fields,
                    activeFields: list.config.activeFields,
                    groupByFieldName: list.groupByField.name,
                    context: list.context,
                    list: {
                        resModel: list.config.resModel,
                        fields: list.config.fields,
                        activeFields: list.config.activeFields,
                        groupBy: [],
                        context: list.context,
                    },
                };

                const data = {
                    count: 0,
                    length: 0,
                    records: [],
                    __domain: [],
                    value: "fake",
                    displayName: "fake",
                    groups: [
                        {
                            display_name: false,
                            count: 0,
                        },
                    ],
                };

                list.config.groups.fake = commonConfig;

                const group = list._createGroupDatapoint(data);
                list.groups.push(group);
                list = group.list;
            }
            await list.addNewRecord();
        }
    }
}

class KanbanEditorControllerLegacy extends kanbanView.Controller {
    setup() {
        super.setup();
        useModelConfigFetchInvisible(this.model);
    }

    get modelParams() {
        const params = super.modelParams;
        params.groupsLimit = 1;
        return params;
    }
}

const kanbanEditor = {
    ...kanbanView,
    Controller: KanbanEditorControllerLegacy,
    ArchParser: EditorArchParser,
    Renderer: KanbanEditorRendererLegacy,
    Model: OneRecordModel,
    Sidebar: KanbanEditorSidebarLegacy,
    props(genericProps, editor, config) {
        const props = kanbanView.props(genericProps, editor, config);
        props.defaultGroupBy = props.archInfo.defaultGroupBy;
        props.Model = makeModelErrorResilient(OneRecordModel);
        props.limit = 1;
        props.Renderer = KanbanEditorRendererLegacy;
        return props;
    },
};
registry.category("studio_editors").add("kanban_legacy", kanbanEditor);

return __exports;
});
;

/********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_record_legacy.js  *
*  Lines: 231                                                                                                       *
********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_record_legacy', ['@web/core/l10n/translation', '@web/views/kanban/kanban_view', '@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_compiler_legacy', '@web_studio/client_action/view_editor/editors/components/field_studio', '@web_studio/client_action/view_editor/editors/components/widget_studio', '@web_studio/client_action/view_editor/editors/components/view_button_studio', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@web_studio/client_action/view_editor/editors/components/field_selector_dialog', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/core/utils/hooks', '@web/core/confirmation_dialog/confirmation_dialog', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { kanbanView } = require("@web/views/kanban/kanban_view");

const { KanbanEditorCompilerLegacy } = require("@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_compiler_legacy");
const { FieldStudio } = require("@web_studio/client_action/view_editor/editors/components/field_studio");
const { WidgetStudio } = require("@web_studio/client_action/view_editor/editors/components/widget_studio");
const { ViewButtonStudio } = require("@web_studio/client_action/view_editor/editors/components/view_button_studio");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");
const { FieldSelectorDialog } = require("@web_studio/client_action/view_editor/editors/components/field_selector_dialog");

const { computeXpath } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { useService } = require("@web/core/utils/hooks");
const { AlertDialog, ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const { Component, toRaw, useEnv, useState, xml, useEffect, useRef, onError } = require("@odoo/owl");

class FieldStudioKanbanRecord extends FieldStudio {
    isX2ManyEditable() {
        return false;
    }
}

const OriginDropdown = kanbanView.Renderer.components.KanbanRecord.components.Dropdown;
class Dropdown extends OriginDropdown {
    static template = "web_studio.KanbanEditorRecord.Dropdown";
    static props = {
        ...OriginDropdown.props,
        studioXpath: { type: String, optional: 1 },
        hasCoverSetter: { type: Boolean, optional: 1 },
    };

    setup() {
        super.setup();
        const rootRef = useRef("root");
        useEffect(
            (rootEl) => {
                if (this.props.studioXpath) {
                    rootEl.classList.add("o-web-studio-editor--element-clickable");
                    rootEl.dataset.studioXpath = this.props.studioXpath;
                }

                if (this.props.hasCoverSetter) {
                    rootEl.dataset.hasCoverSetter = true;
                }
            },
            () => [rootRef.el]
        );
    }

    handleClick() {
        this.env.config.onNodeClicked(this.props.studioXpath);
    }
}

const KanbanRecord = kanbanView.Renderer.components.KanbanRecord;

function useSafeKanban() {
    const state = useState({ hasError: false });
    const viewEditorModel = toRaw(useEnv().viewEditorModel);
    onError((error) => {
        const hasError = state.hasError;
        if (hasError || viewEditorModel.isInEdition) {
            throw error;
        }
        state.hasError = true;
    });
    return state;
}

class SafeKanbanRecordLegacy extends KanbanRecord {
    static template = "web_studio.SafeKanbanRecordLegacy";
    setup() {
        super.setup();
        this.safe = useSafeKanban();
    }
}

class _KanbanEditorRecord extends KanbanRecord {
    static template = "web_studio.SafeKanbanRecordLegacy";
    static menuTemplate = "web_studio.SafeKanbanRecordLegacyMenu";
    static components = {
        ...KanbanRecord.components,
        Dropdown,
        Field: FieldStudioKanbanRecord,
        Widget: WidgetStudio,
        StudioHook,
        ViewButton: ViewButtonStudio,
    };
    setup() {
        super.setup();
        this.viewEditorModel = useState(this.env.viewEditorModel);
        if (this.constructor.LEGACY_KANBAN_MENU_ATTRIBUTE in this.props.templates) {
            const compiledTemplateMenu =
                this.props.templates[this.constructor.LEGACY_KANBAN_MENU_ATTRIBUTE];
            this.dropdownXpath = computeXpath(compiledTemplateMenu, "kanban");
            this.dropdownHasCoverSetter = Boolean(
                compiledTemplateMenu.querySelectorAll("a[data-type='set_cover']").length
            );
        }
        this.dialogService = useService("dialog");

        this.safe = useSafeKanban();
    }

    onGlobalClick() {}

    isFieldValueEmpty(value) {
        if (value === null) {
            return true;
        }
        if (Array.isArray(value)) {
            return !value.length;
        }
        return !value;
    }

    onAddTagsWidget({ xpath }) {
        const fields = [];
        for (const [fName, field] of Object.entries(this.props.record.fields)) {
            if (field.type === "many2many") {
                const _field = { ...field, name: fName };
                fields.push(_field);
            }
        }

        if (!fields.length) {
            this.dialogService.add(AlertDialog, {
                body: _t("You first need to create a many2many field in the form view."),
            });
            return;
        }

        this.dialogService.add(FieldSelectorDialog, {
            fields,
            onConfirm: (field) => {
                const operation = {
                    type: "add",
                    node: {
                        tag: "field",
                        attrs: { name: field },
                    },
                    target: this.env.viewEditorModel.getFullTarget(xpath),
                    position: "inside",
                };
                this.env.viewEditorModel.doOperation(operation);
            },
        });
    }

    onAddDropdown() {
        this.dialogService.add(ConfirmationDialog, {
            body: _t("Do you want to add a dropdown with colors?"),
            confirm: () => {
                this.env.viewEditorModel.doOperation({
                    type: "kanban_dropdown",
                });
            },
        });
    }

    onAddPriority() {
        const fields = [];
        const activeFields = Object.keys(this.props.record.activeFields);
        for (const [fName, field] of Object.entries(this.props.record.fields)) {
            if (field.type === "selection" && !activeFields.includes(fName)) {
                const _field = { ...field, name: fName };
                fields.push(_field);
            }
        }
        this.dialogService.add(FieldSelectorDialog, {
            fields,
            showNew: true,
            onConfirm: (field) => {
                this.env.viewEditorModel.doOperation({
                    type: "kanban_priority",
                    field,
                });
            },
        });
    }

    onAddAvatar() {
        const fields = [];
        for (const [fName, field] of Object.entries(this.props.record.fields)) {
            if (
                field.type === "many2one" &&
                (field.relation === "res.partner" || field.relation === "res.users")
            ) {
                const _field = { ...field, name: fName };
                fields.push(_field);
            }
        }
        this.dialogService.add(FieldSelectorDialog, {
            fields,
            onConfirm: (field) => {
                this.env.viewEditorModel.doOperation({
                    type: "kanban_image",
                    field,
                });
            },
        });
    }
}

const KanbanEditorRecordLegacy = __exports.KanbanEditorRecordLegacy = class KanbanEditorRecordLegacy extends Component {
    static props = [...KanbanRecord.props];
    static template = xml`<t t-component="KanbanRecord" t-props="kanbanRecordProps" />`;

    get KanbanRecord() {
        if (this.env.viewEditorModel.mode !== "interactive") {
            return SafeKanbanRecordLegacy;
        } else {
            return _KanbanEditorRecord;
        }
    }
    get kanbanRecordProps() {
        const props = { ...this.props };
        if (this.env.viewEditorModel.mode === "interactive") {
            props.Compiler = KanbanEditorCompilerLegacy;
        }
        return props;
    }
}

return __exports;
});
;

/**********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_renderer_legacy.js  *
*  Lines: 59                                                                                                          *
**********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_renderer_legacy', ['@web/views/kanban/kanban_view', '@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_record_legacy', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { KanbanEditorRecordLegacy } = require("@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_record_legacy");
const { useRef, useEffect } = require("@odoo/owl");

const KanbanEditorRendererLegacy = __exports.KanbanEditorRendererLegacy = class KanbanEditorRendererLegacy extends kanbanView.Renderer {
    static template = "web_studio.KanbanEditorRendererLegacy";
    static components = {
        ...kanbanView.Renderer.components,
        KanbanRecord: KanbanEditorRecordLegacy,
    };

    setup() {
        super.setup();
        const rootRef = useRef("root");
        useEffect(
            (el) => {
                if (!el) {
                    return;
                }
                el.classList.add("o_web_studio_kanban_view_editor");
                el.classList.add("o_web_studio_kanban_view_editor_legacy");
            },
            () => [rootRef.el]
        );
    }

    get canUseSortable() {
        return false;
    }

    get showNoContentHelper() {
        return false;
    }

    getGroupsOrRecords() {
        const { list } = this.props;
        const groupsOrRec = super.getGroupsOrRecords(...arguments);
        if (list.isGrouped) {
            return [groupsOrRec.filter((el) => el.group.list.records.length)[0]];
        } else {
            return [groupsOrRec[0]];
        }
    }

    canCreateGroup() {
        return false;
    }

    getGroupUnloadedCount() {
        return 0;
    }
}

return __exports;
});
;

/**************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/kanban_editor_sidebar_legacy.js  *
*  Lines: 127                                                                                                                                     *
**************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/kanban_editor_sidebar_legacy', ['@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/editors/components/view_fields', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/interactive_editor/properties/properties', '@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties', '@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/properties/kanban_cover_properties/kanban_cover_properties', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/utils', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { ExistingFields } = require("@web_studio/client_action/view_editor/editors/components/view_fields");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { Properties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/properties");
const { FieldProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties");
const { KanbanCoverProperties } = require("@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/properties/kanban_cover_properties/kanban_cover_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");
const { getFieldsInArch } = require("@web_studio/client_action/utils");
const { _t } = require("@web/core/l10n/translation");

class KanbanFieldProperties extends FieldProperties {
    onChangeAttribute(value, name) {
        if (name === "bold" && !value) {
            return this.editNodeAttributes({ [name]: "" });
        }
        return super.onChangeAttribute(...arguments);
    }
}

const KanbanEditorSidebarLegacy = __exports.KanbanEditorSidebarLegacy = class KanbanEditorSidebarLegacy extends Component {
    static template = "web_studio.ViewEditor.KanbanEditorSidebarLegacy";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        ExistingFields,
        Property,
        Properties,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
        this.propertiesComponents = {
            field: {
                component: KanbanFieldProperties,
                props: {
                    availableOptions: ["invisible", "string", "bold"],
                },
            },
            t: {
                component: KanbanCoverProperties,
            },
        };
    }

    get archInfo() {
        return this.viewEditorModel.controllerProps.archInfo;
    }

    get defaultGroupBy() {
        return {
            choices: fieldsToChoices(
                this.viewEditorModel.fields,
                this.viewEditorModel.GROUPABLE_TYPES,
                (field) => field.store
            ),
            required: false,
        };
    }

    get kanbanFieldsInArch() {
        // fields can be present in the xmlDoc to be preloaded, but not in
        // the actual template. Those must be present in the sidebar
        const kanbanXmlDoc = this.viewEditorModel.xmlDoc.querySelector("[t-name=kanban-box]");
        return getFieldsInArch(kanbanXmlDoc);
    }

    get defaultOrder() {
        if (this.archInfo.defaultOrder.length >= 1) {
            return this.archInfo.defaultOrder[0];
        } else {
            return { name: "", asc: true };
        }
    }

    get sortChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) => field.store
        );
    }

    get orderChoices() {
        return [
            { value: "asc", label: _t("Ascending") },
            { value: "desc", label: _t("Descending") },
        ];
    }

    setSortBy(value) {
        this.onSortingChanged(value, this.defaultOrder.asc ? "asc" : "desc");
    }

    setOrder(value) {
        this.onSortingChanged(this.defaultOrder.name, value);
    }

    onSortingChanged(sortBy, order) {
        if (sortBy) {
            this.editAttribute(`${sortBy} ${order}`, "default_order");
        } else {
            this.editAttribute("", "default_order");
        }
    }

    editAttribute(value, name) {
        return this.editArchAttributes({ [name]: value });
    }

    editDefaultGroupBy(value) {
        this.editAttribute(value || "", "default_group_by");
    }
}

return __exports;
});
;

/********************************************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/properties/kanban_cover_properties/kanban_cover_properties.js  *
*  Lines: 95                                                                                                                                                                    *
********************************************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/kanban_legacy/kanban_editor_sidebar_legacy/properties/kanban_cover_properties/kanban_cover_properties', ['@web/core/l10n/translation', '@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web/core/utils/hooks', '@web_studio/client_action/view_editor/editors/components/field_selector_dialog', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { useService } = require("@web/core/utils/hooks");
const { FieldSelectorDialog } = require("@web_studio/client_action/view_editor/editors/components/field_selector_dialog");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");

const KanbanCoverProperties = __exports.KanbanCoverProperties = class KanbanCoverProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.KanbanCoverProperties";
    static props = {
        node: { type: Object },
    };
    static components = { Property, SidebarPropertiesToolbox };

    setup() {
        this.dialog = useService("dialog");
        // We don't want to display t in the sidebar.
        this.env.viewEditorModel.activeNode.humanName = _t("Dropdown");
    }

    get coverNode() {
        return this.env.viewEditorModel.xmlDoc.querySelector(
            "a[data-type='set_cover'],a[type='set_cover']"
        );
    }

    get coverValue() {
        return !!this.coverNode;
    }

    setCover(value, name) {
        const fields = [];

        for (const field of Object.values(this.env.viewEditorModel.fields)) {
            if (field.type === "many2one" && field.relation === "ir.attachment") {
                fields.push(field);
            }
        }

        this.dialog.add(FieldSelectorDialog, {
            fields: fields,
            showNew: true,
            onConfirm: (field) => {
                const operation = {
                    type: "kanban_set_cover",
                    field: field,
                };
                this.env.viewEditorModel.doOperation(operation);
            },
        });
    }

    onChangeCover(value, name) {
        if (!value) {
            const vem = this.env.viewEditorModel;
            const fieldToRemove = Object.entries(vem.controllerProps.archInfo.fieldNodes).filter(
                ([fName, fInfo]) => {
                    return fInfo.widget === "attachment_image";
                }
            );
            if (fieldToRemove.length !== 1) {
                return;
            }

            const extraNode = this.coverNode;
            const relevantAttr = ["type", "data-type"].filter((att) => {
                return extraNode.hasAttribute(att) && extraNode.getAttribute(att) === "set_cover";
            })[0];
            const operation = {
                target: {
                    attrs: { name: fieldToRemove[0][1].name },
                    tag: "field",
                    extra_nodes: [
                        {
                            tag: extraNode.tagName,
                            attrs: {
                                [relevantAttr]: "set_cover",
                            },
                        },
                    ],
                },
                type: "remove",
            };
            vem.doOperation(operation);
        } else {
            this.setCover(value, name);
        }
    }
}

return __exports;
});
;

/*******************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/list/list_editor.js  *
*  Lines: 146                                                                              *
*******************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/list/list_editor', ['@web/views/list/list_view', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/core/registry', '@web/core/utils/objects', '@web_studio/client_action/view_editor/editors/list/list_editor_renderer', '@odoo/owl', '@web_studio/client_action/view_editor/editors/list/list_editor_sidebar/list_editor_sidebar', '@web_studio/client_action/view_editor/editors/utils'], function (require) {
'use strict';
let __exports = {};
const { listView } = require("@web/views/list/list_view");
const { computeXpath } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { registry } = require("@web/core/registry");
const { omit } = require("@web/core/utils/objects");

const { ListEditorRenderer, columnsStyling } = require("@web_studio/client_action/view_editor/editors/list/list_editor_renderer");

const { Component, xml } = require("@odoo/owl");
const { ListEditorSidebar } = require("@web_studio/client_action/view_editor/editors/list/list_editor_sidebar/list_editor_sidebar");
const { getStudioNoFetchFields, useModelConfigFetchInvisible } = require("@web_studio/client_action/view_editor/editors/utils");

function parseStudioGroups(node) {
    if (node.hasAttribute("studio_groups")) {
        return node.getAttribute("studio_groups");
    }
}

class EditorArchParser extends listView.ArchParser {
    parse(arch, models, modelName) {
        const parsed = super.parse(...arguments);
        const noFetch = getStudioNoFetchFields(parsed.fieldNodes);
        parsed.fieldNodes = omit(parsed.fieldNodes, ...noFetch.fieldNodes);
        const noFetchFieldNames = noFetch.fieldNames;
        parsed.columns = parsed.columns.filter(
            (col) => col.type !== "field" || !noFetchFieldNames.includes(col.name)
        );
        return parsed;
    }

    parseFieldNode(node, models, modelName) {
        const parsed = super.parseFieldNode(...arguments);
        parsed.studioXpath = computeXpath(node, "list, tree");
        parsed.studio_groups = parseStudioGroups(node);
        return parsed;
    }

    parseWidgetNode(node, models, modelName) {
        const parsed = super.parseWidgetNode(...arguments);
        parsed.studioXpath = computeXpath(node, "list, tree");
        parsed.studio_groups = parseStudioGroups(node);
        return parsed;
    }

    processButton(node) {
        const parsed = super.processButton(node);
        parsed.studioXpath = computeXpath(node, "list, tree");
        parsed.studio_groups = parseStudioGroups(node);
        return parsed;
    }
}

/**
 * X2Many fields can have their subview edited. There are some challenges currently with the RelationalModel
 * - We need to inject the parent record in the evalContext. That way, within the subview's arch
 *   a snippet like `<field name="..." invisible="not parent.id" />` works.
 * - We already know the resIds we have, since we are coming from a x2m. There is no need to search_read them, just to read them
 * - The RelationalModel doesn't really supports creatic staticLists as the root record
 *
 * StaticList supports the two first needs and not DynamicList, we assume that the amount of hacking
 * would be slightly bigger if our starting point is DynamicList. Hence, we choose
 * to extend StaticList instead of DynamicList, and make it the root record of the model.
 */
function useParentedStaticList(model, parentRecord, resIds) {
    const config = model.config;
    config.resIds = resIds;
    config.offset = 0;
    config.limit = Math.max(7, resIds.length); // don't load everything

    model._createRoot = (config, data) => {
        const options = { parent: parentRecord };
        const list = new model.constructor.StaticList(model, { ...config }, data, options);
        list.selection = [];
        return list;
    };
}

class ListEditorController extends listView.Controller {
    static props = {
        ...listView.Controller.props,
        parentRecord: { type: Object, optional: true },
    };
    setup() {
        super.setup();
        useModelConfigFetchInvisible(this.model);
        if (this.props.parentRecord) {
            useParentedStaticList(this.model, this.props.parentRecord, this.props.resIds);
        }
    }
}

class ControllerShadow extends Component {
    static props = { ...ListEditorController.props };
    static template = xml`<t t-component="Component" t-props="componentProps" />`;
    get Component() {
        return ListEditorController;
    }

    get componentProps() {
        const props = { ...this.props };
        props.groupBy = [];
        return props;
    }
}

const listEditor = {
    ...listView,
    Controller: ControllerShadow,
    ArchParser: EditorArchParser,
    Renderer: ListEditorRenderer,
    props() {
        const props = listView.props(...arguments);
        props.allowSelectors = false;
        props.editable = false;
        props.showButtons = false;
        return props;
    },
    Sidebar: ListEditorSidebar,
};
registry.category("studio_editors").add("list", listEditor);

/**
 *  Drag/Drop styling
 */

const colNearestHookClass = "o_web_studio_nearest_hook";
listEditor.styleNearestHook = function styleNearestColumn(mainRef, nearestHook) {
    const xpath = nearestHook.dataset.xpath;
    const position = nearestHook.dataset.position;
    columnsStyling(
        mainRef.el,
        `.o_web_studio_hook[data-xpath='${xpath}'][data-position='${position}']`,
        [colNearestHookClass]
    );
};

listEditor.styleClickedElement = (mainRef, params) => {
    columnsStyling(mainRef.el, `[data-studio-xpath='${params.xpath}']:not(.o_web_studio_hook)`, [
        "o-web-studio-editor--element-clicked",
    ]);
};

return __exports;
});
;

/****************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/list/list_editor_renderer.js  *
*  Lines: 208                                                                                       *
****************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/list/list_editor_renderer', ['@web/views/list/list_view', '@web/core/utils/timing', '@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/action_button/action_button'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { listView } = require("@web/views/list/list_view");
const { useThrottleForAnimation } = require("@web/core/utils/timing");
const { reactive, useEffect, useState } = require("@odoo/owl");
const { AddButtonAction } = require("@web_studio/client_action/view_editor/interactive_editor/action_button/action_button");

const colSelectedClass = "o-web-studio-editor--element-clicked";
const colHoverClass = "o-web-studio--col-hovered";

function cleanStyling(mainEl, classNames) {
    mainEl.querySelectorAll(`${classNames.map((c) => `.${c}`)}`).forEach((el) => {
        el.classList.remove(...classNames);
    });
}

__exports.columnsStyling = columnsStyling; function columnsStyling(mainEl, colSelector, classNames) {
    mainEl.querySelectorAll(`td${colSelector}, th${colSelector}`).forEach((el) => {
        el.classList.add(...classNames);
    });
}

function getSelectableCol(target, colSelector) {
    if (target.closest("button")) {
        return null;
    }
    const colEl = target.closest(`td${colSelector}, th${colSelector}`);
    return colEl;
}

const ListEditorRenderer = __exports.ListEditorRenderer = class ListEditorRenderer extends listView.Renderer {
    static template = "web_studio.ListEditorRenderer";
    static recordRowTemplate = "web_studio.ListEditorRenderer.RecordRow";
    static components = {
        ...listView.Renderer.components,
        AddButtonAction,
    };

    setup() {
        const viewEditorModel = useState(this.env.viewEditorModel);
        this.viewEditorModel = reactive(viewEditorModel, () => {
            // Little trick to update our columns when showInvisible changes on the viewEditorModel
            // getActiveColumns reads that value
            this.columns = this.getActiveColumns(this.props.list);
            this.render();
        });
        super.setup();
        this.onTableHover = useThrottleForAnimation(this.onTableHover);

        useEffect(
            (rootEl) => {
                rootEl.classList.add("o_web_studio_list_view_editor");
            },
            () => [this.rootRef.el]
        );
    }

    get canResequenceRows() {
        return false;
    }

    getColumnClass(col) {
        let cls = super.getColumnClass(col);
        if (col.studioColumnInvisible) {
            cls += " o_web_studio_show_invisible";
        }
        return cls;
    }

    getCellClass(col, record) {
        let cls = super.getCellClass(col, record);
        if (col.studioColumnInvisible || super.evalInvisible(col.invisible, record)) {
            cls += " o_web_studio_show_invisible";
        }
        return cls;
    }

    getColumnHookData(col, position) {
        let xpath;
        if (!col) {
            return { xpath: "/list", position: "inside" };
        }
        if (col.type === "button_group") {
            if (position === "before") {
                xpath = col.buttons[0].studioXpath;
            } else {
                xpath = col.buttons[col.buttons.length - 1].studioXpath;
            }
        } else {
            xpath = col.studioXpath;
        }
        return {
            xpath,
            position,
        };
    }

    addColsHooks(_cols) {
        const attrs = { width: "4px" };
        const options = {};
        const cols = [];
        let hookId = 0;
        const firstCol = _cols.find((c) => c.optional !== "hide");
        const { xpath, position } = this.getColumnHookData(firstCol, "before");
        cols.push({
            type: "studio_hook",
            position,
            xpath,
            id: `studio_hook_${hookId++}_${(firstCol && firstCol.id) || 0}`,
            attrs,
            options,
        });
        for (const col of _cols) {
            if (col.optional === "hide") {
                continue;
            }
            cols.push(col);
            const { xpath, position } = this.getColumnHookData(col, "after");
            cols.push({
                type: "studio_hook",
                position,
                xpath,
                id: `studio_hook_${hookId++}_${col.id}`,
                attrs,
                options,
            });
        }
        return cols;
    }

    get allColumns() {
        let cols = this._allColumns;
        if (this.viewEditorModel.showInvisible) {
            cols = cols.map((c) => {
                return {
                    ...c,
                    optional: false,
                    studioColumnInvisible:
                        c.optional === "hide" || super.evalColumnInvisible(c.column_invisible),
                };
            });
        } else {
            cols = cols.filter((c) => !this.evalColumnInvisible(c.column_invisible));
        }
        return this.addColsHooks(cols);
    }

    set allColumns(cols) {
        this._allColumns = cols;
    }

    evalInvisible(modifier, record) {
        if (this.viewEditorModel.showInvisible) {
            return false;
        }
        return super.evalInvisible(modifier, record);
    }
    evalColumnInvisible(columnInvisible) {
        if (this.viewEditorModel.showInvisible) {
            return false;
        }
        return super.evalColumnInvisible(columnInvisible);
    }

    onTableHover(ev) {
        const table = this.tableRef.el;
        cleanStyling(table, [colHoverClass]);
        if (ev.type !== "mouseover") {
            return;
        }
        const colEl = getSelectableCol(ev.target, "[data-studio-xpath]");
        if (!colEl) {
            return;
        }
        const xpath = colEl.dataset.studioXpath;
        columnsStyling(table, `[data-studio-xpath='${xpath}']:not(.o_web_studio_hook)`, [
            colHoverClass,
        ]);
    }

    onTableClicked(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        const table = ev.currentTarget;
        cleanStyling(table, [colSelectedClass]);
        const colEl = getSelectableCol(ev.target, "[data-studio-xpath]");
        if (!colEl) {
            return;
        }
        this.env.config.onNodeClicked(colEl.dataset.studioXpath);
    }

    makeTooltipButton(button) {
        return JSON.stringify({
            button: {
                string: button.string,
                type: button.clickParams?.type,
                name: button.clickParams?.name,
            },
            debug: true,
        });
    }
}

return __exports;
});
;

/***********************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/list/list_editor_sidebar/list_editor_sidebar.js  *
*  Lines: 143                                                                                                          *
***********************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/list/list_editor_sidebar/list_editor_sidebar', ['@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/editors/components/view_fields', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/interactive_editor/properties/properties', '@web/core/l10n/translation', '@web/core/utils/strings', '@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/editors/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, useState } = require("@odoo/owl");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const {
    ExistingFields,
    NewFields,
} = require("@web_studio/client_action/view_editor/editors/components/view_fields");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { Properties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/properties");
const { _t } = require("@web/core/l10n/translation");
const { sprintf } = require("@web/core/utils/strings");
const { FieldProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");

class ListFieldNodeProperties extends FieldProperties {
    onChangeAttribute(value, name) {
        if (name !== "aggregate") {
            return super.onChangeAttribute(...arguments);
        }
        const activeNode = this.env.viewEditorModel.activeNode;
        const newAttrs = {
            avg: "",
            sum: "",
        };
        if (value && value !== "none") {
            const humanName = value === "sum" ? _t("Sum of %s") : _t("Average of %s");
            const fieldString = activeNode.attrs.string || activeNode.field.label;
            newAttrs[value] = sprintf(humanName, fieldString);
        }
        return this.editNodeAttributes(newAttrs);
    }
}

const ListEditorSidebar = __exports.ListEditorSidebar = class ListEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.ListEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        NewFields,
        ExistingFields,
        Property,
        Properties,
        SidebarViewToolbox,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
        this.propertiesComponents = {
            field: {
                component: ListFieldNodeProperties,
                props: {
                    availableOptions: [
                        "invisible",
                        "required",
                        "readonly",
                        "string",
                        "help",
                        "optional",
                    ],
                },
            },
        };
    }

    get archInfo() {
        return this.viewEditorModel.controllerProps.archInfo;
    }

    get defaultOrder() {
        if (this.archInfo.defaultOrder.length >= 1) {
            return this.archInfo.defaultOrder[0];
        } else {
            return { name: "", asc: true };
        }
    }

    get editableChoices() {
        return [
            { value: "", label: _t("Open form view") },
            { value: "top", label: _t("Add record on top") },
            { value: "bottom", label: _t("Add record at the bottom") },
        ];
    }

    get sortChoices() {
        // only have stored fields that are present in arch
        const storeFieldsInArch = Object.fromEntries(
            Object.values(this.archInfo.fieldNodes).map((field) => [field.name, this.viewEditorModel.fields[field.name]])
        );
        return fieldsToChoices(
            storeFieldsInArch,
            null,
            (field) => !["one2many", "many2many", "binary"].includes(field.type) && field.store
        );
    }

    get orderChoices() {
        return [
            { value: "asc", label: _t("Ascending") },
            { value: "desc", label: _t("Descending") },
        ];
    }

    get defaultGroupbyChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) => field.store
        );
    }

    setSortBy(value) {
        this.onSortingChanged(value, this.defaultOrder.asc ? "asc" : "desc");
    }

    setOrder(value) {
        this.onSortingChanged(this.defaultOrder.name, value);
    }

    onSortingChanged(sortBy, order) {
        if (sortBy) {
            this.onAttributeChanged(`${sortBy} ${order}`, "default_order");
        } else {
            this.onAttributeChanged("", "default_order");
        }
    }

    onAttributeChanged(value, name) {
        return this.editArchAttributes({ [name]: value });
    }
}

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/map/map_editor_sidebar.js  *
*  Lines: 111                                                                                    *
*************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/map/map_editor_sidebar', ['@web_map/map_view/map_view', '@web/core/registry', '@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web/model/record', '@web/views/fields/many2many_tags/many2many_tags_field', '@web_studio/client_action/view_editor/view_editor_model', '@web/core/record_selectors/multi_record_selector'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { mapView } = require("@web_map/map_view/map_view");
const { registry } = require("@web/core/registry");

const { Component, useState } = require("@odoo/owl");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { Record } = require("@web/model/record");
const { Many2ManyTagsField } = require("@web/views/fields/many2many_tags/many2many_tags_field");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { MultiRecordSelector } = require("@web/core/record_selectors/multi_record_selector");

const MapEditorSidebar = __exports.MapEditorSidebar = class MapEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.MapEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
        Record,
        Many2ManyTagsField,
        MultiRecordSelector,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
    }

    get modelParams() {
        return this.viewEditorModel.controllerProps.modelParams;
    }

    get multiRecordSelectorProps() {
        return {
            resModel: "ir.model.fields",
            update: this.changeAdditionalFields.bind(this),
            resIds: this.currentAdditionalFieldsIds,
            domain: [
                ["model", "=", this.viewEditorModel.resModel],
                ["ttype", "not in", ["many2many", "one2many", "binary"]],
            ],
        };
    }

    get currentAdditionalFieldsIds() {
        return (
            JSON.parse(
                this.viewEditorModel.xmlDoc.firstElementChild.getAttribute("studio_map_field_ids")
            ) || []
        );
    }

    onViewAttributeChanged(value, name) {
        value = value ? value : "";
        return this.editArchAttributes({ [name]: value });
    }

    get contactFieldChoices() {
        return Object.values(this.viewEditorModel.fields)
            .filter((field) => field.type === "many2one" && field.relation === "res.partner")
            .map((field) => ({ label: `${field.string} (${field.name})`, value: field.name }));
    }

    get defaultOrderChoices() {
        return Object.values(this.viewEditorModel.fields)
            .filter(
                (field) => field.store && !["one2many", "many2many", "binary"].includes(field.type)
            )
            .map((field) => ({ label: `${field.string} (${field.name})`, value: field.name }));
    }

    /**
     * @param {Array<Number>} resIds
     */
    changeAdditionalFields(resIds) {
        const currentFullIds = this.currentAdditionalFieldsIds;
        const newIds = resIds.filter((id) => !currentFullIds.includes(id));
        let toRemoveIds;

        const operationType = newIds.length ? "add" : "remove";

        if (operationType === "remove") {
            toRemoveIds = currentFullIds.filter((id) => !resIds.includes(id));
        }

        this.viewEditorModel.doOperation({
            type: "map_popup_fields",
            target: {
                operation_type: operationType,
                field_ids: operationType === "add" ? newIds : toRemoveIds,
            },
        });
    }
}

registry.category("studio_editors").add("map", {
    ...mapView,
    Sidebar: MapEditorSidebar,
});

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/pivot/pivot_editor.js  *
*  Lines: 156                                                                                *
*********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/pivot/pivot_editor', ['@odoo/owl', '@web/core/registry', '@web/views/pivot/pivot_view', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web_studio/client_action/view_editor/operations_utils', '@web_studio/client_action/view_editor/editors/utils', '@web/model/record', '@web/views/fields/many2many_tags/many2many_tags_field', '@web_studio/client_action/view_editor/view_editor_model', '@web/views/utils', '@web/core/record_selectors/multi_record_selector'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, useState } = require("@odoo/owl");
const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");

const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const operationUtils = require("@web_studio/client_action/view_editor/operations_utils");
const { fieldsToChoices } = require("@web_studio/client_action/view_editor/editors/utils");

const { Record } = require("@web/model/record");
const { Many2ManyTagsField } = require("@web/views/fields/many2many_tags/many2many_tags_field");

const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { computeReportMeasures } = require("@web/views/utils");
const { MultiRecordSelector } = require("@web/core/record_selectors/multi_record_selector");

function getFieldNameFromGroupby(str) {
    return str.split(":")[0];
}

const PivotEditorSidebar = __exports.PivotEditorSidebar = class PivotEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.PivotEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        Property,
        SidebarViewToolbox,
        Record,
        Many2ManyTagsField,
        MultiRecordSelector,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });
    }

    get possibleMeasures() {
        const { fieldAttrs, activeMeasures } = this.archInfo;
        return computeReportMeasures(this.viewEditorModel.fields, fieldAttrs, activeMeasures);
    }

    get multiRecordSelectorProps() {
        return {
            resModel: "ir.model.fields",
            update: this.changeMeasureFields.bind(this),
            resIds: this.currentMeasureFields,
            domain: [
                ["model", "=", this.viewEditorModel.resModel],
                ["name", "in", Object.keys(this.possibleMeasures)],
            ],
        };
    }

    get currentMeasureFields() {
        return (
            JSON.parse(
                this.viewEditorModel.xmlDoc.firstElementChild.getAttribute(
                    "studio_pivot_measure_field_ids"
                )
            ) || []
        );
    }

    get archInfo() {
        return this.viewEditorModel.controllerProps.modelParams.metaData;
    }

    get rowGroupBys() {
        return this.archInfo.rowGroupBys.map((fName) => getFieldNameFromGroupby(fName));
    }

    get colGroupBys() {
        return this.archInfo.colGroupBys.map((fName) => getFieldNameFromGroupby(fName));
    }

    /**
     * @param {Array<Number>} resIds
     */
    changeMeasureFields(resIds) {
        const currentFullIds = this.currentMeasureFields;
        const newIds = resIds.filter((id) => !currentFullIds.includes(id));
        let toRemoveIds;

        const operationType = newIds.length ? "add" : "remove";

        if (operationType === "remove") {
            toRemoveIds = currentFullIds.filter((id) => !resIds.includes(id));
        }

        this.viewEditorModel.doOperation({
            type: "pivot_measures_fields",
            target: {
                operation_type: operationType,
                field_ids: operationType === "add" ? newIds : toRemoveIds,
            },
        });
    }

    onGroupByChanged(type, newValue, oldValue) {
        const operation = operationUtils.viewGroupByOperation("pivot", type, newValue, oldValue);
        this.viewEditorModel.doOperation(operation);
    }

    onViewAttributeChanged(value, name) {
        value = value ? value : "";
        return this.editArchAttributes({ [name]: value });
    }

    get columnGroupbyChoices() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) =>
                field.store &&
                ![this.archInfo.rowGroupBys[0], this.archInfo.rowGroupBys[1]].includes(field.name)
        );
    }

    get rowGroupbyChoices_first() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) =>
                field.store &&
                ![this.archInfo.colGroupBys[0], this.archInfo.rowGroupBys[1]].includes(field.name)
        );
    }

    get rowGroupbyChoices_second() {
        return fieldsToChoices(
            this.viewEditorModel.fields,
            this.viewEditorModel.GROUPABLE_TYPES,
            (field) =>
                field.store &&
                ![this.archInfo.colGroupBys[0], this.archInfo.rowGroupBys[0]].includes(field.name)
        );
    }
}

registry.category("studio_editors").add("pivot", {
    ...pivotView,
    Sidebar: PivotEditorSidebar,
});

return __exports;
});
;

/***********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/search/search_editor.js  *
*  Lines: 499                                                                                  *
***********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/search/search_editor', ['@odoo/owl', '@web/core/registry', '@web_studio/client_action/view_editor/editors/xml_utils', '@web/core/utils/xml', '@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item', '@web_studio/client_action/view_editor/editors/components/studio_hook_component', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', '@web_studio/client_action/view_editor/editors/components/view_fields', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', '@web/core/l10n/translation', '@web/core/utils/functions', '@web/core/utils/hooks', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', '@web/views/standard_view_props', '@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration', '@web_studio/client_action/view_editor/editors/utils'], function (require) {
'use strict';
let __exports = {};
const { Component, useState } = require("@odoo/owl");
const { registry } = require("@web/core/registry");
const { computeXpath } = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { visitXML } = require("@web/core/utils/xml");
const { SidebarDraggableItem } = require("@web_studio/client_action/components/sidebar_draggable_item/sidebar_draggable_item");
const { StudioHook } = require("@web_studio/client_action/view_editor/editors/components/studio_hook_component");
const { InteractiveEditorSidebar } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar");
const { ExistingFields } = require("@web_studio/client_action/view_editor/editors/components/view_fields");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SidebarViewToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox");
const { _t } = require("@web/core/l10n/translation");
const { memoize } = require("@web/core/utils/functions");
const { useOwnedDialogs } = require("@web/core/utils/hooks");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");
const { standardViewProps } = require("@web/views/standard_view_props");
const {
    FieldConfigurationDialog,
    FilterConfiguration,
} = require("@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration");
const { randomName } = require("@web_studio/client_action/view_editor/editors/utils");

function getGroupByFieldNameFromString(str) {
    const matches = str.match(/(,\s*)?(["'])group_by\2\1(\s*:\s*)?\2(?<fieldName>.*)\2/);
    if (!matches) {
        return null;
    }
    if (!matches.groups) {
        return null;
    }
    return matches.groups.fieldName;
}

function isFilterGroupBy(node) {
    if (!node.hasAttribute("context")) {
        return false;
    }
    if (/(['"])group_by\1\s*:/.test(node.getAttribute("context"))) {
        return true;
    }
    return false;
}

/** CONTROLLER STUFF */
class SearchEditorArchParser {
    parse(xmlDoc) {
        this.fields = [];
        this.filters = [];
        this.groupBys = [];
        this.currentCategory = null;
        this.currentItems = { items: [] };

        visitXML(xmlDoc, this.visitNode.bind(this));
        this.changeCategory(null, true); // Flush

        return {
            fields: this.fields,
            filters: this.filters,
            groupBys: this.groupBys,
            xmlDoc,
        };
    }

    visitNode(node) {
        if (node.nodeType !== 1) {
            return;
        }

        const nodeName = node.nodeName;
        const studioXpath = computeXpath(node, "search");
        if (nodeName === "field") {
            this.changeCategory("field", true);
            const item = this.parseNode(node);
            item.studioXpath = studioXpath;
            this.fields.push(item);
            return false;
        }
        if (nodeName === "filter") {
            const category = isFilterGroupBy(node) ? "groupBy" : "filter";
            this.changeCategory(category);
            const item = this.parseNode(node);
            item.studioXpath = studioXpath;
            this.pushItem(item);
            return false;
        }
        if (nodeName === "separator") {
            this.changeCategory("filter", true);
            this.currentItems.separator = studioXpath;
            return false;
        }
        if (nodeName === "group") {
            this.changeCategory(null, true);
            Array.from(node.children).forEach(this.visitNode.bind(this));
            this.changeCategory(null, true);
            return false;
        }
    }

    parseNode(node) {
        const nodeName = node.nodeName;
        const invisible = node.getAttribute("invisible");
        if (nodeName === "field") {
            return {
                type: "field",
                name: node.getAttribute("name"),
                label: node.getAttribute("string"),
                invisible,
            };
        }
        if (nodeName === "separator") {
            return { type: "separator" };
        }
        if (nodeName === "filter") {
            const item = {
                type: "filter",
                name: node.getAttribute("name"),
                label: node.getAttribute("string") || node.getAttribute("help"),
                domain: node.getAttribute("domain"),
                invisible,
            };
            if (node.hasAttribute("context")) {
                const groupBy = getGroupByFieldNameFromString(node.getAttribute("context"));
                if (groupBy) {
                    item.groupBy = groupBy;
                    item.type = "groupBy";
                }
            }
            return item;
        }
    }

    pushItem(item) {
        this.currentItems.items.push(item);
    }

    changeCategory(category, force) {
        if (this.currentCategory !== category || force) {
            let itemsToPushIn;
            if (this.currentCategory === "filter") {
                itemsToPushIn = this.filters;
            } else if (this.currentCategory === "groupBy") {
                itemsToPushIn = this.groupBys;
            }
            if (itemsToPushIn) {
                itemsToPushIn.push(this.currentItems);
                this.currentItems = { items: [] };
            }
        }
        this.currentCategory = category || this.currentCategory;
    }
}

class SearchEditorController extends Component {
    static props = { ...standardViewProps, archInfo: { type: Object } };
    static template = "web_studio.SearchEditorController";
    static components = { StudioHook };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
    }

    get filtersGroups() {
        return this.props.archInfo.filters;
    }

    hasItems(group) {
        return group.some((g) => this.getItems(g.items));
    }

    get autoCompleteFields() {
        return this.props.archInfo.fields;
    }

    get groupByGroups() {
        return this.props.archInfo.groupBys;
    }

    getItems(items) {
        if (!this.viewEditorModel.showInvisible) {
            return items.filter((i) => i.invisible !== "True" && i.invisible !== "1");
        }
        return items;
    }

    getFirstHookProps(type) {
        const xpath = "/search";
        const position = "inside";

        const group = type === "filter" ? this.filtersGroups : this.groupByGroups;
        if (this.hasItems(group)) {
            return false;
        }
        const props = {
            xpath,
            position,
            type,
        };
        if (type === "groupBy") {
            props.infos = JSON.stringify({
                create_group: true,
            });
        }
        return props;
    }

    getItemLabel(type, item) {
        if (type === "filter") {
            return item.label;
        }
        if (type === "groupBy") {
            let label = item.label || item.name;
            if (this.env.debug) {
                label = `${label} (${item.groupBy})`;
            }
            return label;
        }
        if (type === "field") {
            let label = item.label || this.props.fields[item.name].string;
            if (this.env.debug) {
                label = `${label} (${item.name})`;
            }
            return label;
        }
    }

    onItemClicked(ev, xpath) {
        this.env.config.onNodeClicked(xpath);
    }
}

/** SIDEBAR STUFF */

class SearchComponents extends Component {
    static components = { SidebarDraggableItem };
    static props = {};
    static template = "web_studio.SearchEditor.Sidebar.Components";

    get structures() {
        return {
            filter: {
                name: _t("Filter"),
                class: "o_web_studio_filter",
            },
            separator: {
                name: _t("Separator"),
                class: "o_web_studio_filter_separator",
            },
        };
    }
}

class SimpleElementEditor extends Component {
    static props = { node: { type: Object } };
    static components = { Property, SidebarPropertiesToolbox };
    static template = "web_studio.SearchEditor.SimpleElementEditor";

    setup() {
        this.addDialog = useOwnedDialogs();
    }

    get viewEditorModel() {
        return this.env.viewEditorModel;
    }

    get node() {
        return this.props.node;
    }

    get label() {
        if (this.node.type === "field" && !this.node.label) {
            return this.env.viewEditorModel.fields[this.node.name].string;
        }
        return this.node.label;
    }

    get domain() {
        if (this.node.type === "filter") {
            return this.node.domain;
        }
        return null;
    }

    onChangeDomain(value) {
        const operation = {
            new_attrs: { domain: value },
            type: "attributes",
            position: "attributes",
            target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),
        };
        this.viewEditorModel.doOperation(operation);
    }

    onChangeLabel(value) {
        const operation = {
            new_attrs: { string: value },
            type: "attributes",
            position: "attributes",
            target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),
        };
        this.viewEditorModel.doOperation(operation);
    }

    onPropertyRemoved() {
        const activeNodeXpath = this.viewEditorModel.activeNodeXpath;
        this.viewEditorModel.activeNodeXpath = null;
        const operation = {
            type: "remove",
            target: this.viewEditorModel.getFullTarget(activeNodeXpath),
        };
        this.viewEditorModel.doOperation(operation);
    }
}

class SearchEditorSidebar extends Component {
    static template = "web_studio.ViewEditor.SearchEditorSidebar";
    static props = {
        openViewInForm: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
    };
    static components = {
        InteractiveEditorSidebar,
        ExistingFields,
        SearchComponents,
        Property,
        SidebarViewToolbox,
        SimpleElementEditor,
    };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
        const searchArchParser = new SearchEditorArchParser();
        this._getCurrentNode = memoize(() =>
            searchArchParser.parseNode(this.viewEditorModel.activeNode.arch)
        );
    }

    get currentNode() {
        const { activeNodeXpath, arch } = this.viewEditorModel;
        return this._getCurrentNode(`${activeNodeXpath}_${arch}`);
    }
}

/** SIDEBAR STUFF */
const searchEditor = {
    ArchParser: SearchEditorArchParser,
    Controller: SearchEditorController,
    props(genericProps, editor, config) {
        const archInfo = new editor.ArchParser().parse(genericProps.arch);
        return { ...genericProps, archInfo };
    },
    Sidebar: SearchEditorSidebar,
};

registry.category("studio_editors").add("search", searchEditor);

async function addSearchViewStructure(structure, { droppedData, targetInfo, addDialog }) {
    switch (structure) {
        case "group":
        case "separator": {
            return {
                node: {
                    tag: structure,
                    attrs: {
                        name: randomName(`studio_${structure}`),
                    },
                },
            };
        }

        case "field": {
            if (!["groupBy", "filter"].includes(targetInfo.type)) {
                return;
            } else {
                const fieldName = JSON.parse(droppedData).fieldName;
                const fieldGet = this.env.viewEditorModel.fields[fieldName];
                const willBeGroupBy = targetInfo.type === "groupBy";

                const node = {
                    tag: "filter",
                    attrs: {
                        name: randomName(`studio_${willBeGroupBy ? "group" : "filter"}_by`),
                        string: fieldGet.string,
                    },
                };

                if (willBeGroupBy) {
                    node.attrs.context = `{'group_by': '${fieldName}'}`;
                    if (targetInfo.infos && JSON.parse(targetInfo.infos).create_group) {
                        node.attrs.create_group = true;
                    }
                } else {
                    node.attrs.date = fieldName;
                }
                return {
                    node,
                };
            }
        }
        case "filter": {
            const filterData = await new Promise((resolve) => {
                addDialog(FieldConfigurationDialog, {
                    title: _t("New Filter"),
                    size: "md",
                    confirm: (data) => resolve(data),
                    cancel: () => resolve(false),
                    Component: FilterConfiguration,
                    componentProps: { resModel: this.env.viewEditorModel.resModel },
                });
            });
            if (!filterData) {
                return;
            }
            const node = {
                tag: "filter",
                attrs: {
                    domain: filterData.domain,
                    name: randomName("studio_filter"),
                    string: filterData.filterLabel,
                },
            };
            return {
                node,
            };
        }
    }
}
searchEditor.addViewStructure = addSearchViewStructure;

/** Drag/Drop */

const FILTER_TYPES = ["date", "datetime"];
const GROUPABLE_TYPES = [
    "many2one",
    "many2many",
    "char",
    "boolean",
    "selection",
    "date",
    "datetime",
];

function fieldCanBeFilter(field) {
    return FILTER_TYPES.includes(field.type) && field.store;
}

function fieldCanBeGroupable(field) {
    return GROUPABLE_TYPES.includes(field.type) && field.store;
}

const disabledDropClass = "o-web-studio-search--drop-disable";

searchEditor.isValidHook = function isValidSearchHook({ hook, element, viewEditorModel }) {
    if (hook.closest(`.${disabledDropClass}`)) {
        return false;
    }
    return true;
};

searchEditor.prepareForDrag = function ({ element, viewEditorModel, ref }) {
    const draggingStructure = element.dataset.structure;

    switch (draggingStructure) {
        case "field": {
            const fieldName = JSON.parse(element.dataset.drop).fieldName;
            const field = viewEditorModel.fields[fieldName];
            if (!fieldCanBeFilter(field)) {
                ref.el
                    .querySelector(`.o-web-studio-search--filters`)
                    .classList.add(disabledDropClass);
            }
            if (!fieldCanBeGroupable(field)) {
                ref.el
                    .querySelector(`.o-web-studio-search--groupbys`)
                    .classList.add(disabledDropClass);
            }

            break;
        }
        case "separator":
        case "filter": {
            const els = ref.el.querySelectorAll(
                ".o-web-studio-search--fields,.o-web-studio-search--groupbys"
            );
            els.forEach((el) => el.classList.add("o-web-studio-search--drop-disable"));
            break;
        }
    }

    return () => {
        ref.el
            .querySelectorAll(".o-web-studio-search--drop-disable")
            .forEach((el) => el.classList.remove("o-web-studio-search--drop-disable"));
    };
};

return __exports;
});
;

/**********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/sidebar_safe_fields.js  *
*  Lines: 62                                                                                  *
**********************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/sidebar_safe_fields', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

/**
 * A list of field widget keys of the wowl's field registry (`registry.category("fields")`)
 * that are safe for the user to swith to when editing a field's properties in the view editor's sidebar.
 *
 * Other widgets either don't make sense for that use because they are too specific, or they need
 * specific implementation details provided by some view to be usable.
 */
const SIDEBAR_SAFE_FIELDS = __exports.SIDEBAR_SAFE_FIELDS = [
    "badge",
    "selection_badge",
    "handle",
    "percentpie",
    "radio",
    "selection",
    "image_url",
    "ace",
    "priority",
    "date",
    "datetime",
    "remaining_days",
    "email",
    "phone",
    "url",
    "binary",
    "image",
    "pdf_viewer",
    "boolean",
    "state_selection",
    "boolean_toggle",
    "statusbar",
    "float",
    "float_time",
    "integer",
    "monetary",
    "percentage",
    "progressbar",
    "text",
    "boolean_favorite",
    "boolean_icon",
    "char",
    "statinfo",
    "html",
    "text_emojis",
    "CopyClipboardChar",
    "CopyClipboardURL",
    "char_emojis",
    "many2many_tags",
    "many2one",
    "many2many",
    "one2many",
    "sms_widget",
    "reference",
    "daterange",
];

return __exports;
});
;

/********************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/utils.js  *
*  Lines: 240                                                                   *
********************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/utils', ['@web/core/utils/arrays', '@web/core/registry', '@web_studio/client_action/view_editor/editors/sidebar_safe_fields', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { sortBy } = require("@web/core/utils/arrays");
const { registry } = require("@web/core/registry");
const { SIDEBAR_SAFE_FIELDS } = require("@web_studio/client_action/view_editor/editors/sidebar_safe_fields");
const { useComponent, useEffect, useRef } = require("@odoo/owl");

const hookPositionTolerance = __exports.hookPositionTolerance = 50;

__exports.cleanHooks = cleanHooks; function cleanHooks(el) {
    for (const hookEl of el.querySelectorAll(".o_web_studio_nearest_hook")) {
        hookEl.classList.remove("o_web_studio_nearest_hook");
    }
}

__exports.getActiveHook = getActiveHook; function getActiveHook(el) {
    return el.querySelector(".o_web_studio_nearest_hook");
}

// A naive function that determines if the toXpath on which we dropped
// our object is actually the same as the fromXpath of the element we dropped.
// Naive because it won't evaluate xpath, just guess whether they are equivalent
// under precise conditions.
__exports.isToXpathEquivalentFromXpath = isToXpathEquivalentFromXpath; function isToXpathEquivalentFromXpath(position, toXpath, fromXpath) {
    if (toXpath === fromXpath) {
        return true;
    }
    const toParts = toXpath.split("/");
    const fromParts = fromXpath.split("/");

    // Are the paths at least in the same parent node ?
    if (toParts.slice(0, -1).join("/") !== fromParts.slice(0, -1).join("/")) {
        return false;
    }

    const nodeIdxRegExp = /(\w+)(\[(\d+)\])?/;
    const toMatch = toParts[toParts.length - 1].match(nodeIdxRegExp);
    const fromMatch = fromParts[fromParts.length - 1].match(nodeIdxRegExp);

    // Are the paths comparable in terms of their node tag ?
    if (fromMatch[1] !== toMatch[1]) {
        return false;
    }

    // Is the position actually referring to the same place ?
    if (position === "after" && parseInt(toMatch[3] || 1) + 1 === parseInt(fromMatch[3] || 1)) {
        return true;
    }
    return false;
}

__exports.getHooks = getHooks; function getHooks(el) {
    return [...el.querySelectorAll(".o_web_studio_hook")];
}

__exports.randomName = randomName; function randomName(baseName) {
    const random =
        Math.floor(Math.random() * 10000).toString(32) + "_" + Number(new Date()).toString(32);
    return `${baseName}_${random}`;
}

// A standardized method to determine if a component is visible
__exports.studioIsVisible = studioIsVisible; function studioIsVisible(props) {
    return props.studioIsVisible !== undefined ? props.studioIsVisible : true;
}

__exports.cleanClickedElements = cleanClickedElements; function cleanClickedElements(mainEl) {
    for (const el of mainEl.querySelectorAll(".o-web-studio-editor--element-clicked")) {
        el.classList.remove("o-web-studio-editor--element-clicked");
    }
}

__exports.useStudioRef = useStudioRef; function useStudioRef(refName = "studioRef", onClick) {
    // create two hooks and call them here?
    const comp = useComponent();
    const ref = useRef(refName);
    useEffect(
        (el) => {
            if (el) {
                el.setAttribute("data-studio-xpath", comp.props.studioXpath);
            }
        },
        () => [ref.el]
    );

    if (onClick) {
        const handler = onClick.bind(comp);
        useEffect(
            (el) => {
                if (el) {
                    el.addEventListener("click", handler, { capture: true });
                    return () => {
                        el.removeEventListener("click", handler);
                    };
                }
            },
            () => [ref.el]
        );
    }
}

__exports.makeModelErrorResilient = makeModelErrorResilient; function makeModelErrorResilient(ModelClass) {
    function logError(debug) {
        if (!debug) {
            return;
        }
        console.warn(
            "The onchange triggered an error. It may indicate either a faulty call to onchange, or a faulty model python side"
        );
    }
    return class ResilientModel extends ModelClass {
        setup() {
            super.setup(...arguments);
            const orm = this.orm;
            const debug = this.env.debug;
            this.orm = Object.assign(Object.create(orm), {
                async call(model, method) {
                    if (method === "onchange") {
                        try {
                            return await orm.call.call(orm, ...arguments);
                        } catch {
                            logError(debug);
                        }
                        return { value: {} };
                    }
                    return orm.call.call(orm, ...arguments);
                },
            });
        }
    };
}

__exports.getWowlFieldWidgets = getWowlFieldWidgets; function getWowlFieldWidgets(
    fieldType,
    currentKey = "",
    blacklistedKeys = [],
    debug = false
) {
    const wowlFieldRegistry = registry.category("fields");
    const widgets = [];
    for (const [widgetKey, Component] of wowlFieldRegistry.getEntries()) {
        if (widgetKey !== currentKey) {
            // always show the current widget
            // Widget dosn't explicitly supports the field's type
            if (!Component.supportedTypes || !Component.supportedTypes.includes(fieldType)) {
                continue;
            }
            // Widget is view-specific or is blacklisted
            if (widgetKey.includes(".") || blacklistedKeys.includes(widgetKey)) {
                continue;
            }
            // Widget is not whitelisted
            if (!debug && !SIDEBAR_SAFE_FIELDS.includes(widgetKey)) {
                continue;
            }
        }
        widgets.push([widgetKey, Component.displayName]);
    }
    return sortBy(widgets, (el) => el[1] || el[0]);
}

__exports.xpathToLegacyXpathInfo = xpathToLegacyXpathInfo; function xpathToLegacyXpathInfo(xpath) {
    // eg: /form[1]/field[3]
    // RegExp notice: group 1 : form ; group 2: [1], group 3: 1
    const xpathInfo = [];
    const matches = xpath.matchAll(/\/?(\w+|\*)(\[(\d+)\])?/g);
    for (const m of matches) {
        const info = {
            tag: m[1],
            indice: parseInt(m[3] || 1),
        };
        xpathInfo.push(info);
    }
    return xpathInfo;
}

__exports.fieldsToChoices = fieldsToChoices; function fieldsToChoices(fields, availableTypes, filterCallback) {
    let values = Object.values(fields);
    if (filterCallback) {
        values = values.filter(filterCallback);
    }
    if (availableTypes) {
        values = values.filter((f) => availableTypes.includes(f.type));
    }
    return values.map((field) => ({
        label: odoo.debug ? `${field.string} (${field.name})` : field.string || field.name,
        value: field.name,
    }));
}

__exports.getStudioNoFetchFields = getStudioNoFetchFields; function getStudioNoFetchFields(_fieldNodes) {
    const fieldNames = [];
    const fieldNodes = [];
    Object.entries(_fieldNodes)
        .filter(([fNode, field]) => field.attrs && field.attrs.studio_no_fetch)
        .forEach(([fNode, field]) => {
            fieldNames.push(field.name);
            fieldNodes.push(fNode);
        });
    return {
        fieldNames,
        fieldNodes,
    };
}

__exports.useModelConfigFetchInvisible = useModelConfigFetchInvisible; function useModelConfigFetchInvisible(model) {
    function fixActiveFields(activeFields) {
        const stack = [activeFields];
        while (stack.length) {
            const activeFields = stack.pop();
            for (const activeField of Object.values(activeFields)) {
                if ("related" in activeField) {
                    stack.push(activeField.related.activeFields);
                }
                delete activeField.invisible;
            }
        }
        return activeFields;
    }

    const load = model.load;
    model.load = (...args) => {
        fixActiveFields(model.config.activeFields);
        return load.call(model, ...args);
    };
}

__exports.getCurrencyField = getCurrencyField; function getCurrencyField(fieldsGet) {
    const field = Object.entries(fieldsGet).find(([fName, fInfo]) => {
        return fInfo.type === "many2one" && fInfo.relation === "res.currency";
    });
    if (field) {
        return field[0];
    }
}

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/editors/xml_utils.js  *
*  Lines: 111                                                                       *
************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/editors/xml_utils', ['@web/core/py_js/py', '@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { evaluateExpr } = require("@web/core/py_js/py");
const { isComponentNode, appendAttr } = require("@web/views/view_compiler");

const nodeWeak = new WeakMap();

__exports.countPreviousSiblings = countPreviousSiblings; function countPreviousSiblings(node) {
    const countXpath = `count(preceding-sibling::${node.tagName})`;
    return node.ownerDocument.evaluate(countXpath, node, null, XPathResult.NUMBER_TYPE).numberValue;
}

__exports.computeXpath = computeXpath; function computeXpath(node, upperBoundSelector = "form") {
    if (nodeWeak.has(node)) {
        return nodeWeak.get(node);
    }
    const tagName = node.tagName;
    const count = countPreviousSiblings(node) + 1;

    let xpath = `${tagName}[${count}]`;
    const parent = node.parentElement;
    if (!node.matches(upperBoundSelector)) {
        const parentXpath = computeXpath(parent, upperBoundSelector);
        xpath = `${parentXpath}/${xpath}`;
    } else {
        xpath = `/${xpath}`;
    }
    nodeWeak.set(node, xpath);
    return xpath;
}

__exports.getNodeAttributes = getNodeAttributes; function getNodeAttributes(node) {
    const attrs = {};
    for (const att of node.getAttributeNames()) {
        if (att === "options") {
            attrs[att] = evaluateExpr(node.getAttribute(att));
            continue;
        }
        attrs[att] = node.getAttribute(att);
    }
    return attrs;
}

function getXpathNodes(xpathResult) {
    const nodes = [];
    let res;
    while ((res = xpathResult.iterateNext())) {
        nodes.push(res);
    }
    return nodes;
}

__exports.getNodesFromXpath = getNodesFromXpath; function getNodesFromXpath(xpath, xml) {
    const owner = "evaluate" in xml ? xml : xml.ownerDocument;
    const xpathResult = owner.evaluate(xpath, xml, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
    return getXpathNodes(xpathResult);
}

const parser = new DOMParser();
const parseStringToXml = __exports.parseStringToXml = (str) => {
    return parser.parseFromString(str, "text/xml");
};

const serializer = new XMLSerializer();
const serializeXmlToString = __exports.serializeXmlToString = (xml) => {
    return serializer.serializeToString(xml);
};

// This function should be used in Compilers to apply the "invisible" modifiers on
// the compiled templates's nodes
__exports.applyInvisible = applyInvisible; function applyInvisible(invisible, compiled, params) {
    // Just return the node if it is always Visible
    if (!invisible || invisible === "False" || invisible === "0") {
        return compiled;
    }

    let isVisileExpr;
    // If invisible is dynamic, pass a props or apply the studio class.
    if (invisible !== "True" && invisible !== "1") {
        const recordExpr = params.recordExpr || "__comp__.props.record";
        isVisileExpr = `!__comp__.evaluateBooleanExpr(${JSON.stringify(
            invisible
        )},${recordExpr}.evalContextWithVirtualIds)`;
        if (isComponentNode(compiled)) {
            compiled.setAttribute("studioIsVisible", isVisileExpr);
        } else {
            appendAttr(compiled, "class", `o_web_studio_show_invisible:!${isVisileExpr}`);
        }
    } else {
        if (isComponentNode(compiled)) {
            compiled.setAttribute("studioIsVisible", "false");
        } else {
            appendAttr(compiled, "class", `o_web_studio_show_invisible:true`);
        }
    }

    // Finally, put a t-if on the node that accounts for the parameter in the config.
    const studioShowExpr = `__comp__.viewEditorModel.showInvisible`;
    isVisileExpr = isVisileExpr ? `(${isVisileExpr} or ${studioShowExpr})` : studioShowExpr;
    if (compiled.hasAttribute("t-if")) {
        const formerTif = compiled.getAttribute("t-if");
        isVisileExpr = `( ${formerTif} ) and ${isVisileExpr}`;
    }
    compiled.setAttribute("t-if", isVisileExpr);
    return compiled;
}

return __exports;
});
;

/*****************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/action_button/action_button.js  *
*  Lines: 135                                                                                                    *
*****************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/action_button/action_button', ['@web/core/dialog/dialog', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/autocomplete/autocomplete', '@odoo/owl', '@web/core/network/rpc', '@web/core/utils/hooks', '@web/core/l10n/translation', '@web/core/record_selectors/record_selector'], function (require) {
'use strict';
let __exports = {};
const { Dialog } = require("@web/core/dialog/dialog");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { AutoComplete } = require("@web/core/autocomplete/autocomplete");
const { Component, useState } = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { useOwnedDialogs } = require("@web/core/utils/hooks");
const { _t } = require("@web/core/l10n/translation");
const { RecordSelector } = require("@web/core/record_selectors/record_selector");

const DialogAddNewButton = __exports.DialogAddNewButton = class DialogAddNewButton extends Component {
    static template = `web_studio.DialogNewButtonStatusBar`;
    static components = {
        AutoComplete,
        Dialog,
        Dropdown,
        DropdownItem,
        RecordSelector,
    };
    static props = {
        model: { type: String },
        onConfirm: { type: Function },
        close: { type: Function },
    };
    setup() {
        this.state = useState({
            action: "",
            button_type: "",
            actionId: false,
            methodId: "",
            methodList: [],
            error: "",
            methodChecked: false,
        });
    }

    get multiRecordSelectorProps() {
        return {
            resModel: "ir.actions.actions",
            update: (resId) => {
                this.state.actionId = resId;
            },
            resId: this.state.actionId,
            domain: [["binding_model_id", "=", this.props.model]],
        };
    }

    get checkValidity() {
        if (this.state.label?.length > 0) {
            if (this.state.button_type === "action" && this.state.actionId) {
                return false;
            } else if (
                this.state.methodChecked &&
                this.state.button_type === "object" &&
                this.state.methodId?.length > 0 &&
                this.state.error?.length === 0
            ) {
                return false;
            } else {
                return true;
            }
        } else {
            return true;
        }
    }
    onChange() {
        this.state.actionId = false;
        this.state.methodId = null;
    }
    onConfirm() {
        this.props.onConfirm(this.state);
        this.props.close();
    }
    onCancel() {
        this.props.close();
    }
    async checkMethod() {
        this.state.error = "";
        this.state.methodChecked = false;
        if (this.state.methodId?.length > 0) {
            if (this.state.methodId.startsWith("_")) {
                this.state.error = _t("The method %s is private.", this.state.methodId);
            } else {
                try {
                    await rpc("/web_studio/check_method", {
                        model_name: this.props.model,
                        method_name: this.state.methodId,
                    });
                } catch (error) {
                    if (error?.data?.message?.length > 0) {
                        this.state.error = error.data.message;
                    }
                }
                this.state.methodChecked = true;
            }
        }
    }
}

const AddButtonAction = __exports.AddButtonAction = class AddButtonAction extends Component {
    static props = {};
    static template = `web_studio.AddButtonAction`;
    setup() {
        this.addDialog = useOwnedDialogs();
    }
    onClick() {
        this.addDialog(DialogAddNewButton, {
            model: this.env.viewEditorModel.resModel,
            onConfirm: (state) => {
                const viewEditorModel = this.env.viewEditorModel;
                const arch = viewEditorModel.xmlDoc;
                const findHeader = arch.firstChild.querySelector(":scope > header");
                if (!findHeader) {
                    viewEditorModel.pushOperation({
                        type: "statusbar",
                        view_id: this.env.viewEditorModel.view.id,
                    });
                }
                viewEditorModel.doOperation({
                    type: "add_button_action",
                    button_type: state.button_type,
                    actionId: state.actionId,
                    methodId: state.methodId,
                    label: state.label,
                });
            },
        });
    }
}

return __exports;
});
;

/*****************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/field_configuration/field_configuration.js  *
*  Lines: 286                                                                                                                *
*****************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration', ['@odoo/owl', '@web/core/dialog/dialog', '@web/core/model_field_selector/model_field_selector', '@web_studio/client_action/utils', '@web/core/utils/hooks', '@web/core/l10n/translation', '@web/core/domain_selector/domain_selector', '@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog', '@web/core/record_selectors/record_selector'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, useState, xml } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");
const { ModelFieldSelector } = require("@web/core/model_field_selector/model_field_selector");
const { useDialogConfirmation } = require("@web_studio/client_action/utils");
const { useOwnedDialogs, useService } = require("@web/core/utils/hooks");
const { _t } = require("@web/core/l10n/translation");
const { DomainSelector } = require("@web/core/domain_selector/domain_selector");
const { SelectionContentDialog } = require("@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog");
const { RecordSelector } = require("@web/core/record_selectors/record_selector");

const SelectionValuesEditor = __exports.SelectionValuesEditor = class SelectionValuesEditor extends Component {
    static components = {
        SelectionContentDialog,
    };
    static props = {
        configurationModel: { type: Object },
        confirm: { type: Function },
        cancel: { type: Function },
    };
    static template = "web_studio.SelectionValuesEditor";
    static Model = class SelectionValuesModel {
        constructor() {
            this.selection = "[]";
        }
        get isValid() {
            return true;
        }
    };
    get selection() {
        return JSON.parse(this.props.configurationModel.selection);
    }
    onConfirm(choices) {
        this.props.configurationModel.selection = JSON.stringify(choices);
        this.props.confirm();
    }
}

const RelationalFieldConfigurator = __exports.RelationalFieldConfigurator = class RelationalFieldConfigurator extends Component {
    static template = "web_studio.RelationalFieldConfigurator";
    static components = { RecordSelector };
    static props = {
        configurationModel: { type: Object },
        resModel: { type: String },
        fieldType: { type: String },
    };
    static Model = class RelationalFieldModel {
        constructor() {
            this.relationId = false;
        }
        get isValid() {
            return !!this.relationId;
        }
    };

    setup() {
        this.state = useState(this.props.configurationModel);
    }

    get valueSelectorProps() {
        if (this.props.fieldType === "one2many") {
            return {
                resModel: "ir.model.fields",
                domain: [
                    ["relation", "=", this.props.resModel],
                    ["ttype", "=", "many2one"],
                    ["model_id.abstract", "=", false],
                    ["store", "=", true],
                ],
                resId: this.state.relationId,
                update: (resId) => {
                    this.state.relationId = resId;
                },
            };
        }
        return {
            resModel: "ir.model",
            domain: [
                ["transient", "=", false],
                ["abstract", "=", false],
                ["model", "not in", ["knowledge.article"]],
            ],
            resId: this.state.relationId,
            update: (resId) => {
                this.state.relationId = resId;
            },
        };
    }
}

class RelatedChainBuilderModel {
    static services = ["field", "dialog"];

    constructor({ services, props }) {
        this.services = services;
        this.relatedParams = {};
        this.fieldInfo = { resModel: props.resModel, fieldDef: null };
        this.resModel = props.resModel;
    }

    get isValid() {
        return !!this.relatedParams.related;
    }

    getRelatedFieldDescription(resModel, lastField) {
        const fieldType = lastField.type;
        const relatedDescription = {
            readonly: true,
            copy: false,
            string: lastField.string,
            type: fieldType,
            store: false,
        };

        if (["many2one", "many2many", "one2many"].includes(fieldType)) {
            relatedDescription.relation = lastField.relation;
        }
        if (["one2many", "many2many"].includes(fieldType)) {
            relatedDescription.relational_model = resModel;
        }
        if (fieldType === "selection") {
            relatedDescription.selection = lastField.selection;
        }
        return relatedDescription;
    }

    async confirm() {
        const relatedDescription = this.getRelatedFieldDescription(
            this.fieldInfo.resModel,
            this.fieldInfo.fieldDef
        );
        Object.assign(this.relatedParams, relatedDescription);
        return true;
    }
}

const RelatedChainBuilder = __exports.RelatedChainBuilder = class RelatedChainBuilder extends Component {
    static template = xml`<ModelFieldSelector resModel="props.resModel" path="fieldChain" readonly="false" filter.bind="filter" update.bind="updateChain" />`;
    static components = { ModelFieldSelector };
    static props = {
        resModel: { type: String },
        configurationModel: { type: Object },
    };
    static Model = RelatedChainBuilderModel;

    setup() {
        this.state = useState(this.props.configurationModel);
        this.relatedParams.related = "";
    }

    get relatedParams() {
        return this.state.relatedParams;
    }

    get fieldChain() {
        return this.relatedParams.related;
    }

    filter(fieldDef, path) {
        return fieldDef.type !== "properties";
    }

    async updateChain(path, fieldInfo) {
        this.relatedParams.related = path;
        this.state.fieldInfo = fieldInfo;
    }
}

function useConfiguratorModel(Model, props) {
    const services = Object.fromEntries(
        (Model.services || []).map((servName) => {
            let serv;
            if (servName === "dialog") {
                serv = { add: useOwnedDialogs() };
            } else {
                serv = useService(servName);
            }
            return [servName, serv];
        })
    );

    const model = new Model({ services, props });
    return useState(model);
}

const FieldConfigurationDialog = __exports.FieldConfigurationDialog = class FieldConfigurationDialog extends Component {
    static props = {
        confirm: { type: Function },
        cancel: { type: Function },
        close: { type: Function },
        Component: { type: Function },
        componentProps: { type: Object, optional: true },
        fieldType: { type: String, optional: true },
        isDialog: { type: Boolean, optional: true },
        title: { type: String, optional: true },
        size: { type: String, optional: true },
    };
    static template = "web_studio.FieldConfigurationDialog";
    static components = { Dialog };

    setup() {
        const { confirm, cancel } = useDialogConfirmation({
            confirm: async () => {
                let confirmValues = false;
                if (!this.configurationModel.isValid) {
                    return false;
                }
                if (this.configurationModel.confirm) {
                    const res = await this.configurationModel.confirm();
                    if (res || res === undefined) {
                        confirmValues = this.configurationModel;
                    }
                } else {
                    confirmValues = this.configurationModel;
                }
                return this.props.confirm(confirmValues);
            },
            cancel: () => this.props.cancel(),
        });
        this.confirm = confirm;
        this.cancel = cancel;
        this.configurationModel = useConfiguratorModel(
            this.Component.Model,
            this.props.componentProps
        );
    }

    get title() {
        if (this.props.title) {
            return this.props.title;
        }
        if (this.props.fieldType) {
            return _t("Field properties: %s", this.props.fieldType);
        }
        return "";
    }

    get Component() {
        return this.props.Component;
    }

    get canConfirm() {
        return this.configurationModel.isValid;
    }
}

const FilterConfiguration = __exports.FilterConfiguration = class FilterConfiguration extends Component {
    static components = { DomainSelector };
    static template = "web_studio.FilterConfiguration";
    static props = {
        resModel: { type: String },
        configurationModel: { type: Object },
    };
    static Model = class FilterConfigurationModel {
        constructor() {
            this.filterLabel = "";
            this.domain = "[]";
        }

        get isValid() {
            return !!this.filterLabel;
        }
    };

    setup() {
        this.state = useState(this.props.configurationModel);
    }

    get domainSelectorProps() {
        return {
            resModel: this.props.resModel,
            readonly: false,
            domain: this.state.domain,
            update: (domainStr) => {
                this.state.domain = domainStr;
            },
            isDebugMode: !!this.env.debug,
        };
    }
}

return __exports;
});
;

/**********************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog.js  *
*  Lines: 198                                                                                                                     *
**********************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog', ['@web/core/dialog/dialog', '@web/core/utils/sortable_owl', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Dialog } = require("@web/core/dialog/dialog");
const { useSortable } = require("@web/core/utils/sortable_owl");

const { Component, useRef, useState } = require("@odoo/owl");

const SelectionContentDialog = __exports.SelectionContentDialog = class SelectionContentDialog extends Component {
    static components = {
        Dialog,
    };
    static defaultProps = {
        defaultChoices: [],
    };
    static props = {
        defaultChoices: { type: Array, optional: true },
        onConfirm: { type: Function },
        close: { type: Function },
    };
    static template = "web_studio.SelectionContentDialog";

    setup() {
        this.state = useState({
            choices: this.props.defaultChoices,
        });
        this.localState = useState({
            _newItem: [],
            editedItem: null,
        });

        const itemsList = useRef("itemsList");
        useSortable({
            enable: () => !this.editedItem,
            handle: ".o-draggable-handle",
            ref: itemsList,
            elements: ".o-draggable",
            cursor: "move",
            onDrop: (params) => this.resequenceItems(params),
        });

        this.oldValue = new WeakMap();
    }

    getSelectionFromItem(item) {
        if (item.id === "new") {
            return this.localState._newItem;
        }
        return this.selection[item.id];
    }

    get selection() {
        return this.state.choices;
    }

    set selection(items) {
        this.state.choices = items;
    }

    selectionToItem(selection, params = {}) {
        return Object.assign(
            {
                id: "new",
                key: selection[0],
                name: selection[0],
                label: selection[1],
                isDraggable: false,
                isRemovable: false,
                isInEdition: false,
            },
            params
        );
    }

    get selectionToItems() {
        const inEdition = !!this.editedItem;
        return this.selection.map((sel, index) => {
            return this.selectionToItem(sel, {
                id: index,
                key: inEdition ? index : sel[0],
                isInEdition:
                    this.editedItem?.id === this.selection.indexOf(sel) && !this.shouldFullEdit,
                isDraggable: !inEdition,
                isRemovable: !inEdition,
            });
        });
    }

    get newItem() {
        return this.selectionToItem(this.localState._newItem, { isInEdition: true, id: "new" });
    }

    get editedItem() {
        return this.localState.editedItem;
    }

    get shouldFullEdit() {
        return Boolean(this.env.debug);
    }

    ensureUnique(item) {
        const value = item[0];
        if (!value) {
            return false;
        }

        const otherElements = this.selection.filter((i) => i !== item);
        if (otherElements.some((i) => i[0] === value)) {
            return false;
        }
        return true;
    }

    setItemValue(item, value) {
        if (item.id !== "new" && item.id !== this.editedItem.id) {
            return;
        }
        const isEditingLabel = item.id !== "new";
        item = this.getSelectionFromItem(item);
        item[0] = isEditingLabel ? this.editedItem.name : value;
        item[1] = value;
    }

    addItem(item) {
        if (!this.ensureUnique(item)) {
            return;
        }
        this.selection.push(item);
        this.localState._newItem = [];
    }

    removeItem(item) {
        this.selection = this.selection.filter((i) => i[0] !== item.name);
    }

    editItem(item) {
        const selItem = this.getSelectionFromItem(item);
        if (item.id === "new") {
            return this.addItem(selItem);
        }
        if (this.editedItem?.id === item.id) {
            if (!this.ensureUnique(selItem)) {
                return;
            }
            this.localState.editedItem = null;
            this.oldValue.delete(selItem);
            return;
        }
        this.oldValue.set(selItem, [...selItem]);
        this.localState.editedItem = item;
    }

    discardItemChanges(item) {
        if (item.id === "new") {
            return this.setItemValue(item, "");
        }
        const selItem = this.getSelectionFromItem(item);
        const oldValue = this.oldValue.get(selItem);
        selItem[0] = oldValue[0];
        selItem[1] = oldValue[1];
        this.localState.editedItem = null;
    }

    resequenceItems(params) {
        const { previous, next, element } = params;
        const itemId = parseInt(element.dataset.itemId);

        let items = this.selection;
        const item = items[itemId];
        items = items.filter((i) => i !== item);

        let toIndex;
        if (previous) {
            toIndex = parseInt(previous.dataset.itemId) + 1;
        } else if (next) {
            toIndex = parseInt(next.dataset.itemId);
        }
        items.splice(toIndex, 0, item);
        this.selection = items;
    }

    async onConfirm() {
        if (this.newItem.name?.length) {
            this.editItem(this.newItem);
        }
        await this.props.onConfirm(this.selection);
        this.props.close();
    }

    onKeyPressed(item, key) {
        if (key === "Enter") {
            this.editItem(item);
        }
    }
}

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/interactive_editor.js  *
*  Lines: 527                                                                                           *
********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/interactive_editor', ['@odoo/owl', '@web/core/utils/ui', '@web/core/utils/draggable', '@web/core/utils/hooks', '@web/core/l10n/translation', '@web_studio/client_action/view_editor/editors/utils', '@web/core/confirmation_dialog/confirmation_dialog', '@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration', '@web_studio/client_action/view_editor/editors/xml_utils', '@web_studio/client_action/view_editor/default_view_sidebar/default_view_sidebar'], function (require) {
'use strict';
let __exports = {};
const { Component, toRaw } = require("@odoo/owl");

const { closest, touching } = require("@web/core/utils/ui");
const { useDraggable } = require("@web/core/utils/draggable");
const { useOwnedDialogs, useService } = require("@web/core/utils/hooks");
const { _t } = require("@web/core/l10n/translation");
const {
    isToXpathEquivalentFromXpath,
    cleanHooks,
    getActiveHook,
    getCurrencyField,
    getHooks,
    hookPositionTolerance,
    randomName,
} = require("@web_studio/client_action/view_editor/editors/utils");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const {
    FieldConfigurationDialog,
    SelectionValuesEditor,
    RelationalFieldConfigurator,
    RelatedChainBuilder,
} = require("@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration");
const {
    getNodesFromXpath,
    countPreviousSiblings,
} = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { DefaultViewSidebar } = require("@web_studio/client_action/view_editor/default_view_sidebar/default_view_sidebar");

const NO_M2O_AVAILABLE = _t(`
    There are no many2one fields related to the current model.
    To create a one2many field on the current model, you must first create its many2one counterpart on the model you want to relate to.
`);

function copyElementOnDrag() {
    let element;
    let copy;

    function clone(_element) {
        element = _element;
        copy = element.cloneNode(true);
    }

    function insert() {
        if (element) {
            element.insertAdjacentElement("beforebegin", copy);
        }
    }

    function clean() {
        if (copy) {
            copy.remove();
        }
        copy = null;
        element = null;
    }

    return { clone, insert, clean };
}

const InteractiveEditor = __exports.InteractiveEditor = class InteractiveEditor extends Component {
    static template = "web_studio.InteractiveEditor";
    static components = {};
    static props = {
        editor: true,
        slots: { type: Object },
        editorContainerRef: { type: Object },
        rendererRef: { type: Object },
    };

    setup() {
        this.defaultSidebar = DefaultViewSidebar;

        this.action = useService("action");
        this.orm = useService("orm");
        this.addDialog = useOwnedDialogs();
        this.notification = useService("notification");
        /* DagDrop: from sidebar to View, and within the view */
        const getNearestHook = this.getNearestHook.bind(this);
        // Those are fine because editor defines the t-key
        const prepareForDrag = this.props.editor.prepareForDrag;
        const isValidHook = this.props.editor.isValidHook || (() => true);
        this.addViewStructure = this.props.editor.addViewStructure;
        const styleNearestHook =
            this.props.editor.styleNearestHook ||
            ((ref, hook) => {
                hook.classList.add("o_web_studio_nearest_hook");
            });

        function removeBootStrapClasses(element) {
            const bootstrapClasses = Array.from(element.classList).filter(
                (c) => c.startsWith("position-") || c.startsWith("w-") || c.startsWith("h-")
            );
            if (!bootstrapClasses.length) {
                return () => {};
            }
            element.classList.remove(...bootstrapClasses);
            return () => {
                element.classList.add(...bootstrapClasses);
            };
        }

        let cleanUps;
        const copyOnDrag = copyElementOnDrag();
        useDraggable({
            ref: this.props.editorContainerRef,
            elements: ".o-draggable",
            onWillStartDrag: ({ element }) => {
                cleanUps = [];
                if (element.closest(".o_web_studio_component")) {
                    copyOnDrag.clone(element);
                }
            },
            onDragStart: ({ element }) => {
                cleanUps.push(removeBootStrapClasses(element));
                copyOnDrag.insert();
                if (prepareForDrag) {
                    cleanUps.push(
                        prepareForDrag({
                            element,
                            viewEditorModel: this.viewEditorModel,
                            ref: this.props.editorContainerRef,
                        })
                    );
                }
            },
            onDrag: ({ x, y, element }) => {
                cleanHooks(this.viewRef.el);
                element.classList.remove("o-draggable--drop-ready");
                const hook = getNearestHook(element, { x, y });
                if (!hook) {
                    return;
                }
                if (!isValidHook({ hook, element, viewEditorModel: this.viewEditorModel })) {
                    return;
                }
                styleNearestHook(this.props.rendererRef, hook);
                element.classList.add("o-draggable--drop-ready");
            },
            onDrop: ({ element }) => {
                const targetHook = getActiveHook(this.viewRef.el);
                if (!targetHook) {
                    return;
                }
                const { xpath, position, type, infos } = targetHook.dataset;
                const droppedData = element.dataset;

                const isNew = element.classList.contains("o_web_studio_component");
                const structure = isNew ? droppedData.structure : "field"; // only fields can be moved

                if (isNew) {
                    this.addStructure(structure, droppedData.drop, {
                        xpath,
                        position,
                        type,
                        infos,
                    });
                } else {
                    this.moveStructure(structure, droppedData, { xpath, position });
                }
            },
            onDragEnd: ({ element }) => {
                cleanHooks(this.viewRef.el);
                if (cleanUps) {
                    cleanUps.forEach((c) => c());
                    cleanUps = null;
                }
                copyOnDrag.clean();
            },
        });

        this.applyAutoClick = () => {
            if (!this.autoClick) {
                return;
            }

            const { targetInfo, tag, attrs } = this.autoClick;

            // First step: locate node in new arch
            let xpathToClick = targetInfo.xpath;
            if (tag) {
                // We are trying to select a new node of which targetInfo could be its parent
                if (targetInfo.position !== "inside") {
                    xpathToClick = xpathToClick.split("/").slice(0, -1).join("/");
                }

                const attrForXpath = Object.entries(attrs)
                    .filter(([, value]) => !!value)
                    .map(([attName, value]) => {
                        return `@${attName}='${value}'`;
                    })
                    .join(" and ");
                const nodeXpath = `${tag}[${attrForXpath}]`;
                const fullXpath = `${xpathToClick}/${nodeXpath}`;

                const nodes = getNodesFromXpath(fullXpath, toRaw(this.viewEditorModel).xmlDoc);
                this.autoClick = null; // Early reset of that variable
                if (nodes.length !== 1) {
                    return;
                }
                const atPosition = countPreviousSiblings(nodes[0]) + 1;
                xpathToClick = `${xpathToClick}/${tag}[${atPosition}]`;
            }

            // Second step: locate corresponding dom element
            const domEl = this.props.rendererRef.el.querySelector(
                `[data-studio-xpath='${xpathToClick}'], [studioxpath='${xpathToClick}']`
            );
            if (domEl) {
                domEl.click();
            }
        };
    }

    get viewEditorModel() {
        return this.env.viewEditorModel;
    }

    get viewRef() {
        return this.viewEditorModel.viewRef;
    }

    getNearestHook(draggedEl, { x, y }) {
        const viewRefEl = this.viewRef.el;
        cleanHooks(viewRefEl);

        const mouseToleranceRect = {
            x: x - hookPositionTolerance,
            y: y - hookPositionTolerance,
            width: hookPositionTolerance * 2,
            height: hookPositionTolerance * 2,
        };

        const touchingEls = touching(getHooks(viewRefEl), mouseToleranceRect);
        const closestHookEl = closest(touchingEls, { x, y });

        return closestHookEl;
    }

    openViewInForm() {
        return this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "ir.ui.view",
                res_id: this.env.viewEditorModel.mainView.id,
                views: [[false, "form"]],
                target: "current",
            },
            { clearBreadcrumbs: true }
        );
    }

    openDefaultValues() {
        const resModel = this.env.viewEditorModel.resModel;
        this.action.doAction(
            {
                name: _t("Default Values"),
                type: "ir.actions.act_window",
                res_model: "ir.default",
                target: "current",
                views: [
                    [false, "list"],
                    [false, "form"],
                ],
                domain: [["field_id.model", "=", resModel]],
            },
            { clearBreadcrumbs: true }
        );
    }

    setAutoClick(targetInfo, nodeDescr) {
        if (!targetInfo) {
            this.autoClick = null;
            return;
        }
        if (targetInfo && !nodeDescr) {
            this.autoClick = {
                targetInfo,
            };
            return;
        }
        let nameAttr = nodeDescr.attrs?.name;
        if (nodeDescr.tag === "field" && !nameAttr) {
            nameAttr = nodeDescr.field_description.name;
        } else if (!nameAttr) {
            this.autoClick = {
                targetInfo,
            };
            return;
        }

        this.autoClick = {
            targetInfo,
            tag: nodeDescr.tag,
            attrs: { name: nameAttr },
        };
    }

    async addField(droppedData) {
        const data = JSON.parse(droppedData);
        const isExistingField = "fieldName" in data;

        let newNode;
        if (!isExistingField) {
            newNode = await this.getNewFieldNode(data);
        } else {
            newNode = {
                tag: "field",
                attrs: { name: data.fieldName },
            };

            const field = this.viewEditorModel.fields[data.fieldName];
            if (field.type === "monetary") {
                this.setCurrencyInfos(newNode.attrs);
            }
        }
        if (!newNode) {
            return;
        }
        if (!isExistingField) {
            this.viewEditorModel.setRenameableField(newNode.field_description?.name, true);
        }

        if (this.viewEditorModel.viewType === "kanban") {
            newNode.attrs.display = "full";
        }

        if (this.viewEditorModel.viewType === "list") {
            newNode.attrs.optional = "show";
        }

        return {
            node: newNode,
        };
    }

    async addStructure(structure, droppedData, targetInfo) {
        let _operation;
        if (this.addViewStructure) {
            _operation = await this.addViewStructure(structure, {
                droppedData,
                targetInfo,
                addDialog: this.addDialog.bind(this),
            });
        }
        if (!_operation && structure === "field") {
            _operation = await this.addField(droppedData);
        }
        if (!_operation) {
            return;
        }
        const operation = {
            target:
                _operation?.target ||
                (targetInfo.xpath
                    ? this.viewEditorModel.getFullTarget(targetInfo.xpath)
                    : undefined),
            position: targetInfo.position,
            type: "add",
            ..._operation,
        };
        this.setAutoClick(targetInfo, operation.node);
        return this.viewEditorModel.doOperation(operation);
    }

    async getNewFieldNode(data) {
        const string = _t("New %s", data.string);

        const newNode = {
            field_description: {
                field_description: string,
                name: randomName(`x_studio_${data.fieldType}_field`),
                type: data.fieldType,
                model_name: this.viewEditorModel.resModel,
                special: data.special,
            },
            tag: "field",
            attrs: { widget: data.widget },
        };

        if (data.special === "lines") {
            return newNode;
        }

        const fieldType = data.fieldType;
        if (fieldType === "selection" && data.widget === "priority") {
            // should not be translated at the creation
            newNode.field_description.selection = [
                ["0", "Normal"],
                ["1", "Low"],
                ["2", "High"],
                ["3", "Very High"],
            ];
            return newNode;
        }

        if (["selection", "one2many", "many2one", "many2many", "related"].includes(fieldType)) {
            if (fieldType === "one2many") {
                const count = await this.orm.searchCount("ir.model.fields", [
                    ["relation", "=", this.viewEditorModel.resModel],
                    ["ttype", "=", "many2one"],
                    ["store", "=", true],
                ]);
                if (!count) {
                    this.addDialog(ConfirmationDialog, {
                        title: _t("No related many2one fields found"),
                        body: NO_M2O_AVAILABLE,
                        confirm: async () => {},
                    });
                    return;
                }
            }

            const fieldParams = await this.openFieldConfiguration(fieldType);
            if (!fieldParams) {
                return;
            }
            if (fieldType === "selection") {
                newNode.field_description.selection = fieldParams.selection;
            }
            if (fieldType === "one2many") {
                newNode.field_description.relation_field_id = fieldParams.relationId;
            }
            if (fieldType === "many2many" || fieldType === "many2one") {
                newNode.field_description.relation_id = fieldParams.relationId;
            }
            if (fieldType === "related") {
                Object.assign(newNode.field_description, fieldParams.relatedParams);
                if (!newNode.field_description.related) {
                    delete newNode.field_description.related;
                }
            }
        }

        if (
            fieldType === "monetary" ||
            (fieldType === "related" && newNode.field_description?.type === "monetary")
        ) {
            this.setCurrencyInfos(newNode.field_description);
        }

        if (fieldType === "integer") {
            newNode.field_description.default_value = "0";
        }

        return newNode;
    }

    openFieldConfiguration(fieldType) {
        let dialogProps;
        if (fieldType === "selection") {
            dialogProps = {
                Component: SelectionValuesEditor,
                isDialog: true,
            };
        } else if (["one2many", "many2many", "many2one"].includes(fieldType)) {
            dialogProps = {
                Component: RelationalFieldConfigurator,
                componentProps: { fieldType, resModel: this.viewEditorModel.resModel },
            };
        } else if (fieldType === "related") {
            dialogProps = {
                Component: RelatedChainBuilder,
                componentProps: {
                    resModel: this.viewEditorModel.resModel,
                },
            };
        }

        const fieldParams = new Promise((resolve, reject) => {
            this.addDialog(FieldConfigurationDialog, {
                fieldType,
                confirm: async (params) => {
                    resolve(params);
                },
                cancel: () => resolve(false),
                ...dialogProps,
            });
        });
        return fieldParams;
    }

    moveStructure(structure, droppedData, targetInfo) {
        if (structure !== "field") {
            throw Error("Moving anything else than a field is not supported");
        }

        if (
            isToXpathEquivalentFromXpath(
                targetInfo.position,
                targetInfo.xpath,
                droppedData.studioXpath
            )
        ) {
            return;
        }

        const operation = {
            type: "move",
            node: this.viewEditorModel.getFullTarget(droppedData.studioXpath),
            target: this.viewEditorModel.getFullTarget(targetInfo.xpath),
            position: targetInfo.position,
        };
        const subViewXpath = this.viewEditorModel.getSubviewXpath();
        if (subViewXpath) {
            operation.node.subview_xpath = subViewXpath;
        }

        if (this.viewEditorModel.activeNodeXpath === droppedData.studioXpath) {
            this.setAutoClick(targetInfo, operation.node);
        }
        this.viewEditorModel.doOperation(operation);
    }

    setCurrencyInfos(object) {
        const currencyField = getCurrencyField(this.viewEditorModel.fields);
        if (currencyField) {
            object.currency_field = currencyField;
            object.currency_in_view = this.viewEditorModel.fieldsInArch.includes(currencyField);
        }
    }
}

return __exports;
});
;

/****************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/interactive_editor_sidebar.js  *
*  Lines: 83                                                                                                    *
****************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar', ['@web/core/l10n/translation', '@odoo/owl', '@web/core/notebook/notebook', '@web/core/utils/hooks'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { _t } = require("@web/core/l10n/translation");
const { onWillStart, useState, onWillUpdateProps, Component } = require("@odoo/owl");

const { Notebook } = require("@web/core/notebook/notebook");
const { useBus } = require("@web/core/utils/hooks");

const tabsDisplay = {
    new: {
        class: "o_web_studio_new px-2",
        title: _t("Add"),
    },
    view: {
        class: "o_web_studio_view px-2",
        title: _t("View"),
    },
    properties: {
        class: "o_web_studio_properties px-2",
        title: _t("Properties"),
    },
};

const InteractiveEditorSidebar = __exports.InteractiveEditorSidebar = class InteractiveEditorSidebar extends Component {
    static components = { Notebook };
    static template = "web_studio.ViewEditor.InteractiveEditorSidebar";
    static props = {
        slots: { type: Object },
    };

    setup() {
        this.editorModel = useState(this.env.viewEditorModel);
        this.tabsDisplay = tabsDisplay;
        useBus(this.editorModel.bus, "error", () => this.render(true));

        this._defaultTab = this.computeDefaultTab(this.props);
        this.editorModel.sidebarTab = this._defaultTab;

        onWillStart(() => {
            this.editorModel.resetSidebar();
        });
        onWillUpdateProps(() => {
            // This component takes slots: it is always re-rendered
            const editorModel = this.editorModel;
            if (editorModel.sidebarTab === "properties" && !editorModel.activeNode) {
                editorModel.resetSidebar();
            }
        });
    }

    get icons() {
        return {
            new: "fa-plus",
            view: "fa-television",
            properties: "fa-server",
        };
    }

    computeDefaultTab(props) {
        const slots = props.slots;
        const defaults = Object.keys(slots).filter((s) => slots[s].isDefault);
        if (defaults.length) {
            return defaults[0];
        }
        return "new" in slots ? "new" : "view";
    }

    get defaultTab() {
        return this.editorModel.sidebarTab || this._defaultTab;
    }

    onTabClicked(tab) {
        if (tab !== "properties") {
            this.editorModel.resetSidebar(tab);
        }
        this.editorModel.sidebarTab = tab;
    }
}

return __exports;
});
;

/********************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute.js  *
*  Lines: 25                                                                                                                    *
********************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', ['@odoo/owl', '@web/core/l10n/translation', '@web_studio/client_action/view_editor/property/property'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { Property } = require("@web_studio/client_action/view_editor/property/property");

const ClassAttribute = __exports.ClassAttribute = class ClassAttribute extends Component {
    static template = "web_studio.ViewEditor.ClassAttribute";
    static components = {
        Property,
    };
    static props = {
        value: { type: String, optional: true },
        onChange: { type: Function },
    };
    get tooltip() {
        return _t(
            "Use Bootstrap or any other custom classes to customize the style and the display of the element."
        );
    }
}

return __exports;
});
;

/**********************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/field_properties/field_properties.js  *
*  Lines: 234                                                                                                                     *
**********************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/confirmation_dialog/confirmation_dialog', '@web/core/network/rpc', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog', '@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web/core/utils/hooks', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { Component, onWillStart, onWillUpdateProps, useState, toRaw } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { rpc } = require("@web/core/network/rpc");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { SelectionContentDialog } = require("@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog");
const { TypeWidgetProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useService } = require("@web/core/utils/hooks");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { ModifiersProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

class TechnicalName extends Component {
    static props = {
        node: { type: Object },
    };
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Field.TechnicalName";
    static components = { Property };

    setup() {
        this.renameField = (value) => {
            return this.env.viewEditorModel.renameField(
                this.props.node.attrs.name,
                `x_studio_${value}`,
                { autoUnique: false }
            );
        };
    }

    get canEdit() {
        return (
            this.env.debug && this.env.viewEditorModel.isFieldRenameable(this.props.node.attrs.name)
        );
    }

    get fieldName() {
        const fName = this.props.node.attrs.name;
        if (this.canEdit) {
            return fName.split("x_studio_")[1];
        }
        return fName;
    }
}

const FieldProperties = __exports.FieldProperties = class FieldProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Field";
    static props = {
        node: { type: Object },
        availableOptions: { type: Array, optional: true },
    };
    static components = {
        ClassAttribute,
        Property,
        TechnicalName,
        TypeWidgetProperties,
        ViewStructureProperties,
        ModifiersProperties,
    };

    setup() {
        this.dialog = useService("dialog");
        this.companyService = useService("company");
        this.multiCompany = Object.keys(this.companyService.allowedCompanies).length > 1;
        this.state = useState({});
        this.editNodeAttributes = useEditNodeAttributes();
        onWillStart(async () => {
            if (this._canShowDefaultValue(this.props.node)) {
                this.state.defaultValue = await this.getDefaultValue(this.props.node);
            }
        });

        onWillUpdateProps(async (nextProps) => {
            if (this._canShowDefaultValue(nextProps.node)) {
                this.state.defaultValue = await this.getDefaultValue(nextProps.node);
            }
        });
    }

    get viewEditorModel() {
        return this.env.viewEditorModel;
    }

    async onChangeFieldString(value) {
        if (this.viewEditorModel.isFieldRenameable(this.props.node.field.name) && value) {
            return this.viewEditorModel.renameField(this.props.node.attrs.name, value, {
                label: value,
            });
        } else {
            const operation = {
                new_attrs: { string: value },
                type: "attributes",
                position: "attributes",
                target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),
            };
            // FIXME: the python API is messy: we need to send node, which is the same as target since
            // we are editing the target's attributes, to be able to modify the python field's string
            operation.node = operation.target;
            return this.viewEditorModel.doOperation(operation);
        }
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }

    async onChangeDefaultValue(value) {
        await rpc("/web_studio/set_default_value", {
            model_name: this.env.viewEditorModel.resModel,
            field_name: this.props.node.field.name,
            value,
            company_id: this.companyService.currentCompany.id,
        });
        this.state.defaultValue = value;
    }

    getBoldValue() {
        const classList = this.props.node.arch.classList;
        return (
            classList.contains("fw-bold") ||
            classList.contains("fw-bolder") ||
            this.props.node.attrs.bold // legacy kanban
        );
    }

    async getDefaultValue(node) {
        const defaultValueObj = await rpc("/web_studio/get_default_value", {
            model_name: this.env.viewEditorModel.resModel,
            field_name: node.field.name,
            company_id: this.companyService.currentCompany.id,
        });
        return defaultValueObj.default_value;
    }

    get optionalVisibilityChoices() {
        return {
            choices: [
                { label: _t("Show by default"), value: "show" },
                { label: _t("Hide by default"), value: "hide" },
            ],
        };
    }

    getDefaultValuePropertyProps() {
        if (!this._canShowDefaultValue(this.props.node)) {
            return null;
        }
        const { field, attrs } = this.props.node;
        const props = {
            childProps: {},
            inputAttributes: {},
        };
        if (field.selection) {
            props.childProps.choices = this.props.node.field.selection.map(([value, label]) => {
                return {
                    label,
                    value,
                };
            });
        }
        const fieldType = field.type;
        const widget = attrs.widget;
        props.type = fieldType;
        if (widget === "statusbar") {
            props.type = "selection";
        }
        return props;
    }

    _canShowDefaultValue(node) {
        if (/^(in_group_|sel_groups_)/.test(node.attrs.name)) {
            return false;
        }
        return !["image", "many2many", "one2many", "many2one", "binary"].includes(node.field.type);
    }

    get canEditSelectionChoices() {
        return this.props.node.field.manual && this.props.node.field.type === "selection";
    }

    /**
     * @param {string} name of the attribute
     * @returns if this attribute supported in the current view
     */
    isAttributeSupported(name) {
        return this.props.availableOptions?.includes(name);
    }

    editSelectionChoices() {
        const field = this.props.node.field;
        this.dialog.add(SelectionContentDialog, {
            defaultChoices: toRaw(field).selection.map((s) => [...s]),
            onConfirm: async (choices) => {
                const result = await rpc("/web_studio/edit_field", {
                    model_name: this.env.viewEditorModel.resModel,
                    field_name: field.name,
                    values: { selection: JSON.stringify(choices) },
                    force_edit: false,
                });
                let reflectChanges = !result;
                if (result && result.records_linked) {
                    reflectChanges = false;
                    await new Promise((resolve) => {
                        this.dialog.add(ConfirmationDialog, {
                            body:
                                result.message ||
                                _t("Are you sure you want to remove the selection values?"),
                            confirm: async () => {
                                await rpc("/web_studio/edit_field", {
                                    model_name: this.env.viewEditorModel.resModel,
                                    field_name: field.name,
                                    values: { selection: JSON.stringify(choices) },
                                    force_edit: true,
                                });
                                reflectChanges = true;
                                resolve();
                            },
                            cancel: () => resolve(),
                        });
                    });
                }
                if (reflectChanges) {
                    field.selection = choices;
                }
            },
        });
    }
}

return __exports;
});
;

/**********************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility.js  *
*  Lines: 80                                                                                                                                  *
**********************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility', ['@odoo/owl', '@web/model/record', '@web_studio/client_action/view_editor/view_editor_model', '@web/core/record_selectors/multi_record_selector'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, onWillRender } = require("@odoo/owl");
const { Record } = require("@web/model/record");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");
const { MultiRecordSelector } = require("@web/core/record_selectors/multi_record_selector");

const LimitGroupVisibility = __exports.LimitGroupVisibility = class LimitGroupVisibility extends Component {
    static template = "web_studio.ViewEditor.LimitGroupVisibility";
    static components = {
        Record,
        MultiRecordSelector,
    };
    static props = {
        node: { type: Object },
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
        onWillRender(() => {
            const groups = JSON.parse(this.props.node.attrs.studio_groups || "[]");
            this.allowGroups = [];
            this.forbidGroups = [];
            this.currentGroups = [];
            for (const group of groups) {
                const groupId = group.id;
                this.currentGroups.push(groupId);
                if (group.forbid) {
                    this.forbidGroups.push(groupId);
                } else {
                    this.allowGroups.push(groupId);
                }
            }
        })
    }

    handleNodeGroupsChange(allow, forbid) {
        allow = new Set(allow || this.allowGroups);
        forbid = new Set(forbid || this.forbidGroups);
        if (!allow.isDisjointFrom(forbid)) {
            throw new Error("Cannot allow and forbid at the same time");
        }
        const resIds = [];
        for (const g of allow) {
            resIds.push(g);
        }
        for (const g of forbid) {
            resIds.push(`!${g}`)
        }
        return this.editNodeAttributes({ groups: resIds });
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }

    get allowGroupsProps() {
        return {
            resModel: "res.groups",
            domain: [["id", "not in", this.currentGroups]],
            resIds: this.allowGroups,
            update: (resIds) => this.handleNodeGroupsChange(resIds, null),
        };
    }

    get forbidGroupsProps() {
        return {
            resModel: "res.groups",
            domain: [["id", "not in", this.currentGroups]],
            resIds: this.forbidGroups,
            update: (resIds) => this.handleNodeGroupsChange(null, resIds),
        };
    }
}

return __exports;
});
;

/*******************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties.js  *
*  Lines: 117                                                                                                                  *
*******************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties', ['@odoo/owl', '@web/core/checkbox/checkbox', '@web/core/utils/hooks', '@web/core/expression_editor_dialog/expression_editor_dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { useOwnedDialogs } = require("@web/core/utils/hooks");
const { ExpressionEditorDialog } = require("@web/core/expression_editor_dialog/expression_editor_dialog");

const ModifiersProperties = __exports.ModifiersProperties = class ModifiersProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Modifiers";
    static components = { CheckBox };
    static props = {
        node: { type: Object },
        availableOptions: { type: Array },
    };

    setup() {
        this.addDialog = useOwnedDialogs();
    }

    /**
     * @param {string} name of the attribute
     * @returns if this attribute supported in the current view
     */
    isAttributeSupported(name) {
        return this.props.availableOptions?.includes(name);
    }

    // <tag invisible="EXPRESSION"  />
    onChangeModifier(name, value) {
        const isTypeBoolean = typeof value === "boolean";
        const encodesBoolean = isTypeBoolean || this.isBooleanExpression(value);
        const isTruthy = encodesBoolean ? this.isBoolTrue(value) : !!value;
        const newAttrs = {};
        const oldAttrs = { ...this.props.node.attrs };

        const changingInvisible = name === "invisible";
        const isInList = this.env.viewEditorModel.viewType === "list";

        if (encodesBoolean) {
            if (changingInvisible && isInList) {
                if (isTruthy) {
                    newAttrs["column_invisible"] = "True";
                } else {
                    newAttrs["column_invisible"] = "False";
                    newAttrs["invisible"] = "False";
                }
            } else {
                newAttrs[name] = isTruthy ? "True" : "False";
            }
        } else {
            newAttrs[name] = value;
            if (changingInvisible && isInList && "column_invisible" in oldAttrs) {
                newAttrs["column_invisible"] = "False";
            }
        }

        if (this.env.viewEditorModel.viewType === "form" && name === "readonly") {
            newAttrs.force_save = isTruthy ? "1" : "0";
        }

        const operation = {
            new_attrs: newAttrs,
            type: "attributes",
            position: "attributes",
            target: this.env.viewEditorModel.getFullTarget(
                this.env.viewEditorModel.activeNodeXpath
            ),
        };
        this.env.viewEditorModel.doOperation(operation);
    }

    getCheckboxClassName(value) {
        if (value && !this.isBooleanExpression(value)) {
            return "o_web_studio_checkbox_indeterminate";
        }
    }

    isBooleanExpression(expression) {
        return ["1", "0", "True", "true", "False", "false"].includes(expression);
    }

    isBoolTrue(value) {
        if (typeof value === "boolean") {
            return value;
        }
        return ["1", "True", "true"].includes(value);
    }

    valueAsBoolean(expression) {
        if (!expression) {
            return false;
        }
        if (this.isBooleanExpression(expression)) {
            return this.isBoolTrue(expression);
        }
        return true;
    }

    onConditionalButtonClicked(name, value) {
        if (typeof value !== "string" || value === "") {
            value = "False"; // See py.js:evaluateBooleanExpr default value is False
        }
        const { fields, resModel } = this.env.viewEditorModel;
        this.addDialog(ExpressionEditorDialog, {
            resModel,
            fields,
            expression: value,
            onConfirm: (expression) => this.onChangeModifier(name, expression),
        });
    }
}

return __exports;
});
;

/***********************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/properties.js  *
*  Lines: 53                                                                                               *
***********************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/properties', ['@odoo/owl', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox'], function (require) {
'use strict';
let __exports = {};
const { Component, useState, xml } = require("@odoo/owl");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");

class DefaultProperties extends Component {
    static props = {
        node: { type: Object },
    };
    static template = xml`
        <SidebarPropertiesToolbox/>
    `;
    static components = { SidebarPropertiesToolbox };
}

const Properties = __exports.Properties = class Properties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties";
    static props = {
        propertiesComponents: { type: Object },
    };
    static components = { DefaultProperties };

    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
    }

    get iconClass() {
        // first check if the structure has a dedicated icon
        let icon =
            this.env.viewEditorModel.editorInfo.editor.Sidebar.viewStructures?.[this.nodeType]
                ?.class;
        if (!icon && this.nodeType === "field") {
            icon = `o_web_studio_field_${this.node.field.type}`;
        }
        return icon || `o_web_studio_field_${this.nodeType}`;
    }

    get node() {
        return this.viewEditorModel.activeNode;
    }

    get propertiesComponent() {
        return this.props.propertiesComponents[this.nodeType] || {};
    }

    get nodeType() {
        return this.node?.arch.tagName;
    }
}

return __exports;
});
;

/******************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox.js  *
*  Lines: 78                                                                                                                                          *
******************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', ['@odoo/owl', '@web/core/utils/hooks', '@web/core/confirmation_dialog/confirmation_dialog', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { useService } = require("@web/core/utils/hooks");
const { AlertDialog, ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { _t } = require("@web/core/l10n/translation");

const SidebarPropertiesToolbox = __exports.SidebarPropertiesToolbox = class SidebarPropertiesToolbox extends Component {
    static props = {};
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Toolbox";

    setup() {
        this.orm = useService("orm");
        this.action = useService("action");
        this.dialog = useService("dialog");
    }

    get node() {
        return this.env.viewEditorModel.activeNode;
    }

    get nodeType() {
        return this.node.arch.tagName;
    }

    onRemoveFromView() {
        this.dialog.add(ConfirmationDialog, {
            body: _t(
                "Are you sure you want to remove this %s from the view?",
                this.node.humanName.toLowerCase()
            ),
            confirm: () => {
                return this.removeNodeFromArch();
            },
            cancel: () => {},
        });
    }

    async openFormAction() {
        if (/^(in_group_|sel_groups_)/.test(this.node.attrs.name)) {
            return this.dialog.add(AlertDialog, {
                body: _t("You cannot perform this action on this field."),
            });
        }
        const resId = await this.orm.searchRead(
            "ir.model.fields",
            [
                ["model", "=", this.env.viewEditorModel.resModel],
                ["name", "=", this.node.field.name],
            ],
            ["id"]
        );
        return this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "ir.model.fields",
                res_id: resId[0].id,
                views: [[false, "form"]],
                target: "current",
            },
            { clearBreadcrumbs: true }
        );
    }

    removeNodeFromArch(xpath) {
        const target = this.env.viewEditorModel.getFullTarget(xpath || this.node.xpath);
        const operation = {
            type: "remove",
            target,
        };
        this.env.viewEditorModel.resetSidebar();
        return this.env.viewEditorModel.doOperation(operation);
    }
}

return __exports;
});
;

/*************************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_specific_and_computed_properties.js  *
*  Lines: 152                                                                                                                                                *
*************************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_specific_and_computed_properties', ['@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");

/**
 * This object describes the properties editable in studio, depending on
 * one or more attribute of a field. The TypeWidgetProperties component will
 * retrieve the value by itself, or you can set a function with the `getValue`
 * key to compute it specifically for one editable property.
 */
const EDITABLE_FIELD_ATTRIBUTES = {
    context: {
        name: "context",
        label: _t("Context"),
        type: "string",
    },
    domain: {
        name: "domain",
        label: _t("Domain"),
        type: "domain",
        getValue({ attrs, field }) {
            return {
                domain: attrs.domain,
                relation: field.relation,
            };
        },
    },
    aggregate: {
        name: "aggregate",
        label: _t("Aggregate"),
        type: "selection",
        choices: [
            { value: "sum", label: _t("Sum") },
            { value: "avg", label: _t("Average") },
            { value: "none", label: _t("No aggregation") },
        ],
        getValue({ attrs }) {
            return attrs.sum ? "sum" : attrs.avg ? "avg" : "none";
        },
    },
    placeholder: {
        name: "placeholder",
        label: _t("Placeholder"),
        type: "string",
        help: _t("Displays a textual hint that helps the user when the field is empty."),
    },
};

const FIELD_TYPE_ATTRIBUTES = __exports.FIELD_TYPE_ATTRIBUTES = {
    char: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
    },
    date: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
    },
    datetime: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
    },
    float: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
        list: [EDITABLE_FIELD_ATTRIBUTES.aggregate],
    },
    html: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
    },
    integer: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
        list: [EDITABLE_FIELD_ATTRIBUTES.aggregate],
    },
    many2many: {
        common: [EDITABLE_FIELD_ATTRIBUTES.domain, EDITABLE_FIELD_ATTRIBUTES.context],
    },
    many2one: {
        common: [
            EDITABLE_FIELD_ATTRIBUTES.domain,
            EDITABLE_FIELD_ATTRIBUTES.context,
            EDITABLE_FIELD_ATTRIBUTES.placeholder,
        ],
    },
    monetary: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
        list: [EDITABLE_FIELD_ATTRIBUTES.aggregate],
    },
    selection: {
        common: [EDITABLE_FIELD_ATTRIBUTES.placeholder],
    },
};

/**
 * Computed Options are options that are tied to another option.
 * Their value and visibility depends on another option present in the sidebar.
 *
 * They must be documented using 'supportedOptions' on any field widget.
 * Then, register them under COMPUTED_DISPLAY_OPTIONS using the technical name of the option.
 *
 * Here is how to declare them :
 *
 *      COMPUTED_DISPLAY_OPTIONS = {
 *          dependent_option: {
 *              superOption (string): technical name of another option that has an impact on the dependent option.
 *                                      This option must also be documented under 'supportedOptions'.
 *              getValue (function): compute the value of the dependent option from super option value
 *              getReadonly (function): compute a boolean based on the super value.
 *                                      If true, the option is greyed out and it is not possible to interact with them.
 *                                      Otherwise, the dependent option can still be edited.
 *              getInvisible (function): compute a boolean based on the super value.
 *                                      If true, the option is not present in the sidebar.
 *          },
 *          ...
 *      }
 *
 */

const COMPUTED_DISPLAY_OPTIONS = __exports.COMPUTED_DISPLAY_OPTIONS = {
    collaborative_trigger: {
        superOption: "collaborative",
        getInvisible: (value) => !value,
    },
    no_quick_create: {
        superOption: "no_create",
        getValue: (value) => value,
        getReadonly: (value) => value,
    },
    no_create_edit: {
        superOption: "no_create",
        getValue: (value) => value,
        getReadonly: (value) => value,
    },
    decimals: {
        superOption: "human_readable",
        getInvisible: (value) => !value,
    },
    zoom_delay: {
        superOption: "zoom",
        getInvisible: (value) => !value,
    },
    placeholder_field: {
        superOption: "placeholder",
    },
    edit_max_value: {
        superOption: "editable",
        getInvisible: (value) => !value,
    },
    no_edit_color: {
        superOption: "color_field",
        getInvisible: (value) => !value,
    },
};

return __exports;
});
;

/**********************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties.js  *
*  Lines: 386                                                                                                                                 *
**********************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties', ['@odoo/owl', '@web/core/network/rpc', '@web/core/registry', '@web/core/utils/hooks', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_specific_and_computed_properties'], function (require) {
'use strict';
let __exports = {};
const { Component, onWillStart, onWillUpdateProps, useState } = require("@odoo/owl");
const { rpc } = require("@web/core/network/rpc");
const { registry } = require("@web/core/registry");
const { useService } = require("@web/core/utils/hooks");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const {
    fieldsToChoices,
    getWowlFieldWidgets,
} = require("@web_studio/client_action/view_editor/editors/utils");
const {
    FIELD_TYPE_ATTRIBUTES,
    COMPUTED_DISPLAY_OPTIONS,
} = require("@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_specific_and_computed_properties");

const TypeWidgetProperties = __exports.TypeWidgetProperties = class TypeWidgetProperties extends Component {
    static template =
        "web_studio.ViewEditor.InteractiveEditorProperties.Field.TypeWidgetProperties";
    static components = { Property };
    static props = {
        node: { type: Object },
        onChangeAttribute: { type: Function },
    };

    setup() {
        this.orm = useService("orm");
        this.attributes = useState({
            field: [],
            selection: [],
            boolean: [],
            domain: [],
            number: [],
            string: [],
            digits: [],
        });

        onWillStart(async () => {
            await this.computeAttributesList(this.props);
        });

        onWillUpdateProps(async (nextProps) => {
            await this.computeAttributesList(nextProps);
        });
    }

    async computeAttributesList(props) {
        this.attributesForCurrentTypeAndWidget = this.getAttributesForCurrentTypeAndWidget(props);
        await this.groupAttributesPerType(props);
    }

    async groupAttributesPerType(props) {
        this.attributes.field = await this.getAttributesOfTypeField(props);
        this.attributes.selection = this.getWidgetAttributes("selection", props);
        this.attributes.boolean = this.getWidgetAttributes("boolean", props);
        this.attributes.domain = this.getWidgetAttributes("domain", props);
        this.attributes.number = this.getWidgetAttributes("number", props);
        this.attributes.string = this.getWidgetAttributes("string", props);
        this.attributes.digits = this.getWidgetAttributes("digits", props);
    }

    async getAttributesOfTypeField(props) {
        const fieldAttributes = this.getWidgetAttributes("field", props);
        if (fieldAttributes.length) {
            const fields = Object.entries(this.env.viewEditorModel.fields).map(([key, value]) => {
                return {
                    ...value,
                    name: value.name || key,
                };
            });
            // for each attribute looking for a field, compute the choices to display in the SelectMenu
            await Promise.all(
                fieldAttributes.map(async (attribute) => {
                    const choices = await this.getFieldChoices(attribute, fields);
                    attribute.choices = choices;
                    this.getOptionObj(attribute.name).choices = choices;
                })
            );
            return fieldAttributes;
        }
        return [];
    }

    getSupportedOptionsAndAttributes(props) {
        const widgetName = this.isField
            ? props.node.attrs?.widget || props.node.field?.type
            : props.node.attrs.name;
        const itemsRegistry = registry.category(this.isField ? "fields" : "view_widgets").content;
        const widgetDescription =
            itemsRegistry[this.env.viewEditorModel.viewType + "." + widgetName] ||
            itemsRegistry[widgetName];
        return [
            // tag the attributes as the edition changes the attribute value instead of a value from the option attribute.
            ...(widgetDescription?.[1].supportedAttributes || []).map((e) => ({
                ...e,
                isAttribute: true,
            })),
            ...(widgetDescription?.[1].supportedOptions || []),
        ];
    }

    /**
     * @returns the list of available widgets for the current node
     */
    get widgetChoices() {
        const widgets = getWowlFieldWidgets(
            this.props.node.field.type,
            this.props.node.attrs.widget,
            [],
            this.env.debug
        );
        return {
            choices: widgets.map(([value, label]) => {
                label = label ? label : "";
                return {
                    label: `${label} (${value})`.trim(),
                    value,
                };
            }),
        };
    }

    /**
     * @returns the list of attributes available depending the type of field,
     * as well the current widget selected. For a widget node, there is no
     * concept of type, we simply read what supported options and attributes
     * are on the node
     */
    _getAttributesForCurrentTypeAndWidget(props) {
        if (!props.node.field) {
            // node is a widget, and there is no 'type' on such elements
            return JSON.parse(JSON.stringify(this.getSupportedOptionsAndAttributes(props)));
        }

        this.isField = true;

        const fieldType = props.node.field.type;
        const { viewType } = this.env.viewEditorModel;

        const fieldCommonViewsProperties = FIELD_TYPE_ATTRIBUTES[fieldType]?.common || [];
        const fieldSpecificViewProperties = FIELD_TYPE_ATTRIBUTES[fieldType]?.[viewType] || [];

        return [
            ...fieldCommonViewsProperties.map((e) => ({ ...e, isAttribute: true })),
            ...fieldSpecificViewProperties.map((e) => ({ ...e, isAttribute: true })),
            // create a deep copy of the options description to avoid modifying the original objects
            ...JSON.parse(JSON.stringify(this.getSupportedOptionsAndAttributes(props))),
        ];
    }

    getAttributesForCurrentTypeAndWidget(props) {
        const _attributes = this._getAttributesForCurrentTypeAndWidget(props);
        _attributes.forEach((property) => {
            if (COMPUTED_DISPLAY_OPTIONS[property.name]) {
                const dependentOption = COMPUTED_DISPLAY_OPTIONS[property.name];
                const superOption = _attributes.find((o) => o.name === dependentOption.superOption);
                property.isSubOption = true;
                if (!superOption.subOptions) {
                    superOption.subOptions = [];
                }
                if (!superOption.subOptions.includes(property.name)) {
                    // only add the subOption if not already present
                    superOption.subOptions.push(property.name);
                }
            }
        });
        return _attributes;
    }

    getOptionObj(optionName) {
        return this.attributesForCurrentTypeAndWidget.find((o) => o.name === optionName);
    }

    /**
     * @param {string} type of the attribute (eg. "string", "boolean" )
     * @returns only the given type of attributes for the current field node
     */
    getWidgetAttributes(type, props) {
        return this.attributesForCurrentTypeAndWidget
            .filter((attribute) => attribute.type === type)
            .map((attribute) => {
                if (attribute.isAttribute) {
                    return this.getPropertyFromAttributes(attribute, props);
                }
                return this.getPropertyFromOptions(attribute, props);
            })
            .filter((attribute) => attribute !== undefined);
    }

    async getFieldChoices(attribute, fields) {
        let availableFields = fields;
        // Specific code to filter available fields to display is handled here as supportedOptions
        // is a generic description and don't allow to describe the full spec of an option
        if (attribute.name === "fold_field") {
            if (this.env.viewEditorModel.activeNode.field.type === "selection") {
                // fold_field is only relevant with relational status with its own model
                attribute.isInvisible = true;
                return [];
            }
            const fields = await this.orm.call(
                this.env.viewEditorModel.activeNode.field.relation,
                "fields_get"
            );
            availableFields = Object.values(fields);
        } else if (attribute.name === "currency_field") {
            availableFields = availableFields.filter((f) => f.relation === "res.currency");
        }
        return fieldsToChoices(
            availableFields,
            attribute.availableTypes,
            (f) => f.name !== this.env.viewEditorModel.activeNode.attrs.name
        );
    }

    /**
     * Compute the property and its value from one or more attributes on the node
     */
    getPropertyFromAttributes(property, props) {
        let value;
        value = props.node.attrs[property.name];
        if (property.getValue) {
            const attrs = props.node.attrs || {};
            const field = props.node.field || {};
            value = property.getValue({ attrs, field });
        }
        if (value === undefined && property.default) {
            value = property.default;
        }
        return {
            ...property,
            value,
        };
    }

    /**
     * Compute the property and its value from the `options` attribute on the node
     */
    getPropertyFromOptions(property, props) {
        let value;
        if (COMPUTED_DISPLAY_OPTIONS[property.name]) {
            // The display of this property must be computed from the value of the corresponding super option
            const dependentOption = COMPUTED_DISPLAY_OPTIONS[property.name];
            const superOption = this.getOptionObj(dependentOption.superOption);
            const superValue = this.getPropertyFromOptions(superOption, props).value;
            if (dependentOption.getReadonly) {
                property.isReadonly = dependentOption.getReadonly(superValue);
            }
            if (dependentOption.getValue) {
                property.value = dependentOption.getValue(superValue);
                if (property.isReadonly) {
                    // The property value cannot be edited, return the computed value directly
                    return property;
                }
            }
            if (dependentOption.getInvisible) {
                property.isInvisible = dependentOption.getInvisible(superValue);
            }
        }
        value = props.node.attrs.options?.[property.name];
        if (property.type === "string") {
            value = JSON.stringify(value);
        }
        if (property.type === "boolean" && value !== undefined) {
            value = !!value;
        }
        if (value === undefined && property.default) {
            value = property.default;
        }
        if (property.name === "currency_field" && !value) {
            value = props.node.field.currency_field;
        }
        return {
            ...property,
            value,
        };
    }

    getSelectValue(value) {
        return typeof value === "object" ? JSON.stringify(value) : value;
    }

    async onChangeCurrency(value) {
        const proms = [];
        proms.push(
            rpc("/web_studio/set_currency", {
                model_name: this.env.viewEditorModel.resModel,
                field_name: this.props.node.field.name,
                value,
            })
        );
        this.env.viewEditorModel.fields[this.props.node.field.name]["currency_field"] = value;

        if (this.env.viewEditorModel.fieldsInArch.includes(value)) {
            // is the new currency in the view ?
            await Promise.all(proms).then((results) => {
                if (results[0] === true) {
                    this.env.viewEditorModel.fields[this.props.node.field.name]["currency_field"] =
                        value;
                }
            });
            // alter the value of the currently selected currency manually to trigger a re-render of the SelectMenu
            // with the correct value since we don't pass through doOperations from the ViewEditorModel
            this.attributes.field = this.attributes.field.map((e) => {
                if (e.name === "currency_field") {
                    e.value = value;
                }
                return e;
            });
            return;
        }

        const currencyNode = {
            tag: "field",
            attrs: { name: value },
        };

        const operation = {
            node: currencyNode,
            target: this.env.viewEditorModel.getFullTarget(
                this.env.viewEditorModel.activeNodeXpath
            ),
            position: "after",
            type: "add",
        };

        proms.push(this.env.viewEditorModel.doOperation(operation));
        await Promise.all(proms).then((results) => {
            if (results[0] === true) {
                this.env.viewEditorModel.fields[this.props.node.field.name]["currency_field"] =
                    value;
            }
        });
    }

    onChangeWidget(value) {
        return this.props.onChangeAttribute(value, "widget");
    }

    async onChangeProperty(value, name) {
        if (
            ["show_seconds", "show_time"].includes(name) &&
            !value &&
            this.props.node.field.type === "datetime" &&
            !this.props.node.attrs.widget
        ) {
            this.onChangeWidget("datetime");
        } else if (name === "currency_field" && this.props.node.field.type === "monetary") {
            await this.onChangeCurrency(value);
            if (!this.props.node.attrs.options?.[name]) {
                return;
            }
            value = ""; // the currency_field arch option will be deleted
        }

        const currentProperty = this.getOptionObj(name);
        if (currentProperty.isAttribute) {
            return this.props.onChangeAttribute(value, name);
        }
        const options = { ...this.props.node.attrs.options };
        if (value || currentProperty.type === "boolean") {
            if (currentProperty.type === "digits") {
                // The digits options is composed of two integers.
                // The first one is unused and the second one is passed to `toFixed`
                // from `formatFloat`. It should be an integer between 0 and 20.
                value = Number(value);
                if (!Number.isInteger(value) || value < 0 || value > 20) {
                    return;
                }
                options[name] = [value * 2, value];
            } else if (["[", "{"].includes(value[0]) || !isNaN(value)) {
                options[name] = JSON.parse(value);
            } else if (currentProperty.type === "number") {
                options[name] = Number(value);
            } else {
                options[name] = value;
            }
        } else {
            delete options[name];
        }
        this.props.onChangeAttribute(JSON.stringify(options), "options");
    }
}

return __exports;
});
;

/****************************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties.js  *
*  Lines: 20                                                                                                                                        *
****************************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', ['@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility', '@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { LimitGroupVisibility } = require("@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility");
const { SidebarPropertiesToolbox } = require("@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox");
const { Component, useState } = require("@odoo/owl");

const ViewStructureProperties = __exports.ViewStructureProperties = class ViewStructureProperties extends Component {
    static components = { LimitGroupVisibility, SidebarPropertiesToolbox };
    static template = "web_studio.ViewStructureProperties";
    static props = {
        slots: { type: Object },
    };
    setup() {
        this.viewEditorModel = useState(this.env.viewEditorModel);
    }
}

return __exports;
});
;

/************************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties.js  *
*  Lines: 33                                                                                                                        *
************************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/properties/widget_properties/widget_properties', ['@odoo/owl', '@web_studio/client_action/view_editor/property/property', '@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute', '@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties', '@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties', '@web_studio/client_action/view_editor/view_editor_model'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { Property } = require("@web_studio/client_action/view_editor/property/property");
const { ClassAttribute } = require("@web_studio/client_action/view_editor/interactive_editor/properties/class_attribute/class_attribute");
const { TypeWidgetProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/type_widget_properties/type_widget_properties");
const { ViewStructureProperties } = require("@web_studio/client_action/view_editor/interactive_editor/properties/view_structure_properties/view_structure_properties");
const { useEditNodeAttributes } = require("@web_studio/client_action/view_editor/view_editor_model");

const WidgetProperties = __exports.WidgetProperties = class WidgetProperties extends Component {
    static template = "web_studio.ViewEditor.InteractiveEditorProperties.Widget";
    static components = {
        ClassAttribute,
        Property,
        TypeWidgetProperties,
        ViewStructureProperties,
    };
    static props = {
        node: { type: Object },
    };

    setup() {
        this.editNodeAttributes = useEditNodeAttributes();
    }

    onChangeAttribute(value, name) {
        return this.editNodeAttributes({ [name]: value });
    }
}

return __exports;
});
;

/*******************************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox.js  *
*  Lines: 18                                                                                                                   *
*******************************************************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");

const SidebarViewToolbox = __exports.SidebarViewToolbox = class SidebarViewToolbox extends Component {
    static template = "web_studio.ViewEditor.ViewToolbox";
    static props = {
        canEditXml: { type: Boolean, optional: true },
        onMore: { type: Function, optional: true },
        openDefaultValues: { type: Function, optional: true },
        canEditDefaultValues: { type: Boolean, optional: true },
    };
}

return __exports;
});
;

/***********************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/operations_utils.js  *
*  Lines: 27                                                                       *
***********************************************************************************/
odoo.define('@web_studio/client_action/view_editor/operations_utils', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

__exports.viewGroupByOperation = viewGroupByOperation; function viewGroupByOperation(viewType, type, newValue, oldValue = undefined) {
    const operation_type = newValue ? "add" : "remove";
    const operation = {
        target: {
            view_type: viewType,
            field_names: [operation_type === "add" ? newValue : oldValue],
            operation_type,
            field_type: type,
        },
        type: "graph_pivot_groupbys_fields",
    };

    if (oldValue && newValue) {
        operation.target.operation_type = "replace";
        operation.target.old_field_names = oldValue;
    }

    return operation;
}

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/property/property.js  *
*  Lines: 59                                                                        *
************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/property/property', ['@odoo/owl', '@web/core/checkbox/checkbox', '@web/core/domain_selector_dialog/domain_selector_dialog', '@web/core/select_menu/select_menu', '@web/core/utils/hooks'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { DomainSelectorDialog } = require("@web/core/domain_selector_dialog/domain_selector_dialog");
const { SelectMenu } = require("@web/core/select_menu/select_menu");
const { useService } = require("@web/core/utils/hooks");

const Property = __exports.Property = class Property extends Component {
    static template = "web_studio.Property";
    static components = { CheckBox, SelectMenu, DomainSelectorDialog };
    static defaultProps = {
        childProps: {},
        class: "",
    };
    static props = {
        name: { type: String },
        type: { type: String },
        value: { optional: true },
        onChange: { type: Function, optional: true },
        childProps: { type: Object, optional: true },
        class: { type: String, optional: true },
        isReadonly: { type: Boolean, optional: true },
        slots: {
            type: Object,
            optional: true,
        },
        tooltip: { type: String, optional: true },
        inputAttributes: { type: Object, optional: true },
    };

    setup() {
        this.dialog = useService("dialog");
    }

    get className() {
        const propsClass = this.props.class ? this.props.class : "";
        return `o_web_studio_property_${this.props.name} ${propsClass}`;
    }

    onDomainClicked() {
        this.dialog.add(DomainSelectorDialog, {
            resModel: this.props.childProps.relation,
            domain: this.props.value || "[]",
            isDebugMode: !!this.env.debug,
            onConfirm: (domain) => this.props.onChange(domain, this.props.name),
        });
    }

    onViewOptionChange(value) {
        this.props.onChange(value, this.props.name);
    }
}

return __exports;
});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/studio_view.js  *
*  Lines: 131                                                                 *
******************************************************************************/
odoo.define('@web_studio/client_action/view_editor/studio_view', ['@web/search/with_search/with_search', '@web_studio/client_action/view_editor/editors/utils', '@odoo/owl', '@web/core/utils/hooks', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { WithSearch } = require("@web/search/with_search/with_search");
const { cleanClickedElements } = require("@web_studio/client_action/view_editor/editors/utils");
const { Component, onError, onMounted, toRaw, useRef, xml, useSubEnv, useEffect } = require("@odoo/owl");
const { useService } = require("@web/core/utils/hooks");
const { _t } = require("@web/core/l10n/translation");

const StudioView = __exports.StudioView = class StudioView extends Component {
    static components = { WithSearch };
    static template = xml`
        <div t-att-style="style" class="w-100" t-ref="viewRenderer">
            <WithSearch t-props="withSearchProps" t-slot-scope="search">
                <t t-component="viewEditorModel.editorInfo.editor.Controller" t-props="Object.assign(controllerProps, search)" />
            </WithSearch>
        </div>
    `;
    static props = { autoClick: { type: Function, optional: true }, "*": true }; // Same as View.js. This is just a wrapper
    setup() {
        this.notification = useService("notification");
        this.style = this.props.setOverlay ? "pointer-events: none;" : "";
        this.withSearchProps = {
            resModel: this.props.resModel,
            SearchModel: this.props.SearchModel,
            context: this.props.context,
            domain: this.props.domain,
            globalState: this.props.globalState,
            searchViewArch: this.props.searchViewArch,
            searchViewFields: this.props.searchViewFields,
            irFilters: this.props.searchViewIrFilters,
            display: this.props.display,
        };
        this.viewEditorModel = this.env.viewEditorModel;

        this.viewRenderer = useRef("viewRenderer");

        this.controllerProps = { ...this.viewEditorModel.controllerProps };
        if (this.viewEditorModel.initialState.activeNodeXpath) {
            onMounted(() => {
                const initialActiveNodeXpath = this.viewEditorModel.initialState.activeNodeXpath;
                this.viewEditorModel.initialState.activeNodeXpath = null;
                this.viewEditorModel.activeNodeXpath = initialActiveNodeXpath;
            });
        }
        useEffect(
            (xpath) => {
                if (xpath) {
                    this.updateActiveNode({ xpath, resetSidebarOnNotFound: true });
                }
            },
            () => [this.viewEditorModel.activeNodeXpath]
        );

        const rawModel = toRaw(this.viewEditorModel);
        useEffect(
            () => {
                rawModel.isInEdition = false;
            },
            () => [rawModel.isInEdition]
        );

        onError((error) => {
            if (rawModel.isInEdition) {
                this.notification.add(
                    _t(
                        "The requested change caused an error in the view. It could be because a field was deleted, but still used somewhere else."
                    ),
                    {
                        type: "danger",
                        title: _t("Error"),
                    }
                );
                this.viewEditorModel.resetSidebar("view");
                this.viewEditorModel._operations.undo(false);
            } else {
                throw error;
            }
        });

        const config = {
            ...this.env.config,
            onNodeClicked: (xpath) => {
                if (this.updateActiveNode({ xpath })) {
                    this.viewEditorModel.activeNodeXpath = xpath;
                }
            },
        };

        if (this.props.autoClick) {
            onMounted(() => this.props.autoClick());
        }

        useSubEnv({
            config,
            __beforeLeave__: null,
            __getGlobalState__: null,
            __getLocalState__: null,
            __getContext__: null,
            __getOrderBy__: null,
        });
    }

    updateActiveNode({ xpath, resetSidebarOnNotFound = false }) {
        const vem = this.env.viewEditorModel;
        cleanClickedElements(this.viewRenderer.el);
        const el = this.viewRenderer.el.querySelector(
            `[data-studio-xpath="${xpath}"], [studioxpath="${xpath}"]`
        );
        if (!el) {
            if (resetSidebarOnNotFound) {
                vem.resetSidebar();
            }
            return false;
        }
        if (vem.editorInfo.editor.styleClickedElement) {
            vem.editorInfo.editor.styleClickedElement(this.viewRenderer, { xpath });
            return true;
        }
        const clickable = el.closest(".o-web-studio-editor--element-clickable");
        if (clickable) {
            clickable.classList.add("o-web-studio-editor--element-clicked");
        }
        return true;
    }
}

return __exports;
});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/view_editor.js  *
*  Lines: 119                                                                 *
******************************************************************************/
odoo.define('@web_studio/client_action/view_editor/view_editor', ['@odoo/owl', '@web/core/utils/hooks', '@web/core/registry', '@web_studio/client_action/view_editor/studio_view', '@web_studio/client_action/view_editor/interactive_editor/interactive_editor', '@web_studio/client_action/view_editor/view_editor_hook', '@web/webclient/actions/action_service', '@web/views/view', '@web_studio/client_action/xml_resource_editor/xml_resource_editor', '@web/search/action_hook', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, onWillUpdateProps, useState, useSubEnv, useRef, markRaw } = require("@odoo/owl");

const { useBus, useService } = require("@web/core/utils/hooks");
const { registry } = require("@web/core/registry");
const { StudioView } = require("@web_studio/client_action/view_editor/studio_view");

const { InteractiveEditor } = require("@web_studio/client_action/view_editor/interactive_editor/interactive_editor");
const { useViewEditorModel } = require("@web_studio/client_action/view_editor/view_editor_hook");
const { standardActionServiceProps } = require("@web/webclient/actions/action_service");
const { getDefaultConfig } = require("@web/views/view");

const { XmlResourceEditor } = require("@web_studio/client_action/xml_resource_editor/xml_resource_editor");
const { useSetupAction } = require("@web/search/action_hook");
const { _t } = require("@web/core/l10n/translation");

class ViewXmlEditor extends XmlResourceEditor {
    static props = { ...XmlResourceEditor.props, studioViewArch: { type: String } };
    setup() {
        super.setup();
        this.viewEditorModel = this.env.viewEditorModel;
        useBus(this.viewEditorModel.bus, "error", () => this.render(true));
        this.studioViewState = useState({ arch: this.props.studioViewArch });

        onWillUpdateProps((nextProps) => {
            if (nextProps.studioViewArch !== this.props.studioViewArch) {
                const studioResource = this.getStudioResource(this.state.resourcesOptions);
                if (studioResource) {
                    studioResource.value.arch = nextProps.studioViewArch;
                }
            }
        });
    }

    getStudioResource(resourcesOptions) {
        return resourcesOptions.find((opt) => opt.value.id === this.viewEditorModel.studioViewId);
    }
}

const ViewEditor = __exports.ViewEditor = class ViewEditor extends Component {
    static props = { ...standardActionServiceProps };
    static components = { StudioView, InteractiveEditor, ViewXmlEditor };
    static template = "web_studio.ViewEditor";

    static displayName = _t("View Editor");

    setup() {
        /* Services */
        this.studio = useService("studio");
        this.orm = useService("orm");
        /* MISC */
        // Avoid pollution from the real actionService's env
        // Set config compatible with View.js
        useSubEnv({ config: getDefaultConfig() });

        // Usefull for drag/drop
        this.rootRef = useRef("root");
        this.rendererRef = useRef("viewRenderer");

        const initialState = {};
        const breadcrumbs = this.env.editionFlow.breadcrumbs;
        if (breadcrumbs.length) {
            initialState.showInvisible = breadcrumbs[0].initialState.showInvisible;
            initialState.activeNodeXpath = breadcrumbs.at(-1).initialState.activeNodeXpath;
        }

        this.viewEditorModel = useViewEditorModel(this.rendererRef, { initialState });

        useSetupAction({
            getLocalState: () => {
                // Use this as a hook that is triggered when the actionService knows
                // this component will be unmounted, is still alive and the new action
                // is being built.
                // We store the state in the breadcrumbs, because there two ways
                // to respawn the editor:
                // - the editor's breadcrumbs
                // - the standard actionService breadcrumbs
                const breadcrumbs = this.viewEditorModel.breadcrumbs;
                breadcrumbs[0].initialState = markRaw({
                    showInvisible: this.viewEditorModel.showInvisible,
                });
                const last = breadcrumbs.at(-1);
                last.initialState = markRaw({
                    ...(last.initialState || {}),
                    activeNodeXpath: this.viewEditorModel.activeNodeXpath,
                });
            },
        });
    }

    get interactiveEditorKey() {
        const { viewType, breadcrumbs } = this.viewEditorModel;
        let key = viewType;
        if (breadcrumbs.length > 1) {
            key += `_${breadcrumbs.length}`;
        }
        return key;
    }

    onSaveXml({ resourceId, oldCode, newCode }) {
        this.viewEditorModel.doOperation({
            type: "replace_arch",
            viewId: resourceId,
            oldArch: oldCode,
            newArch: newCode,
        });
    }

    onXmlEditorClose() {
        this.viewEditorModel.switchMode();
    }
}
registry.category("actions").add("web_studio.view_editor", ViewEditor);

return __exports;
});
;

/***********************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/view_editor_hook.js  *
*  Lines: 83                                                                       *
***********************************************************************************/
odoo.define('@web_studio/client_action/view_editor/view_editor_hook', ['@odoo/owl', '@web/core/utils/hooks', '@web_studio/studio_service', '@web_studio/client_action/editor/edition_flow', '@web_studio/client_action/view_editor/view_editor_model', '@web_studio/client_action/view_editor/view_editor_snackbar'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const {
    onWillDestroy,
    onWillStart,
    status,
    useComponent,
    useEnv,
    useState,
    useSubEnv,
} = require("@odoo/owl");
const { useOwnedDialogs, useService } = require("@web/core/utils/hooks");
const { viewTypeToString } = require("@web_studio/studio_service");
const {
    useEditorBreadcrumbs,
    useEditorMenuItem,
} = require("@web_studio/client_action/editor/edition_flow");
const { ViewEditorModel } = require("@web_studio/client_action/view_editor/view_editor_model");
const { ViewEditorSnackbar } = require("@web_studio/client_action/view_editor/view_editor_snackbar");

__exports.useViewEditorModel = useViewEditorModel; function useViewEditorModel(viewRef, { initialState }) {
    const env = useEnv();

    /* Services */
    const services = Object.fromEntries(
        ["orm", "ui", "notification"].map((sName) => {
            return [sName, useService(sName)];
        })
    );
    // Capture studio's state as a new Object. This is due to concurrency
    // issues because we are an action, and rendering may be caused by other things (reactives)
    services.studio = { ...env.services.studio };
    services.dialog = { add: useOwnedDialogs() };

    /* Coordination */
    // Communicates with editorMenu, provides standard server calls
    const editionFlow = useState(env.editionFlow);
    useEditorBreadcrumbs({ name: viewTypeToString(services.studio.editedViewType) });

    const viewEditorModel = new ViewEditorModel({
        env,
        services,
        editionFlow,
        viewRef,
        initialState,
    });
    useSubEnv({ viewEditorModel });

    const { _snackBar, _operations } = viewEditorModel;
    useEditorMenuItem({
        component: ViewEditorSnackbar,
        props: { operations: _operations, saveIndicator: _snackBar },
    });

    const component = useComponent();
    onWillStart(async () => {
        return new Promise((resolve, reject) => {
            viewEditorModel
                .load()
                .then(resolve)
                .catch((error) => {
                    if (status(component) !== "destroyed") {
                        reject(error);
                    }
                });
        });
    });

    onWillDestroy(() => {
        viewEditorModel.isInEdition = false;
    });
    return useState(viewEditorModel);
}

__exports.useSnackbarWrapper = useSnackbarWrapper; function useSnackbarWrapper(fn) {
    const env = useEnv();
    return env.viewEditorModel._decorateFunction(fn);
}

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/view_editor_model.js  *
*  Lines: 868                                                                       *
************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/view_editor_model', ['@web/core/network/rpc', '@web/core/registry', '@web/search/search_model', '@web_studio/client_action/view_editor/editors/xml_utils', '@odoo/owl', '@web/core/user', '@web/core/utils/strings', '@web/core/utils/xml', '@web_studio/studio_service', '@web_studio/client_action/view_editor/editors/utils', '@web_studio/client_action/utils', '@web/views/view_compiler', '@web/core/l10n/translation', '@web_studio/client_action/editor/edition_flow', '@web/core/utils/concurrency', '@web/core/confirmation_dialog/confirmation_dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { rpc } = require("@web/core/network/rpc");
const { registry } = require("@web/core/registry");
const { SearchModel } = require("@web/search/search_model");
const {
    computeXpath,
    getNodesFromXpath,
    getNodeAttributes,
    parseStringToXml,
    serializeXmlToString,
} = require("@web_studio/client_action/view_editor/editors/xml_utils");
const { EventBus, markRaw, useEnv, reactive, toRaw } = require("@odoo/owl");
const { user } = require("@web/core/user");
const { sprintf } = require("@web/core/utils/strings");
const { parseXML } = require("@web/core/utils/xml");
const { viewTypeToString } = require("@web_studio/studio_service");
const {
    xpathToLegacyXpathInfo,
    cleanClickedElements,
} = require("@web_studio/client_action/view_editor/editors/utils");
const { Reactive, getFieldsInArch, memoizeOnce } = require("@web_studio/client_action/utils");
const { getModifier, resetViewCompilerCache } = require("@web/views/view_compiler");
const { _t } = require("@web/core/l10n/translation");
const { EditorOperations, SnackbarIndicator } = require("@web_studio/client_action/editor/edition_flow");
const { Race } = require("@web/core/utils/concurrency");
const { AlertDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const editorsRegistry = registry.category("studio_editors");
const viewRegistry = registry.category("views");

class EditorOperationsWithSnackbar extends EditorOperations {
    constructor(params) {
        super(...arguments);
        this.snackBar = params.snackBar;
        this.race = markRaw(new Race());
    }

    _wrapPromise(prom) {
        const _prom = super._wrapPromise(prom);
        this.snackBar.add(this.race.add(_prom));
        return _prom;
    }
}

/**
 * Determines whether a given x2m field has a subview corresponding to archTag.
 * it returns hasArch, true if there is one usable arch already
 * and position, an index, starting at 1, to locate the node via an xpath
 * If there is no arch, hasArch is false, and we expect to go through "createInlineView"
 * The position is then the position of the future arch node
 */
function getSubarchPosition(mainArch, xpathToField, archTag) {
    // get eligible arch nodes, which were not automatically inlined by the server
    const xpathToArch = `${xpathToField}/${archTag}[not(@studio_subview_inlined)]`;
    const nodes = getNodesFromXpath(xpathToArch, parseStringToXml(mainArch));
    let hasArch = false;
    let position = 1;
    for (const node of nodes) {
        // When a subarch has groups="somegroup" and the user doesn't have those groups
        // The server makes it invisible via the modifiers.
        if (getModifier(node, "invisible") !== "True" && getModifier(node, "invisible") !== "1") {
            hasArch = true;
            break;
        }
        position++;
    }
    return { hasArch, position };
}

/**
 * Returns the arch of the subview
 *
 * @param {String} mainArch
 * @param {String} xpathToField
 * @param {String} viewType
 * @param {Number} position
 */
function getSubArch(mainArch, xpathToField, archTag, position) {
    const xpathToView = `${archTag}[${position}]`;
    const xpathToArch = `${xpathToField}/${xpathToView}`;
    const nodes = getNodesFromXpath(xpathToArch, parseStringToXml(mainArch));
    if (nodes.length !== 1) {
        throw new Error(`Single sub-view arch not found for xpath: ${xpathToArch}`);
    }
    return serializeXmlToString(nodes[0]);
}

function buildKey(...args) {
    return args.join("_");
}

const ViewEditorModel = __exports.ViewEditorModel = class ViewEditorModel extends Reactive {
    constructor({ env, services, editionFlow, viewRef, initialState = {} }) {
        super();
        this.initialState = initialState;
        this._isInEdition = false;
        this.mode = "interactive";
        this.env = env;
        this.bus = markRaw(new EventBus());
        this._services = markRaw(services);
        this._studio = services.studio;

        this._snackBar = new SnackbarIndicator();
        this._operations = new EditorOperationsWithSnackbar({
            do: this._handleOperations.bind(this),
            onDone: this._handleDone.bind(this),
            onError: this._handleError.bind(this),
            snackBar: this._snackBar,
        });

        this._decorateCall = async (callback, ...args) => {
            this._services.ui.block();
            const prom = callback(...args);
            this._snackBar.add(prom);
            try {
                return await prom;
            } finally {
                this._services.ui.unblock();
            }
        };
        this._decorateFunction = (callback) => {
            return async (...args) => {
                return this._decorateCall(callback, ...args);
            };
        };

        this._decoratedRpc = this._decorateFunction(rpc);

        this._editionFlow = editionFlow;

        this.GROUPABLE_TYPES = ["many2one", "char", "boolean", "selection", "date", "datetime"];

        this._activeNodeXpath = undefined;
        this.lastActiveNodeXpath = undefined;

        this._getEditor = memoizeOnce(() => {
            let viewType = this.viewType;
            const view = viewRegistry.contains(viewType) ? viewRegistry.get(viewType) : null;
            //FIXME remove as soon as the legacy api is removed (post v18)
            if (viewType === "kanban" && !this.mainArch.includes('t-name="card"')) {
                viewType = "kanban_legacy";
            }
            const editor = editorsRegistry.contains(viewType)
                ? editorsRegistry.get(viewType)
                : null;

            // When the mode is interactive, the priority is to get the taylor-made editor if it exists.
            // otherwise, the priority is to get the view, if it exists (e.g.:, the search editor doesn't have a view)
            return {
                getProps: editor ? editor.props : view.props,
                editor: this.mode === "interactive" ? editor || view : view || editor,
            };
        });

        this._getControllerProps = memoizeOnce(function () {
            let { resId, resIds } = this.isEditingSubview
                ? this._subviewInfo
                : this._studio.editedControllerState || {};
            resIds = resIds || [];
            resId = resId || resIds[0];

            const arch = parseXML(this.arch);
            if (this.mode !== "interactive") {
                arch.querySelectorAll(`[studio_no_fetch="1"]`).forEach((n) => n.remove());
            }

            const rootArchNode = this.xmlDoc.firstElementChild;
            const controllerClasses = Array.from(
                new Set([
                    "o_view_controller",
                    `o_${this.viewType}_view`,
                    ...(rootArchNode.getAttribute("class") || "").split(" "),
                ])
            ).filter((c) => c);

            let controllerProps = {
                info: {},
                relatedModels: { ...toRaw(this.viewDescriptions.relatedModels) },
                useSampleModel: ["graph", "pivot"].includes(this.viewType),
                searchMenuTypes: [],
                className: controllerClasses.join(" "),
                resId,
                resIds,
                resModel: this.resModel,
                arch,
                fields: { ...toRaw(this.fields) },
            };

            if (
                ["list", "list", "form"].includes(this.viewType) &&
                this.mode === "interactive" &&
                this._subviewInfo
            ) {
                controllerProps.parentRecord = this._subviewInfo.parentRecord;
            }
            // if (custom_view_id) {
            //     // for dashboard
            //     controllerProps.info.customViewId = custom_view_id;
            // }

            const { editor, getProps } = this.editorInfo;
            controllerProps = getProps
                ? getProps(controllerProps, editor, this.env.config)
                : controllerProps;

            return markRaw(controllerProps);
        });

        this.__getDefaultStudioViewProps = memoizeOnce(() => {
            const editedAction = this._studio.editedAction;
            let globalState;
            if (this._views.search && !this.isEditingSubview) {
                globalState = editedAction.globalState;
            }

            const context = this._subviewInfo ? this._subviewInfo.context : editedAction.context;
            const searchModel = this.editorInfo.editor.SearchModel || SearchModel;
            return {
                context: { ...context, studio: 1 },
                domain: editedAction.domain,
                resModel: this.resModel,
                SearchModel: searchModel,
                setOverlay:
                    !["form", "list", "list", "kanban", "search"].includes(this.viewType) ||
                    this.mode !== "interactive",
                display: { controlPanel: false, searchPanel: false },
                globalState,
            };
        });

        this._getActiveNode = memoizeOnce(() => {
            if (!this.activeNodeXpath) {
                return undefined;
            }

            const node = getNodesFromXpath(this.activeNodeXpath, this.xmlDoc)[0];
            if (!node) {
                return null;
            }
            const isField = node.tagName === "field";
            const attrs = getNodeAttributes(node);
            const humanName =
                this.editorInfo.editor.Sidebar.viewStructures?.[node.tagName]?.name || node.tagName;

            let field;
            if (isField) {
                field = reactive(this.fields[attrs.name]);
                Object.defineProperty(field, "label", {
                    get() {
                        return field.string;
                    },
                    configurable: true,
                });
            }
            return reactive({
                arch: node,
                attrs,
                humanName,
                xpath: this.activeNodeXpath,
                field,
            });
        });

        this._getUnprocessedXmlDoc = memoizeOnce((arch) => parseStringToXml(arch));

        this.breadcrumbs = editionFlow.breadcrumbs;

        this._editionFlow = editionFlow;

        this._views = {};

        this.studioViewArch = "";
        this.viewDescriptions = {
            relatedModels: {},
            fields: [],
        };
        this.viewRef = viewRef;

        this.showInvisible = initialState.showInvisible || false;

        // Keep track of the current sidebarTab to be able to
        // restore it when switching back from the xml editor
        // to the interactive editor.
        this._currentSidebarTab = undefined;

        this._getFieldsAllowedRename = memoizeOnce(() => {
            return new Set();
        });
    }

    //-----------------------------------------------------------------
    // Public getters and setters
    //-----------------------------------------------------------------
    get editorInfo() {
        return this._getEditor(buildKey(this.viewType, this.mode));
    }

    get controllerProps() {
        const key = buildKey(
            this.arch,
            this.viewType,
            this.mode,
            this.resModel,
            this.breadcrumbs.length > 1 ? this.breadcrumbs.length : 1
        );
        return this._getControllerProps(key);
    }

    get studioViewProps() {
        const key = buildKey(this.viewType, this.resModel, this.mode, this.isEditingSubview);
        return this.__getDefaultStudioViewProps(key);
    }

    get xmlDoc() {
        return this._getUnprocessedXmlDoc(this.arch);
    }

    get isEditingSubview() {
        return this.breadcrumbs.length > 1;
    }

    set isInEdition(value) {
        value = !!value; // enforce boolean
        if (this.isInEdition === value) {
            return;
        }
        this._isInEdition = value;
        if (value) {
            this._services.ui.block();
        } else {
            this._services.ui.unblock();
        }
    }

    get isInEdition() {
        return this._isInEdition;
    }

    get mainView() {
        return this._views ? this._views[this.mainViewType] : undefined;
    }

    get mainArch() {
        return this.mainView ? this.mainView.arch : "";
    }

    get mainViewType() {
        return this._studio.editedViewType;
    }

    get mainResModel() {
        return this._studio.editedAction.res_model;
    }

    get arch() {
        return this.isEditingSubview ? this._subviewInfo.getArch(this.mainArch) : this.mainArch;
    }

    get viewType() {
        return this.isEditingSubview ? this._subviewInfo.viewType : this.mainViewType;
    }

    get view() {
        return this._views[this.viewType];
    }

    get resModel() {
        return this.isEditingSubview ? this._subviewInfo.resModel : this.mainResModel;
    }

    get fields() {
        return this.viewDescriptions.relatedModels[this.resModel].fields;
    }

    get activeNode() {
        return this._getActiveNode(buildKey(this.activeNodeXpath, this.arch));
    }

    get studioViewKey() {
        return buildKey(this.arch, JSON.stringify(this.fields));
    }

    get fieldsInArch() {
        return getFieldsInArch(this.xmlDoc);
    }

    get isChatterAllowed() {
        return !this.isEditingSubview && this._isChatterAllowed;
    }

    get activeNodeXpath() {
        return this._activeNodeXpath;
    }

    set activeNodeXpath(value) {
        this._activeNodeXpath = value;
        if (value) {
            this.lastActiveNodeXpath = value;
        }
    }

    get sidebarTab() {
        if (this.activeNodeXpath) {
            return "properties";
        }
        return this._currentSidebarTab;
    }

    set sidebarTab(newTab) {
        this._currentSidebarTab = newTab;
    }

    //-----------------------------------------------------------------
    // Public methods
    //-----------------------------------------------------------------

    async editX2ManyView({ viewType, fieldName, record, xpath, fieldContext }) {
        const staticList = record.data[fieldName];
        const resIds = staticList.records.map((r) => r.resId).filter(id => !!id);
        const resModel = staticList.resModel;
        const archTag = viewType;

        // currentFullXpath is the absolute xpath to the current edited subview as a function of the whole full arch
        // while xpath is the absolute xpath to the field we want to edit a subarch for, as a function of its subArch
        // currentFullXpath: /form[x]/field[y]/form[z]
        // xpath: /form[g]/field[h]/form[i]
        // Where form[z] and form[g] do point to the same subArch
        // We need to combine them to get a xpath of the field's arch we want to edit as a function of the entire main arch
        // what we want: /form[x]/field[y]/form[z]/field[h]/form[i]
        const currentFullXpath = this.getSubviewXpath();
        let xpathToField = xpath;
        if (currentFullXpath) {
            const xpathWithoutView = xpath.split("/").slice(2);
            xpathToField = `${currentFullXpath}/${xpathWithoutView.join("/")}`;
        }

        const { hasArch, position } = getSubarchPosition(this.mainArch, xpathToField, archTag);
        if (!hasArch) {
            const subViewRef = fieldContext[`${archTag}_view_ref`] || null;
            this.studioViewArch = await this._createInlineView({
                subViewType: viewType,
                fullXpath: xpathToField,
                subViewRef,
                resModel,
                fieldName,
            });
            const viewDescriptions = await this._editionFlow.loadViews();
            this.viewDescriptions = viewDescriptions;
            Object.assign(this._views, viewDescriptions.views);
            this._operations.clear(false);
        }
        await this._decorateCall(() => this.fieldsGet(resModel));

        const context = Object.fromEntries(
            Object.entries(fieldContext).filter(([key, val]) => {
                return !key.startsWith("default_") && !key.endsWith("_view_ref");
            })
        );

        const x2ManyEditionInfo = {
            name: sprintf("Subview %s", viewTypeToString(viewType)),
            context,
            resModel,
            resId: resIds[0],
            resIds,
            viewType,
            parentRecord: record,
            xpath: `${xpath}/${archTag}[${position}]`, // /form[x]/field[y]/list[z]
            fieldName,
            getArch: memoizeOnce((mainArch) => {
                return getSubArch(mainArch, xpathToField, archTag, position);
            }),
        };
        this._editionFlow.pushBreadcrumb(x2ManyEditionInfo);
    }

    async fieldsGet(resModel) {
        this.fieldsGetCache = this.fieldsGetCache || new Set();
        if (!this.fieldsGetCache.has(resModel)) {
            const fg = await this._services.orm.call(resModel, "fields_get");
            this.fieldsGetCache.add(resModel);
            Object.assign(this.viewDescriptions.relatedModels[resModel].fields, fg);
        }
    }

    async load() {
        const proms = [this._editionFlow.loadViews({ forceSearch: true })];

        if (this.viewType === "form") {
            proms.push(this._studio.isAllowed("chatter", this.mainResModel));
        }

        const [viewDescriptions, isChatterAllowed] = await Promise.all(proms);
        this._isChatterAllowed = isChatterAllowed;
        this.viewDescriptions = viewDescriptions || {
            relatedModels: {},
            fields: [],
        };
        Object.assign(this._views, viewDescriptions.views);
        const { mainViewId, viewId, arch } = await this._getStudioViewArch();
        this.studioViewArch = arch;
        this.studioViewId = viewId;
        if (!this.mainView.id) {
            // the call to getStudioViewArch has created the view in DB (before that, it was the default_view)
            // Clear the caches, in particular the one of the viewService to aknowledge that.
            this.env.bus.trigger("CLEAR-CACHES");
            this.mainView.id = mainViewId;
        }
    }

    getSubviewXpath() {
        if (!this.isEditingSubview) {
            return null;
        }
        const temp = [`/${this.mainViewType}[1]`];
        this.breadcrumbs.slice(1).forEach(({ data }) => {
            const withoutView = data.xpath.split("/").slice(2);
            temp.push(...withoutView);
        });
        return temp.join("/");
    }

    getFullTarget(xpath, { isXpathFullAbsolute = true } = {}) {
        const nodes = getNodesFromXpath(xpath, this.xmlDoc);
        if (nodes.length !== 1) {
            throw new Error("Xpath resolved to nothing or multiple nodes");
        }
        const element = nodes[0];

        // Attributes that could be used to identify the node python side, it is mandatory
        // Although it might be more robust to rely solely on a sufficiently expressive xpath
        const attrs = {};
        ["name", "id", "class", "for"].forEach((attrName) => {
            if (element.hasAttribute(attrName)) {
                attrs[attrName] = element.getAttribute(attrName);
            }
        });

        let xpath_info;
        if (isXpathFullAbsolute) {
            xpath_info = xpathToLegacyXpathInfo(xpath);
        } else {
            const fullAbsolute = computeXpath(element, this.viewType);
            xpath_info = xpathToLegacyXpathInfo(fullAbsolute);
        }

        const target = {
            tag: element.tagName,
            attrs,
            xpath_info,
        };

        const subViewXpath = this.getSubviewXpath();
        if (subViewXpath) {
            target.subview_xpath = subViewXpath;

            const subViewTargetInfo = xpathToLegacyXpathInfo(subViewXpath);
            xpath_info.splice(0, 1, subViewTargetInfo[subViewTargetInfo.length - 1]);
        }
        return target;
    }

    async doOperation(operation, write = true) {
        return this._operations.do(operation, !write);
    }

    pushOperation(operation) {
        return this._operations.pushOp(operation);
    }

    /** Mode and Sidebar */
    resetSidebar(tab = null) {
        this.sidebarTab = tab;
        // store the last active xpath in this variable
        this.activeNodeXpath = undefined;

        const resetEl = this.viewRef.el;
        if (resetEl) {
            cleanClickedElements(resetEl);
        }
    }

    switchMode() {
        resetViewCompilerCache();
        this.mode = this.mode === "interactive" ? "xml" : "interactive";
    }

    /** Field Renaming */
    setRenameableField(fieldName, add = true) {
        if (add) {
            this._fieldsAllowedRename.add(fieldName);
        } else {
            this._fieldsAllowedRename.delete(fieldName);
        }
    }

    isFieldRenameable(fieldName) {
        return this._fieldsAllowedRename.has(fieldName);
    }

    async renameField(fieldName, newName, { label, autoUnique = true } = {}) {
        // Sanitization
        newName = newName
            .toLowerCase()
            .trim()
            .replace(/[^\w\s-]/g, "") // remove non-word [a-z0-9_], non-whitespace, non-hyphen characters
            .replace(/[\s_-]+/g, "_") // swap any length of whitespace, underscore, hyphen characters with a single _
            .replace(/^-+|-+$/g, ""); // remove leading, trailing

        if (!newName.startsWith("x_studio_")) {
            newName = `x_studio_${newName}`;
        }

        const existingFields = this.fields;
        if (autoUnique) {
            const baseName = newName;
            let index = 1;
            while (newName in existingFields) {
                newName = baseName + "_" + index;
                index++;
            }
        }

        if (!autoUnique && newName in existingFields) {
            this._services.dialog.add(AlertDialog, {
                body: _t("A field with the same name already exists."),
            });
            return;
        }
        this.isInEdition = true;
        const prom = rpc("/web_studio/rename_field", {
            studio_view_id: this.studioViewId,
            studio_view_arch: this.studioViewArch,
            model: this.resModel,
            old_name: fieldName,
            new_name: newName,
            new_label: label,
        });

        this._snackBar.add(prom);

        try {
            await prom;
        } catch (e) {
            this.isInEdition = false;
            throw e;
        }

        const strOperations = JSON.stringify(this._operations.operations);
        // We only want to replace exact matches of the field name, but it can
        // be preceeded/followed by other characters, like parent.my_field or in
        // a domain like [('...', '...', my_field)] etc.
        // Note that negative lookbehind is not correctly handled in JS ...
        const chars = "[^\\w\\u007F-\\uFFFF]";
        const re = new RegExp(`(${chars}|^)${fieldName}(${chars}|$)`, "g");
        this._operations.clear();
        this.setRenameableField(fieldName, false);
        this.setRenameableField(newName, true);
        this._operations.doMulti(JSON.parse(strOperations.replace(re, `$1${newName}$2`)));
    }

    //-----------------------------------------------------------------
    // Private
    //-----------------------------------------------------------------

    async _createInlineView({ subViewType, fullXpath, subViewRef, resModel, fieldName }) {
        // We build the correct xpath if we are editing a 'sub' subview
        // Use specific view if available in context
        // We write views in the base language to make sure we do it on the source term field
        // of ir.ui.view
        const context = { ...user.context, lang: false, studio: true };
        if (subViewRef) {
            context[`${subViewType}_view_ref`] = subViewRef;
        }

        // FIXME: maybe this route should return def _return_view
        const studioViewArch = await this._decoratedRpc("/web_studio/create_inline_view", {
            model: resModel,
            view_id: this.mainView.id,
            field_name: fieldName,
            subview_type: subViewType,
            subview_xpath: fullXpath,
            context,
        });
        this.env.bus.trigger("CLEAR-CACHES");
        return studioViewArch;
    }

    /** Arch Edition */
    async _editView(operations) {
        const context = {
            ...user.context,
            ...(this._studio.editedAction.context || {}),
            lang: false,
            studio: true,
        };
        return rpc("/web_studio/edit_view", {
            view_id: this.mainView.id,
            studio_view_arch: this.studioViewArch,
            operations: operations,
            model: this.resModel,
            context,
        });
    }

    async _editViewArch(viewId, viewArch) {
        const context = {
            ...user.context,
            ...(this._studio.editedAction.context || {}),
            lang: false,
            studio: true,
        };
        const result = await rpc("/web_studio/edit_view_arch", {
            view_id: viewId,
            view_arch: viewArch,
            // We write views in the base language to make sure we do it on the source term field
            // of ir.ui.view
            context,
        });
        return result;
    }

    async _handleOperations({ mode, operations, lastOp }) {
        this.isInEdition = true;
        if (lastOp.type !== "replace_arch") {
            operations = operations.filter((op) => op.type !== "replace_arch");
            return this._editView(operations);
        } else {
            const viewId = lastOp.viewId;
            let { newArch, oldArch } = lastOp;
            if (mode === "undo") {
                const _newArch = newArch;
                newArch = oldArch;
                oldArch = _newArch;
            }
            return this._editViewArch(viewId, newArch);
        }
    }

    async restoreDefaultView(viewId) {
        const result = await this._editionFlow.restoreDefaultView(viewId, this.mainViewType);
        if (result) {
            this.viewDescriptions.relatedModels = result.models;
            this._views[this.mainViewType].arch = result.views[this.mainViewType].arch;
            this._operations.clear();
        }
    }

    _handleDone({ mode, pending, pendingUndone, result }) {
        this.env.bus.trigger("CLEAR-CACHES");
        if (this.mainViewType === "kanban") {
            // the cache is on a by-template basis
            // kanban may have multiple t-name templates
            // Wipe everything to force re-compilation
            resetViewCompilerCache();
        }
        if (result) {
            this.viewDescriptions.relatedModels = result.models;

            const oldArch = this._views[this.mainViewType].arch;
            const newArch = result.views[this.mainViewType].arch;
            this._views[this.mainViewType].arch = newArch;
            if (oldArch === newArch) {
                this.isInEdition = false;
            }

            if (!this.studioViewId && result.studio_view_id) {
                this.studioViewId = result.studio_view_id;
            }
        }

        const isUndoing = mode === "undo";
        const pendingOps = isUndoing ? pendingUndone : pending;
        const lastOperation = pendingOps[pendingOps.length - 1];
        if (lastOperation && lastOperation.type === "replace_arch") {
            if (lastOperation.viewId === this.studioViewId) {
                this.studioViewArch = isUndoing ? lastOperation.oldArch : lastOperation.newArch;
                this._operations.clear();
                const ops = isUndoing ? this._operations.undone : this._operations.operations;
                ops.push(lastOperation);
            }
        }
    }

    async _handleError({ mode, pending, error }) {
        this.isInEdition = false;
        this._services.notification.add(
            _t("This operation caused an error, probably because a xpath was broken"),
            {
                type: "danger",
                title: _t("Error"),
            }
        );

        Promise.resolve().then(() => {
            throw error;
        });

        this.resetSidebar("view");
        this.bus.trigger("error");
    }

    async _getStudioViewArch() {
        const result = await rpc("/web_studio/get_studio_view_arch", {
            model: this.resModel,
            view_type: this.viewType,
            view_id: this.mainView.id,
            context: { ...user.context, lang: false },
        });
        return {
            arch: result.studio_view_arch,
            viewId: result.studio_view_id,
            mainViewId: result.main_view_id,
        };
    }

    get _subviewInfo() {
        if (!this.isEditingSubview) {
            return null;
        }
        const length = this.breadcrumbs.length;
        return this.breadcrumbs[length - 1].data;
    }

    get _fieldsAllowedRename() {
        return this._getFieldsAllowedRename(
            this.breadcrumbs.length > 1 ? this.breadcrumbs.length : 1
        );
    }
}

__exports.useEditNodeAttributes = useEditNodeAttributes; function useEditNodeAttributes({ isRoot = false } = {}) {
    const vem = useEnv().viewEditorModel;
    function editNodeAttributes(newAttributes) {
        let target;
        let node;
        if (isRoot) {
            target = vem.getFullTarget(`/${vem.viewType}`);
            target.isSubviewAttr = true;
        } else {
            target = vem.getFullTarget(vem.activeNodeXpath);
            const { arch, attrs } = vem.activeNode;
            node = {
                tag: arch.tagName,
                attrs,
            };
        }

        const operation = {
            new_attrs: newAttributes,
            type: "attributes",
            position: "attributes",
            target,
        };
        if (node) {
            operation.node = node;
        }
        return vem.doOperation(operation);
    }
    return editNodeAttributes;
}

return __exports;
});
;

/***************************************************************************************
*  Filepath: /web_studio/static/src/client_action/view_editor/view_editor_snackbar.js  *
*  Lines: 16                                                                           *
***************************************************************************************/
odoo.define('@web_studio/client_action/view_editor/view_editor_snackbar', ['@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component } = require("@odoo/owl");

const ViewEditorSnackbar = __exports.ViewEditorSnackbar = class ViewEditorSnackbar extends Component {
    static template = "web_studio.ViewEditor.Snackbar";
    static props = {
        operations: Object,
        saveIndicator: Object,
    };
}

return __exports;
});
;

/**********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/xml_resource_editor/xml_resource_editor.js  *
*  Lines: 254                                                                                 *
**********************************************************************************************/
odoo.define('@web_studio/client_action/xml_resource_editor/xml_resource_editor', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/code_editor/code_editor', '@web/core/network/rpc', '@web/core/resizable_panel/resizable_panel', '@web/core/select_menu/select_menu'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { Component, onWillStart, onWillUpdateProps, toRaw, useState } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { CodeEditor } = require("@web/core/code_editor/code_editor");
const { rpc } = require("@web/core/network/rpc");
const { ResizablePanel } = require("@web/core/resizable_panel/resizable_panel");
const { SelectMenu } = require("@web/core/select_menu/select_menu");

class ViewSelector extends SelectMenu {
    static template = "web_studio.ViewSelector";
    static choiceItemTemplate = "web_studio.ViewSelector.ChoiceItemRecursive";
    static props = {
        ...SelectMenu.props,
        choices: {
            optional: true,
            type: Array,
            element: {
                type: Object,
                shape: {
                    value: true,
                    label: { type: String },
                    resource: { optional: true },
                },
            },
        },
    };

    getMainViews() {
        return this.state.displayedOptions.filter((opt) => opt.resource.isMainResource);
    }

    getInherited(choice) {
        const inheritedChoices = this.state.displayedOptions.filter(
            (opt) => (opt.resource.inherit_id || [])[0] === choice.resource.id
        );
        if (inheritedChoices.length) {
            inheritedChoices.forEach((opt) => (opt.resource.relatedChoice = choice.resource.id));
        }
        return inheritedChoices;
    }

    getComposedBy(choice) {
        const resource = choice.resource;
        if (!resource.called_xml_ids) {
            return [];
        }
        const composedChoices = this.state.displayedOptions.filter(
            (opt) =>
                resource.called_xml_ids.includes(opt.resource.xml_id) ||
                resource.called_xml_ids.includes(opt.resource.key)
        );
        if (composedChoices.length) {
            composedChoices.forEach((opt) => (opt.resource.relatedChoice = resource.id));
        }
        return composedChoices;
    }

    // Parents of displayed options must also be visible when doing a search
    // Based on the filtered choices, they must be added from the list of choices
    sliceDisplayedOptions() {
        const childChoices = this.state.choices.filter((c) => c.resource.relatedChoice);
        childChoices.forEach((c) => this.addRelatedChoice(c.resource.relatedChoice));
        super.sliceDisplayedOptions();
    }

    addRelatedChoice(parentId) {
        if (this.state.choices.findIndex((c) => c.resource.id === parentId) === -1) {
            const parent = this.props.choices.find((c) => c.resource.id === parentId);
            if (!parent.resource.isMainResource) {
                this.addRelatedChoice(parent.resource.relatedChoice);
            }
            this.state.choices.push(parent);
        }
    }
}

const XmlResourceEditor = __exports.XmlResourceEditor = class XmlResourceEditor extends Component {
    static template = "web_studio.XmlResourceEditor";
    static components = { ResizablePanel, CodeEditor, SelectMenu: ViewSelector };
    static props = {
        onClose: { type: Function },
        onCodeChange: { type: Function, optional: true },
        onSave: { type: Function, optional: true },
        mainResourceId: { type: true },
        defaultResourceId: { type: true, optional: true },
        getDefaultResource: { optional: true, type: Function },
        canSave: { type: Boolean, optional: true },
        minWidth: { type: Number, optional: true },
        reloadSources: { type: Number, optional: true },
        displayAlerts: { type: Boolean, optional: true },
        onResourceChange: { type: Function, optional: true },
    };
    static defaultProps = {
        canSave: true,
        minWidth: 400,
        reloadSources: 1,
        displayAlerts: true,
        onResourceChange: () => {},
        getDefaultResource: () => {},
    };

    setup() {
        this.state = useState({
            resourcesOptions: [],
            currentResourceId: null,
            _codeChanges: null,
        });
        this.codeEditorKey = this.props.reloadSources;
        onWillStart(() => this.loadResources(this.props.mainResourceId));

        onWillUpdateProps(async (nextProps) => {
            const resourceChanged = nextProps.mainResourceId !== this.props.mainResourceId;
            const shouldReload = resourceChanged || this.codeEditorKey !== nextProps.reloadSources;
            const nextResourceId =
                nextProps.mainResourceId !== this.props.mainResourceId
                    ? nextProps.mainResourceId
                    : this.state.currentResourceId;

            if (resourceChanged) {
                this.cursorPosition = undefined;
            }

            if (shouldReload) {
                this.state._codeChanges = null;
                await this.loadResources(nextProps.mainResourceId);
                this.state.currentResourceId = nextResourceId;
            }
            this.codeEditorKey = nextProps.reloadSources;
        });

        this.alerts = useState({
            "built-in-file": {
                message: _t(
                    "Editing a built-in file through this editor is not advised, as it will prevent it from being updated during future App upgrades."
                ),
                display: true,
            },
        });
    }

    get minWidth() {
        return this.props.minWidth;
    }

    get arch() {
        const currentResourceId = this.state.currentResourceId;
        if (!currentResourceId) {
            return "";
        }
        return this.tempCode || this.getResourceFromId(currentResourceId).arch;
    }

    get tempCode() {
        if (!this.state.currentResourceId) {
            return "";
        }
        return this.state._codeChanges && this.state._codeChanges[this.state.currentResourceId];
    }

    set tempCode(value) {
        if (!this.state.currentResourceId) {
            return;
        }
        this.state._codeChanges = this.state._codeChanges || {};
        this.state._codeChanges[this.state.currentResourceId] = value;
    }

    getResourceFromId(resourceId) {
        const opt = this.state.resourcesOptions.find((opt) => opt.value === resourceId) || {};
        return opt.resource;
    }

    onFormat() {
        this.tempCode = window.vkbeautify.xml(this.tempCode || this.arch, 4);
    }

    hideAlert(alertKey) {
        this.alerts[alertKey].display = false;
    }

    onCloseClick() {
        this.props.onClose();
    }

    onCodeChange(code, cursorPosition) {
        this.cursorPosition = cursorPosition;
        this.tempCode = code;
        if ("onCodeChange" in this.props) {
            this.props.onCodeChange({ ...toRaw(this.state._codeChanges) });
        }
    }

    onSaveClick() {
        if (!this.tempCode) {
            return;
        }
        const resource = this.getResourceFromId(this.state.currentResourceId);
        this.props.onSave({
            resourceId: resource.id,
            newCode: this.tempCode,
            oldCode: resource.oldArch,
        });
    }

    onResourceChange(resourceId) {
        this.state.currentResourceId = resourceId;
        this.cursorPosition = undefined;
        this.props.onResourceChange(this.getResourceFromId(this.state.currentResourceId));
    }

    async loadResources(resourceId) {
        const resources = await rpc("/web_studio/get_xml_editor_resources", {
            key: resourceId,
        });

        const resourcesOptions = resources.views.map((res) => ({
            label: `${res.name} (${res.xml_id})`,
            value: res.id,
            resource: {
                ...res,
                oldArch: res.arch,
                isMainResource:
                    res.key === resourceId || res.id === resourceId || res.xml_id === resourceId,
            },
        }));

        this.state.resourcesOptions = resourcesOptions;
        if (resourcesOptions.length >= 1) {
            let defaultResource = this.props.getDefaultResource(
                resourcesOptions,
                resources.main_view_key
            );
            if (!defaultResource && (this.props.defaultResourceId || resources.main_view_key)) {
                const defaultId = this.props.defaultResourceId || resources.main_view_key;
                defaultResource = resourcesOptions.find(
                    (opt) =>
                        opt.resource.id === defaultId ||
                        opt.resource.xml_id === defaultId ||
                        opt.resource.key === defaultId
                );
            }
            defaultResource = defaultResource || resourcesOptions[0];
            this.state.currentResourceId = defaultResource.value;
        }

        return resourcesOptions;
    }
}

return __exports;
});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/views/kanban_report/new_report_dialog.js  *
*  Lines: 49                                                                  *
******************************************************************************/
odoo.define('@web_studio/views/kanban_report/new_report_dialog', ['@odoo/owl', '@web/core/dialog/dialog', '@web/core/l10n/translation', '@web/core/network/rpc', '@web/core/user'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");
const { _t } = require("@web/core/l10n/translation");
const { rpc } = require("@web/core/network/rpc");
const { user } = require("@web/core/user");

const NewReportDialog = __exports.NewReportDialog = class NewReportDialog extends Component {
    static template = "web_studio.NewReportDialog";
    static components = { Dialog };
    static props = ["resModel", "onReportCreated", "close"];

    setup() {
        this.layouts = [
            {
                name: "web.external_layout",
                label: _t("External"),
                description: _t("Business header/footer"),
            },
            {
                name: "web.internal_layout",
                label: _t("Internal"),
                description: _t("Minimal header/footer"),
            },
            {
                name: "web.basic_layout",
                label: _t("Blank"),
                description: _t("No header/footer"),
            },
        ];
    }

    async createNewReport(layout) {
        const report = await rpc("/web_studio/create_new_report", {
            model_name: this.props.resModel,
            layout,
            context: user.context,
        });
        this.props.onReportCreated(report);
        this.props.close();
    }
}

return __exports;
});
;

/*******************************************************************************
*  Filepath: /web_studio/static/src/views/kanban_report/report_kanban_view.js  *
*  Lines: 47                                                                   *
*******************************************************************************/
odoo.define('@web_studio/views/kanban_report/report_kanban_view', ['@web/core/registry', '@web/core/utils/hooks', '@web/views/kanban/kanban_view', '@web/views/kanban/kanban_controller', '@web_studio/views/kanban_report/new_report_dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { useService } = require("@web/core/utils/hooks");
const { kanbanView } = require("@web/views/kanban/kanban_view");
const { KanbanController } = require("@web/views/kanban/kanban_controller");

const { NewReportDialog } = require("@web_studio/views/kanban_report/new_report_dialog");

class StudioReportKanbanController extends KanbanController {
    setup() {
        super.setup();
        this.actionService = useService("action");
        this.dialogService = useService("dialog");
        this.orm = useService("orm");
    }
    createRecord() {
        this.dialogService.add(NewReportDialog, {
            resModel: this.props.context.default_model,
            onReportCreated: (report) => {
                this.openRecord({ data: report, resId: report.id });
            },
        });
    }

    openRecord(record) {
        return this.actionService.doAction("web_studio.action_edit_report", {
            report: {
                data: record.data,
                res_id: record.resId,
            },
        });
    }
}

const studioReportKanbanView = {
    ...kanbanView,
    Controller: StudioReportKanbanController,
};

registry.category("views").add("studio_report_kanban", studioReportKanbanView);

return __exports;
});
;

/********************************************************
*  Filepath: /website_studio/static/src/editor_tabs.js  *
*  Lines: 45                                            *
********************************************************/
odoo.define('@website_studio/editor_tabs', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { markup } = require("@odoo/owl");
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");

const MODEL_PAGE_HELP = _t(markup(`
    <p class="o_view_nocontent_empty_folder">
        Create a new model page
    </p>
    <p>
        Publish everything on your websites
        then customize the pages
        using the power of the Website app
    </p>
`));

registry.category("web_studio.editor_tabs").add("website", {
    name: _t("Model Pages"),
    action: (env) => {
        const { editedAction } = env.services.studio;
        const context = {
            default_model: editedAction.res_model,
            search_default_model: editedAction.res_model,
            default_page_type: "listing",
            default_website_published: true,
            default_use_menu: true,
            default_auto_single_page: true,
            form_view_ref: "website_studio.website_controller_page_form_dialog",
            "website_studio.create_page": true,
        }
        return {
            type: "ir.actions.act_window",
            res_model: "website.controller.page",
            name: _t("Model Pages"),
            views: [[false, "kanban"], [false, "list"], [false, "form"]],
            context,
            help: MODEL_PAGE_HELP,
        }
    },
});

return __exports;
});


                    /*******************************************
                    *  Templates                               *
                    *******************************************/

                    odoo.define("web_studio.studio_assets.bundle.xml", ["@web/core/templates"], function(require) {
                        "use strict";
                        const { checkPrimaryTemplateParents, registerTemplate, registerTemplateExtension } = require("@web/core/templates");
                        /* web_studio.studio_assets */
                        registerTemplate("web.GraphView.Buttons", `/web/static/src/views/graph/graph_controller.xml`, `<t t-name="web.GraphView.Buttons" xml:space="preserve">
        <div class="btn-group" role="toolbar" aria-label="Main actions">
            <ReportViewMeasures measures="model.metaData.measures" activeMeasures="[model.metaData.measure]" onMeasureSelected.bind="this.onMeasureSelected"/>
        </div>
        <div class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-bar-chart o_graph_button" data-tooltip="Bar Chart" aria-label="Bar Chart" data-mode="bar" t-on-click="() =&gt; this.onModeSelected('bar')" t-att-class="{ active: model.metaData.mode === 'bar' }"/>
            <button class="btn btn-secondary fa fa-line-chart o_graph_button" data-tooltip="Line Chart" aria-label="Line Chart" data-mode="line" t-on-click="() =&gt; this.onModeSelected('line')" t-att-class="{ active: model.metaData.mode === 'line' }"/>
            <button class="btn btn-secondary fa fa-pie-chart o_graph_button" data-tooltip="Pie Chart" aria-label="Pie Chart" data-mode="pie" t-on-click="() =&gt; this.onModeSelected('pie')" t-att-class="{ active: model.metaData.mode === 'pie' }"/>
        </div>
        <div t-if="model.metaData.mode === 'bar'" class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-database o_graph_button" data-tooltip="Stacked" aria-label="Stacked" t-on-click="toggleStacked" t-att-class="{ active: model.metaData.stacked }"/>
        </div>
        <div t-if="model.metaData.mode === 'line'" class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-database o_graph_button" data-tooltip="Stacked" aria-label="Stacked" t-on-click="toggleStacked" t-att-class="{ active: model.metaData.stacked }"/>
            <button class="btn btn-secondary fa fa-signal o_graph_button" data-tooltip="Cumulative" aria-label="Cumulative" t-on-click="toggleCumulated" t-att-class="{ active: model.metaData.cumulated }"/>
        </div>
        <div t-if="model.metaData.mode !== 'pie' and model.metaData.domains.length === 1" class="btn-group" role="toolbar" aria-label="Sort graph" name="toggleOrderToolbar">
            <button class="btn btn-secondary fa fa-sort-amount-desc o_graph_button" data-tooltip="Descending" aria-label="Descending" t-on-click="() =&gt; this.toggleOrder('DESC')" t-att-class="{ active: model.metaData.order === 'DESC' }"/>
            <button class="btn btn-secondary fa fa-sort-amount-asc o_graph_button" data-tooltip="Ascending" aria-label="Ascending" t-on-click="() =&gt; this.toggleOrder('ASC')" t-att-class="{ active: model.metaData.order === 'ASC' }"/>
        </div>
    </t>

    `);
registerTemplate("web.GraphView", `/web/static/src/views/graph/graph_controller.xml`, `<t t-name="web.GraphView" xml:space="preserve">
        <div t-att-class="props.className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-if="model.data">
                    <t t-if="!model.hasData() or model.useSampleModel and props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-if="model.data.exceeds">
                        <div class="alert alert-info text-center o_graph_alert" role="status">
                            There are too many data. The graph only shows a sample. Use the filters to refine the scope.
                            <a class="o_graph_load_all_btn" href="#" t-on-click="() =&gt; this.loadAll()">
                                Load everything anyway.
                            </a>
                        </div>
                    </t>
                    <t t-component="props.Renderer" model="model" buttonTemplate="props.buttonTemplate"/>
                </t>
                <t t-else="" t-call="web.NoContentHelper">
                    <t t-set="title">Invalid data</t>
                    <t t-set="description">Pie chart cannot mix positive and negative numbers. Try to change your domain to only display positive results</t>
                </t>
            </Layout>
        </div>
    </t>

`);
registerTemplate("web.GraphRenderer.CustomTooltip", `/web/static/src/views/graph/graph_renderer.xml`, `<t t-name="web.GraphRenderer.CustomTooltip" xml:space="preserve">
        <div class="o_graph_custom_tooltip popover show px-2 py-1 pe-none mw-100 position-absolute">
            <table class="overflow-hidden m-0">
                <thead>
                    <tr>
                        <th class="o_measure align-baseline border-0" t-esc="measure"/>
                    </tr>
                </thead>
                <tbody>
                    <tr t-foreach="tooltipItems" t-as="tooltipItem" t-key="tooltipItem_index">
                        <td>
                            <span class="o_square badge p-2 rounded-0 align-middle me-2" t-attf-style="background-color: {{ tooltipItem.boxColor }}"> </span>
                            <small class="o_label d-inline-block text-truncate align-middle smaller" t-attf-style="max-width: {{ maxWidth }}" t-esc="tooltipItem.label"/>
                        </td>
                        <td class="o_value ps-2 text-end fw-bolder">
                            <small class="smaller">
                                <t t-esc="tooltipItem.value"/>
                                <t t-if="mode === 'pie' and tooltipItem.percentage">
                                    (<t t-esc="tooltipItem.percentage"/>%)
                                </t>
                            </small>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </t>

    `);
registerTemplate("web.GraphRenderer", `/web/static/src/views/graph/graph_renderer.xml`, `<t t-name="web.GraphRenderer" xml:space="preserve">
        <div t-att-class="'o_graph_renderer o_renderer h-100 d-flex flex-column border-top ' + props.class" t-ref="root">
            <div class="d-flex d-print-none gap-1 flex-shrink-0 mt-2 mx-3 mb-3 overflow-x-auto">
                <t t-call="{{ props.buttonTemplate }}"/>
            </div>
            <div t-if="model.hasData()" class="o_graph_canvas_container flex-grow-1 position-relative px-3 pb-3" t-ref="container">
                <canvas t-ref="canvas"/>
            </div>
        </div>
    </t>

`);
registerTemplate("web.PivotView.Buttons", `/web/static/src/views/pivot/pivot_controller.xml`, `<t t-name="web.PivotView.Buttons" xml:space="preserve">
        <div class="o_pivot_buttons d-flex d-print-none gap-1 mt-2 mx-3 mb-3">
            <div class="btn-group" role="toolbar" aria-label="Main actions">
                <ReportViewMeasures measures="model.metaData.measures" activeMeasures="model.metaData.activeMeasures" onMeasureSelected.bind="this.onMeasureSelected"/>
            </div>
            <div class="btn-group" role="toolbar" aria-label="Pivot settings">
                <t t-set="noDataDisplayed" t-value="!model.hasData() || !model.metaData.activeMeasures.length"/>
                <button class="btn btn-secondary fa fa-exchange o_pivot_flip_button" t-on-click="onFlipButtonClicked" data-tooltip="Flip axis" aria-label="Flip axis" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
                <button class="btn btn-secondary fa fa-arrows o_pivot_expand_button" t-on-click="onExpandButtonClicked" data-tooltip="Expand all" aria-label="Expand all" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
                <button class="btn btn-secondary fa fa-download o_pivot_download" t-on-click="onDownloadButtonClicked" data-tooltip="Download xlsx" aria-label="Download xlsx" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
            </div>
        </div>
    </t>

    `);
registerTemplate("web.PivotView", `/web/static/src/views/pivot/pivot_controller.xml`, `<t t-name="web.PivotView" xml:space="preserve">
        <div t-att-class="props.className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-set="displayNoContent" t-value="                     props.info.noContentHelp !== false and (                         !(model.hasData() and model.metaData.activeMeasures.length) or                         model.useSampleModel                     )"/>
                <t t-if="displayNoContent">
                    <t t-if="props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-else="" t-call="web.NoContentHelper"/>
                </t>
                <t t-component="props.Renderer" model="model" buttonTemplate="props.buttonTemplate"/>
            </Layout>
        </div>
    </t>

`);
registerTemplate("web.PivotHeader", `/web/static/src/views/pivot/pivot_header.xml`, `<t t-name="web.PivotHeader" xml:space="preserve">
        <Dropdown state="this.dropdownState" manual="true" position="props.isXAxis ? 'bottom-start' : 'bottom-end'">
            <th class="bg-view text-nowrap cursor-pointer fw-normal user-select-none" t-att-colspan="props.isXAxis ? cell.width : undefined" t-att-rowspan="props.isXAxis ? cell.height : undefined" t-att-class="{                     o_pivot_header_cell_closed: cell.isLeaf,                     o_pivot_header_cell_opened: !cell.isLeaf,                     'border-top': props.isInHead,                 }" t-attf-style="{{                     props.isXAxis                         ? undefined                         : l10n.direction === 'ltr'                             ? 'padding-left: ' + padding + 'px;'                             : 'padding-right: ' + padding + 'px;'                 }}" t-att-data-tooltip="cell.label" t-attf-data-tooltip-position="{{ l10n.direction === 'ltr' ? 'right' : 'left' }}" t-on-click.stop="this.onClick">
                <i t-attf-class="fa fa-{{ cell.isLeaf ? 'plus-square' : 'minus-square-o' }} me-1"/>
                <span t-esc="cell.title"/>
            </th>

            <t t-set-slot="content">
                <t t-set="currentGroup" t-value="null"/>
                <t t-foreach="items" t-as="item" t-key="item.id">
                    <t t-if="currentGroup !== null and currentGroup !== item.groupNumber">
                        <div class="dropdown-divider" role="separator"/>
                    </t>
                    <t t-if="item.fieldType === 'properties'">
                        <PropertiesGroupByItem item="item" onGroup.bind="onGroupBySelected"/>
                    </t>
                    <t t-elif="item.options">
                        <Dropdown>
                            <button t-att-class="'o_menu_item' + (item.isActive ? ' selected' : '')">
                                <t t-esc="item.description"/>
                            </button>
                            <t t-set-slot="content">
                                <t t-set="subGroup" t-value="null"/>
                                <t t-foreach="item.options" t-as="option" t-key="option.id">
                                    <t t-if="subGroup !== null and subGroup !== option.groupNumber">
                                        <div class="dropdown-divider" role="separator"/>
                                    </t>
                                    <CheckboxItem class="{ o_item_option: true, selected: option.isActive }" checked="option.isActive ? true : false" t-esc="option.description" onSelected="() =&gt; this.onGroupBySelected({ itemId: item.id, optionId: option.id})"/>
                                    <t t-set="subGroup" t-value="option.groupNumber"/>
                                </t>
                            </t>
                        </Dropdown>
                    </t>
                    <t t-else="">
                        <CheckboxItem class="{ o_menu_item: true, selected: item.isActive }" checked="item.isActive" t-esc="item.description" onSelected="() =&gt; this.onGroupBySelected({ itemId: item.id })"/>
                    </t>
                    <t t-set="currentGroup" t-value="item.groupNumber"/>
                </t>
                <t t-if="!hideCustomGroupBy and fields.length">
                    <div t-if="items.length" role="separator" class="dropdown-divider"/>
                    <CustomGroupByItem fields="fields" onAddCustomGroup.bind="onAddCustomGroup"/>
                </t>
            </t>
        </Dropdown>
    </t>

`);
registerTemplate("web.PivotRenderer", `/web/static/src/views/pivot/pivot_renderer.xml`, `<t t-name="web.PivotRenderer" xml:space="preserve">
        <t t-call="{{ props.buttonTemplate }}"/>
        <div t-if="model.hasData() and model.metaData.activeMeasures.length" t-att-class="env.isSmall ? 'table-responsive' : ''" class="o_pivot mx-3">
            <table class="table-hover table table-sm table-bordered table-borderless" t-att-class="{ o_enable_linking: !model.metaData.disableLinking }" t-ref="table">
                <thead>
                    <tr t-foreach="table.headers" t-as="row" t-key="'header_' + row_index" class="border-top-0">
                        <t t-foreach="row" t-as="cell" t-key="'header_row_' + cell_index">
                            <t t-if="cell.measure" t-call="web.PivotMeasure"/>
                            <PivotHeader t-elif="cell.isLeaf !== undefined" t-props="this.getHeaderProps({ cell: cell, isXAxis: true, isInHead: true })"/>
                            <th t-else="" t-att-colspan="cell.width" t-att-rowspan="cell.height" class="border-0 bg-100 fw-normal" t-att-class="{ 'border-0': cell_index != 0 }"/>
                        </t>
                    </tr>
                </thead>
                <tbody>
                    <tr t-foreach="table.rows" t-as="row" t-key="'row_' + row_index">
                        <PivotHeader t-props="this.getHeaderProps({ cell: row, isXAxis: false, isInHead: false })"/>
                        <t t-foreach="row.subGroupMeasurements" t-as="cell" t-key="'row_cell_' + cell_index">
                            <td class="o_pivot_cell_value bg-100" t-att-class="{                                     o_empty: cell.value === undefined,                                     'cursor-pointer': cell.value !== undefined,                                     'fw-bold': cell.isBold,                                 }" t-on-click="() =&gt; this.onOpenView(cell)" t-on-mouseover="onMouseEnter" t-on-mouseout="onMouseLeave">
                                <t t-if="cell.value !== undefined">
                                    <div t-if="cell.originIndexes.length &gt; 1" class="o_variation" t-att-class="{                                              'o_positive text-success': cell.value &gt; 0,                                              'o_negative text-danger': cell.value &lt; 0,                                              o_null: cell.value === 0,                                         }" t-esc="getFormattedVariation(cell)"/>
                                    <div t-elif="model.metaData.measures[cell.measure].type === 'boolean'" class="o_value">
                                        <CheckBox disabled="true" value="cell.value"/>
                                    </div>
                                    <div t-else="1" class="o_value" t-esc="getFormattedValue(cell)"/>
                                </t>
                            </td>
                        </t>
                    </tr>
                </tbody>
            </table>
        </div>
    </t>

    `);
registerTemplate("web.PivotMeasure", `/web/static/src/views/pivot/pivot_renderer.xml`, `<t t-name="web.PivotMeasure" xml:space="preserve">
        <th class="bg-view text-muted text-center text-nowrap fw-normal" t-att-colspan="cell.width" t-att-rowspan="cell.height" t-att-class="{                 'o_pivot_origin_row cursor-pointer user-select-none': cell.originIndexes,                 'o_pivot_measure_row cursor-pointer user-select-none': !cell.originIndexes,                 o_pivot_sort_order_asc: cell.order === 'asc',                 o_pivot_sort_order_desc: cell.order === 'desc',             }" t-on-click.prevent="() =&gt; this.onMeasureClick(cell)" t-on-mouseover="onMouseEnter" t-on-mouseout="onMouseLeave">
            <t t-esc="cell.title"/>
            <i t-if="cell.order === 'asc' || cell.order ==='desc'" t-attf-class="fa fa-caret-{{ cell.order === 'asc' ? 'up' : 'down' }} ms-1"/>
        </th>
    </t>

`);
registerTemplate("mail.ActivityCell", `/mail/static/src/views/web/activity/activity_cell.xml`, `<t t-name="mail.ActivityCell" xml:space="preserve">
        <div class="h-100 cursor-pointer p-1 d-flex flex-column justify-content-between" t-on-click="onClick">
            <div class="d-flex align-items-center justify-content-center position-relative" t-ref="content">
                <div class="o-mail-ActivityCell-deadline" t-out="reportingDateFormatted"/>
            </div>
            <div class="d-flex justify-content-between">
                <div t-if="props.userAssignedIds" class="d-flex justify-content-start">
                    <Avatar t-if="props.userAssignedIds.length &gt; 0" resModel="'res.users'" resId="props.userAssignedIds[0]" displayName="''" noSpacing="true"/>
                    <Avatar t-if="props.userAssignedIds.length &gt; 1" resModel="'res.users'" resId="props.userAssignedIds[1]" displayName="''" noSpacing="true"/>
                    <t t-set="nAdditionalAssignee" t-value="props.userAssignedIds.length - 2"/>
                    <span t-if="nAdditionalAssignee &gt; 0">+<t t-out="nAdditionalAssignee"/></span>
                </div>
                <div t-else=""/>
                <div t-if="props.attachmentsInfo and ongoingActivityCount == 0" class="d-flex w-100 justify-content-center gap-1 px-2">
                    <a t-attf-href="/web/content/#{props.attachmentsInfo.most_recent_id}?download=true" t-on-click.stop="" t-out="props.attachmentsInfo.most_recent_name" class="d-inline-block text-truncate" style="max-width: 120px;"/>
                    <div t-if="props.attachmentsInfo.count &gt; 1" class="text-nowrap">
                        +<t t-out="props.attachmentsInfo.count - 1"/>
                    </div>
                </div>
                <div t-if="totalActivityCount &gt; 1" class="o-mail-ActivityCell-counter badge bg-light rounded-pill border-0 m-1">
                    <t t-if="totalActivityCount == ongoingActivityCount or ongoingActivityCount == 0" t-out="totalActivityCount"/>
                    <t t-else="">
                        <t t-out="ongoingActivityCount"/> / <t t-out="totalActivityCount"/>
                    </t>
                </div>
                <div t-else=""/>
            </div>
        </div>
    </t>

`);
registerTemplate("mail.ActivityController", `/mail/static/src/views/web/activity/activity_controller.xml`, `<t t-name="mail.ActivityController" xml:space="preserve">
        <div t-att-class="props.className + (ui.isSmall ? ' o_action_delegate_scroll': '')">
            <Layout display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar/>
                </t>
                <t t-component="props.Renderer" t-props="rendererProps"/>
            </Layout>
        </div>
    </t>
`);
registerTemplate("mail.ActivityRecord", `/mail/static/src/views/web/activity/activity_record.xml`, `<t t-name="mail.ActivityRecord" xml:space="preserve">
    <td class="o_activity_record p-2 cursor-pointer" t-on-click="() =&gt; this.props.openRecord(this.props.record)">
        <t t-call="{{ recordTemplate }}" t-call-context="this.getRenderingContext()"/>
    </td>
</t>

`);
registerTemplate("mail.ActivityViewHeader", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewHeader" xml:space="preserve">
    <thead>
        <tr>
            <th/>
            <th t-foreach="activeColumns" t-as="type" t-key="type.id" class="o_activity_type_cell p-3" t-attf-class="{{ activeFilter.activityTypeId === type.id ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}" t-attf-width="{{100/activeColumns.length}}%">
                <div>
                    <span t-esc="type.name"/>
                    <span t-if="type.template_ids.length &gt; 0" class="dropdown float-end">
                        <i class="fa fa-ellipsis-v fa-fw" data-bs-toggle="dropdown"/>
                        <div class="dropdown-menu">
                            <t t-foreach="type.template_ids" t-as="template" t-key="template.id">
                                <div data-tooltip="This action will send an email." class="o_template_element o_send_mail_template cursor-pointer" t-on-click="() =&gt; props.onSendMailTemplate(template.id, type.id)">
                                    <i class="fa fa-envelope fa-fw"/> <t t-esc="template.name"/>
                                </div>
                            </t>
                        </div>
                    </span>
                </div>
                <div class="o_activity_counter d-flex align-items-center justify-content-between mb-3 h-0 mt24">
                    <t t-set="group" t-value="getGroupInfo(type)"/>
                    <ColumnProgress t-if="group.data.count" group="group.data" aggregate="group.aggregate" aggregateOn="group.aggregateOn" progressBar="group.data.progressBar" onBarClicked.bind="group.data.filterProgressValue"/>
                </div>
            </th>
            <th class="align-middle" style="width: 32px; min-width: 32px">
                <div class="o_optional_columns_dropdown text-center border-top-0">
                    <Dropdown position="'bottom-end'">
                        <button class="btn p-0" tabindex="-1">
                            <i class="o_optional_columns_dropdown_toggle oi oi-fw oi-settings-adjust"/>
                        </button>

                        <t t-set-slot="content">
                            <t t-foreach="props.activityTypes" t-as="type" t-key="type_index">
                                <DropdownItem closingMode="'none'" onSelected="() =&gt; this.toggleDisplayColumn(type.id)">
                                    <CheckBox onChange="() =&gt; this.toggleDisplayColumn(type.id)" value="storageActiveColumns[type.id]" name="type.name">
                                        <t t-esc="type.name"/>
                                    </CheckBox>
                                </DropdownItem>
                            </t>
                        </t>
                    </Dropdown>
                </div>
            </th>
        </tr>
    </thead>
</t>

`);
registerTemplate("mail.ActivityViewBody", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewBody" xml:space="preserve">
    <tbody>
        <t t-foreach="props.activityResIds" t-as="resId" t-key="resId">
            <t t-call="mail.ActivityViewRow"/>
        </t>
    </tbody>
</t>

`);
registerTemplate("mail.ActivityViewRow", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewRow" xml:space="preserve">
    <t t-set="record" t-value="getRecord(resId)"/>
    <t t-if="record">
        <tr class="o_data_row h-100" t-attf-class="{{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}">
                <ActivityRecord archInfo="props.archInfo" record="record" openRecord="props.openRecord"/>
                <t t-foreach="activeColumns" t-as="type" t-key="type.id">
                    <t t-call="mail.ActivityViewCell"/>
                </t>
            <td/>
        </tr>
    </t>
</t>

`);
registerTemplate("mail.ActivityViewCell", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewCell" xml:space="preserve">
    <t t-set="activityGroup" t-value="props.groupedActivities[resId] and props.groupedActivities[resId][type.id] or {count: 0, ids: [], state: false}"/>
    <t t-set="isCellHidden" t-value="!activeFilter.resIds.has(resId) and activeFilter.activityTypeId === type.id"/>
    <td t-if="activityGroup.state and !isCellHidden" t-attf-class="o_activity_summary_cell p-0 h-100 {{activityGroup.state}} {{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}">
        <ActivityCell activityIds="activityGroup.ids" activityTypeId="type.id" attachmentsInfo="activityGroup.attachments_info" reportingDate="activityGroup.reporting_date" countByState="activityGroup.count_by_state" reloadFunc="props.onReloadData" resId="record.resId" resModel="record.resModel" userAssignedIds="activityGroup.user_assigned_ids"/>
    </td>
    <td t-else="" class="o_activity_summary_cell o_activity_empty_cell cursor-pointer" t-attf-class="{{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}" t-on-click.prevent.stop="() =&gt; props.onEmptyCell(resId, type.id)">
        <i data-tooltip="Create" class="text-center fa fa-plus mt-2 align-items-center justify-content-center h-100"/>
    </td>
</t>

`);
registerTemplate("mail.ActivityViewFooter", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewFooter" xml:space="preserve">
    <tfoot>
        <tr class="o_data_row">
            <td class="p-3" colspan="3">
                <span class="btn btn-link o_record_selector cursor-pointer" t-on-click.prevent.stop="props.scheduleActivity">
                    <i class="fa fa-plus pe-2"/> Schedule activity
                </span>
            </td>
        </tr>
    </tfoot>
</t>

`);
registerTemplate("mail.ActivityRenderer", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<div t-name="mail.ActivityRenderer" class="o_activity_view h-100" xml:space="preserve">
    <t t-if="!props.activityTypes.length" t-call="web.NoContentHelper"/>
    <table t-else="" class="table table-bordered mb-5 bg-view o_activity_view_table">
        <t t-call="mail.ActivityViewHeader"/>
        <t t-call="mail.ActivityViewBody"/>
        <t t-call="mail.ActivityViewFooter"/>
    </table>
</div>

`);
registerTemplateExtension("web.PivotRenderer", `/web_enterprise/static/src/views/pivot/pivot_renderer.xml`, `<t t-inherit="web.PivotRenderer" t-inherit-mode="extension" xml:space="preserve">
        <xpath expr="//div[hasclass('o_pivot')]" position="attributes">
            <attribute name="t-ref">root</attribute>
        </xpath>
    </t>

`);
registerTemplate("project.BurndownChartView.Buttons", `/project/static/src/views/burndown_chart/burndown_chart_view.xml`, `<t t-name="project.BurndownChartView.Buttons" t-inherit="web.GraphView.Buttons" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//button[@data-mode='pie']" position="replace">
        </xpath>
        <xpath expr="//div[@role='toolbar'][@name='toggleOrderToolbar']" position="replace">
        </xpath>
    </t>

`);
registerTemplate("web_map.MapView", `/web_map/static/src/map_view/map_controller.xml`, `<t t-name="web_map.MapView" xml:space="preserve">
        <div t-att-class="props.className">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-buttons">
                    <t t-call="{{ props.buttonTemplate }}"/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-component="props.Renderer" t-props="rendererProps"/>
            </Layout>
        </div>
    </t>

    `);
registerTemplate("web_map.MapView.Buttons", `/web_map/static/src/map_view/map_controller.xml`, `<t t-name="web_map.MapView.Buttons" xml:space="preserve">

    </t>

`);
registerTemplate("web_map.MapRenderer", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer" xml:space="preserve">
        <t t-if="env.isSmall">
            <div class="row g-0 o-sm-pin-list-container" t-att-class="{ 'h-100': expendedPinList }">
                <t t-call="web_map.MapRenderer.PinListContainer"/>
            </div>
        </t>
        <div class="o-map-renderer row g-0" t-att-class="{ 'd-none': expendedPinList }">
            <t t-if="!env.isSmall">
                <t t-call="web_map.MapRenderer.PinListContainer"/>
            </t>
            <div class="h-100 col col-md-10">
                <t t-if="props.model.data.routingError">
                    <t t-call="web_map.MapRenderer.RountingUnavailable"/>
                </t>
                <t t-elif="props.model.data.fetchingCoordinates">
                    <t t-call="web_map.MapRenderer.FetchingCoordinates"/>
                </t>
                <t t-elif="props.model.metaData.routing and !props.model.data.useMapBoxAPI">
                    <t t-call="web_map.MapRenderer.NoMapToken"/>
                </t>
                <div class="o-map-renderer--container h-100" t-ref="mapContainer"/>
            </div>
        </div>
    </t>

    `);
registerTemplate("web_map.MapRenderer.FetchingCoordinates", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.FetchingCoordinates" xml:space="preserve">
        <div class="alert alert-info col col-md-10 px-5 mb-0 text-center position-absolute o-map-renderer--alert" role="status">
            <i class="fa fa-spin fa-circle-o-notch"/> Locating new addresses...
        </div>
    </t>

    `);
registerTemplate("web_map.MapRenderer.NoMapToken", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.NoMapToken" xml:space="preserve">

        <div class="alert alert-info alert-dismissible col col-md-10 px-5 mb-0 text-center position-absolute o-map-renderer--alert" role="status">
            To get routing on your map, you first need to set up your MapBox token. It's free.
            <a href="/odoo/action-base_setup.action_general_configuration" class="ml8">
                <i class="oi oi-arrow-right"/>
                Set up token
            </a>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"/>
        </div>
    </t>

    `);
registerTemplate("web_map.MapRenderer.PinListContainer", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.PinListContainer" xml:space="preserve">
        <div class="o-map-renderer--pin-list-container col-12 col-md-2 bg-view border-start cursor-default h-100">
            <div class="o-map-view--buttons">
                <a class="btn btn-primary" t-att-href="googleMapUrl" target="_blank" data-hotkey="m">View in Google Maps</a>
            </div>
            <t t-if="!props.model.metaData.hideTitle">
                <header class="o-map-renderer--pin-list-header o_pin_list_header text-uppercase px-0 py-md-2 d-flex align-items-baseline" t-on-click="togglePinList">
                    <i class="fa fa-list me-2 text-primary"/>
                    <span class="fs-6 fw-bold text-truncate" t-out="props.model.metaData.panelTitle"/>
                    <i t-if="env.isSmall" class="fa float-end ms-auto" t-att-class="{                         'fa-caret-down': expendedPinList,                         'fa-caret-left': !expendedPinList                     }"/>
                </header>
            </t>
            <t t-if="canDisplayPinList and props.model.data.isGrouped">
                <t t-foreach="props.model.data.recordGroups" t-as="groupId" t-key="groupId">
                    <div class="o-map-renderer--pin-list-group mb-1">
                        <t t-set="group" t-value="props.model.data.recordGroups[groupId]"/>
                        <div class="o-map-renderer--pin-list-group-header d-flex align-items-baseline" t-on-click="() =&gt; this.toggleGroup(groupId)">
                            <i t-attf-class="fa fa-caret-{{ state.closedGroupIds.includes(groupId) ? 'right' : 'down' }}"/>
                            <span class="ms-1" t-att-style="'color:' + getGroupColor(groupId)">
                                <t t-call="web_map.pinSVG">
                                    <t t-set="numbering" t-value="props.model.metaData.numbering"/>
                                </t>
                            </span>
                            <t t-if="group.name" t-esc="group.name"/>
                            <t t-else="">Undefined</t>
                        </div>
                        <t t-if="!state.closedGroupIds.includes(groupId)">
                            <t t-call="web_map.MapRenderer.PinList">
                                <t t-set="records" t-value="group.records"/>
                            </t>
                        </t>
                    </div>
                </t>
            </t>
            <t t-elif="canDisplayPinList">
                <t t-call="web_map.MapRenderer.PinList">
                    <t t-set="records" t-value="props.model.data.records"/>
                </t>
            </t>
        </div>
    </t>

    `);
registerTemplate("web_map.MapRenderer.PinList", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.PinList" xml:space="preserve">
        <t t-tag="props.model.metaData.numbering ? 'ol' : 'ul'" t-att-class="{'o-map-renderer--pin-located': !props.model.metaData.numbering}" class="o-map-renderer--pin-list-details ps-0 pb-0 o-map-renderer--handle" t-ref="pinList">
            <t t-call="web_map.MapRenderer.PinListItems"/>
        </t>
    </t>

    `);
registerTemplate("web_map.MapRenderer.PinListItems", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.PinListItems" xml:space="preserve">
        <t t-foreach="records" t-as="record" t-key="record.id">
            <t t-set="latitude" t-value="record.partner and record.partner.partner_latitude"/>
            <t t-set="longitude" t-value="record.partner and record.partner.partner_longitude"/>
            <li t-att-data-id="record.id" t-if="latitude and longitude" t-on-click.prevent="() =&gt; this.centerAndOpenPin(record)" class="cursor-pointer d-flex align-items-center justify-content-between o-map-renderer--pin-located py-1">
                <span class="text-truncate"> <t t-if="props.model.metaData.numbering" t-esc="record_index + 1 + '.'"/> <t t-esc="record.display_name"/> </span>
                <span class="o_row_handle oi oi-draggable" t-if="this.props.model.canResequence" t-on-click.stop=""/>
            </li>
        </t>
    </t>

    `);
registerTemplate("web_map.MapRenderer.RountingUnavailable", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.MapRenderer.RountingUnavailable" xml:space="preserve">
        <div class="alert alert-warning alert-dismissible col col-md-10 px-5 mb-0 text-center position-absolute o-map-renderer--alert" role="status">
            <strong>Unsuccessful routing request: </strong>
            <t t-esc="props.model.data.routingError"/>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"/>
        </div>
    </t>

    `);
registerTemplate("web_map.marker", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.marker" xml:space="preserve">
        <div t-att-style="color and ('color:' + color)">
            <t t-call="web_map.pinSVG"/>
            <t t-if="numbering" t-call="web_map.markerNumber"/>
            <t t-elif="isMulti" t-call="web_map.markerBadge"/>
        </div>
    </t>

    `);
registerTemplate("web_map.markerBadge", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.markerBadge" xml:space="preserve">
        <div class="badge text-bg-danger rounded-pill o-map-renderer--marker-badge d-flex justify-content-center" t-att-style="color and \`background-color: \${color} !important\`">
            <t t-esc="count"/>
        </div>
    </t>

    `);
registerTemplate("web_map.markerNumber", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.markerNumber" xml:space="preserve">
        <p class="o-map-renderer--marker-number position-relative text-center">
            <t t-esc="number"/>
            <t t-if="count gt 1">
                <t t-call="web_map.markerBadge"/>
            </t>
        </p>
    </t>

    `);
registerTemplate("web_map.markerPopup", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.markerPopup" xml:space="preserve">
        <div>
            <table class="o-map-renderer--popup-table align-top">
                <thead>
                    <tr>
                        <th colspan="2"/>
                        <th/>
                        <th/>
                    </tr>
                </thead>
                <tbody>
                    <tr t-foreach="fields" t-as="field" t-key="field.id">
                        <td class="o-map-renderer--popup-table-content-name fw-bold text-nowrap align-baseline">
                            <t t-esc="field.string"/>
                        </td>
                        <td class="o-map-renderer--popup-table-space"/>
                        <td class="o-map-renderer--popup-table-content-value align-baseline">
                            <t t-esc="field.value"/>
                        </td>
                    </tr>
                </tbody>
            </table>
            <div class="o-map-renderer--popup-buttons d-flex align-item-end justify-content-start mt8">
                <t t-if="hasFormView">
                    <button class="btn btn-primary o-map-renderer--popup-buttons-open">
                        Open
                    </button>
                </t>
                <div class="o-map-renderer--popup-buttons-divider d-inline-block h-auto"/>
                <a class="btn btn-primary" role="button" t-att-href="url" target="_blank">
                    Navigate to
                </a>
            </div>
        </div>
    </t>

    `);
registerTemplate("web_map.pinSVG", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.pinSVG" xml:space="preserve">
        <t t-if="numbering">
            <t t-call="web_map.pinNoCircleSVG"/>
        </t>
        <t t-else="">
            <t t-call="web_map.pinCircleSVG"/>
        </t>
    </t>

    `);
registerTemplate("web_map.pinCircleSVG", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.pinCircleSVG" xml:space="preserve">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 60 78.6" style="enable-background:new 0 0 60 78.6;" xml:space="preserve">
            <style type="text/css">
                .st0{opacity:0.3;enable-background:new;}
                .st1{fill:currentColor;stroke:#1A1919;stroke-width:3;stroke-miterlimit:10;}
            </style>
            <g>
                <g id="Layer_2_1_">
                    <g id="Layer_1-2">
                        <path class="st0" d="M32.5,4C17.3,4,5,16.3,5,31.5c0,18.2,23.4,44.6,24.4,45.7c1.5,1.7,4.1,1.8,5.8,0.3c0.1-0.1,0.2-0.2,0.3-0.3                             c1-1.1,24.4-27.4,24.4-45.7C60,16.3,47.7,4,32.5,4z M32.5,42.4c-6.3,0-11.4-5.1-11.4-11.5s5.1-11.5,11.5-11.5S44,24.6,44,31v0                             C43.9,37.3,38.8,42.4,32.5,42.4z"/>
                        <path class="st1" d="M28.8,1.8c-14.9,0-27,12.1-27.1,27.1c0,18.5,24.2,45.7,25.3,46.9c0.9,1,2.4,1.1,3.4,0.2                             c0.1-0.1,0.1-0.1,0.2-0.2c1-1.1,25.3-28.3,25.3-46.9C55.9,13.9,43.7,1.8,28.8,1.8z M28.8,40.3c-6.3,0-11.5-5.1-11.5-11.4                             s5.1-11.5,11.4-11.5s11.5,5.1,11.5,11.4v0C40.2,35.2,35.1,40.3,28.8,40.3z"/>
                    </g>
                </g>
            </g>
        </svg>
    </t>

    `);
registerTemplate("web_map.pinNoCircleSVG", `/web_map/static/src/map_view/map_renderer.xml`, `<t t-name="web_map.pinNoCircleSVG" xml:space="preserve">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 61 78.9" style="enable-background:new 0 0 61 78.9;" xml:space="preserve">
            <style type="text/css">
                .st0{opacity:0.3;enable-background:new;}
                .st1{fill:currentColor;stroke:#1A1919;stroke-width:3;stroke-miterlimit:10;}
            </style>
            <g>
                <g id="Layer_2_1_">
                    <g id="Layer_1-2">
                        <path class="st0" d="M33.5,4C18.3,4,6,16.3,6,31.5c0,18.2,23.4,44.6,24.4,45.7c1.5,1.7,4.1,1.8,5.8,0.3c0.1-0.1,0.2-0.2,0.3-0.3                             c1-1.1,24.4-27.4,24.4-45.7C61,16.3,48.7,4,33.5,4z"/>
                        <path class="st1" d="M28.7,1.7c-14.9,0-27,12.1-27.1,27.1c0,18.5,24.2,45.7,25.3,46.9c0.9,1,2.4,1.1,3.4,0.2                             c0.1-0.1,0.1-0.1,0.2-0.2c1-1.1,25.3-28.3,25.3-46.9C55.8,13.8,43.6,1.7,28.7,1.7z"/>
                    </g>
                </g>
            </g>
        </svg>
    </t>

`);
registerTemplate("web_gantt.GanttConnector", `/web_gantt/static/src/gantt_connector.xml`, `<t t-name="web_gantt.GanttConnector" xml:space="preserve">
        <t t-set="xmlAttributes" t-value="{ version: '1.1', xmlns: 'http://www.w3.org/2000/svg' }"/>
        <svg t-if="sourcePoint and targetPoint" t-ref="root" t-att-data-connector-id="id" class="o_gantt_connector position-absolute start-0 top-0 w-100 h-100" t-att-class="{ o_connector_highlighted: highlighted }" pointer-events="none" t-att="xmlAttributes">
            <t t-set="strokeColor" t-value="style.stroke.color"/>
            <t t-set="outlineStrokeColor" t-value="style.outlineStroke.color"/>

            <defs>
                <marker t-att-id="id" markerHeight="6" markerWidth="6" markerUnits="strokeWidth" orient="auto" refX="9" refY="6" stroke-linejoin="round" viewBox="0 0 12 12">
                    <t t-call="web_gantt.ConnectorStrokeHead">
                        <t t-set="color" t-value="strokeColor"/>
                        <t t-set="width" t-value="style.stroke.width"/>
                    </t>
                </marker>
            </defs>

            <t t-call="web_gantt.ConnectorStroke">
                <t t-set="class" t-value="'o_connector_stroke_hover_ease'"/>
                <t t-set="color" t-value="transparent"/>
                <t t-set="width" t-value="style.stroke.width + style.hoverEaseWidth + style.outlineStroke.width"/>
            </t>
            <t t-if="style.outlineStroke.width gt 0">
                <t t-call="web_gantt.ConnectorStroke">
                    <t t-set="class" t-value="'o_connector_stroke_outline'"/>
                    <t t-set="color" t-value="outlineStrokeColor"/>
                    <t t-set="width" t-value="style.stroke.width + style.outlineStroke.width"/>
                </t>
            </t>
            <t t-call="web_gantt.ConnectorStroke">
                <t t-set="class" t-value="'o_connector_stroke'"/>
                <t t-set="color" t-value="strokeColor"/>
                <t t-set="markerEnd" t-value="id"/>
                <t t-set="width" t-value="style.stroke.width"/>
            </t>

            <t t-if="displayButtons">
                <svg class="o_connector_stroke_buttons" width="48" height="16" pointer-events="all" viewBox="0 0 1536 512" t-att="xmlAttributes">
                    <rect fill="transparent" x="0" y="0" width="1536" height="512"/>
                    <g class="o_connector_stroke_button o_connector_stroke_reschedule_button" t-on-click.stop="onLeftButtonClick">
                        <rect fill="white" x="20" y="20" width="472" height="472" rx="236" ry="236"/>
                        <g pointer-events="none">
                            <line x1="192" y1="256" x2="320" y2="128" stroke-width="56"/>
                            <line x1="192" y1="256" x2="320" y2="384" stroke-width="56"/>
                        </g>
                    </g>
                    <g class="o_connector_stroke_button o_connector_stroke_remove_button" t-on-click.stop="onRemoveButtonClick">
                        <rect fill="white" x="532" y="20" width="472" height="472" rx="236" ry="236"/>
                        <g transform="rotate(45,768,256)" pointer-events="none">
                            <rect x="740" y="100" fill="rgb(221, 60, 79)" width="56" height="312"/>
                            <rect x="612" y="228" fill="rgb(221, 60, 79)" width="312" height="56"/>
                        </g>
                    </g>
                    <g class="o_connector_stroke_button o_connector_stroke_reschedule_button" t-on-click.stop="onRightButtonClick">
                        <rect fill="white" x="1044" y="20" width="472" height="472" rx="236" ry="236"/>
                        <g pointer-events="none">
                            <line x1="1216" y1="128" x2="1344" y2="256" stroke-width="56"/>
                            <line x1="1216" y1="384" x2="1344" y2="256" stroke-width="56"/>
                        </g>
                    </g>
                </svg>
            </t>
        </svg>
    </t>

    `);
registerTemplate("web_gantt.ConnectorStroke", `/web_gantt/static/src/gantt_connector.xml`, `<t t-name="web_gantt.ConnectorStroke" xml:space="preserve">
        <path fill="none" t-att-stroke="color" t-att-stroke-width="width" t-att-class="class" t-att-marker-end="markerEnd ? \`url(#\${markerEnd})\` : false" t-att-pointer-events="isNew ? 'none' : 'stroke'"/>
    </t>

    `);
registerTemplate("web_gantt.ConnectorStrokeHead", `/web_gantt/static/src/gantt_connector.xml`, `<t t-name="web_gantt.ConnectorStrokeHead" xml:space="preserve">
        <path d="M2,2 L10,6 L2,10 L6,6 L2,2" class="o_connector_stroke_head" t-att-fill="color" t-att-stroke="color" t-att="xmlAttributes"/>
    </t>

`);
registerTemplate("web_gantt.GanttController", `/web_gantt/static/src/gantt_controller.xml`, `<t t-name="web_gantt.GanttController" xml:space="preserve">
        <div t-att-class="className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-create-button">
                    <button t-if="model.metaData.canCreate" class="o_gantt_button_add btn btn-primary" data-hotkey="r" t-on-click="onAddClicked">
                        New
                    </button>
                </t>
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-buttons">
                    <t t-call="{{ props.buttonTemplate }}"/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-set-slot="default" t-slot-scope="layout">
                    <t t-if="showNoContentHelp">
                        <t t-if="props.info.noContentHelp" t-call="web.ActionHelper">
                            <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                        </t>
                        <t t-else="" t-call="web.NoContentHelper"/>
                    </t>
                    <t t-component="props.Renderer" class="model.useSampleModel ? 'o_sample_data_disabled' : ''" model="model" arch="props.arch" create.bind="create" openDialog.bind="openDialog" scrollPosition="props.scrollPosition" contentRef="layout.contentRef"/>
                </t>
            </Layout>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttView.Buttons", `/web_gantt/static/src/gantt_controller.xml`, `<t t-name="web_gantt.GanttView.Buttons" xml:space="preserve">
        <div class="d-flex flex-wrap o_gantt_buttons_container">
        </div>
    </t>

`);
registerTemplate("web_gantt.GanttPopover", `/web_gantt/static/src/gantt_popover.xml`, `<t t-name="web_gantt.GanttPopover" xml:space="preserve">
        <div t-ref="root" style="max-width: 320px;"> 
            <div class="popover-header d-flex justify-content-between py-2 pe-2">
                <h4 class="p-0 pt-1">
                    <t t-esc="props.title"/>
                </h4>
                <span class="ms-4 mt-1 me-2 cursor-pointer" t-on-click.stop="props.close">
                    <i class="fa fa-close"/>
                </span>
            </div>
            <div class="popover-body">
                <t t-call="{{ templates.body }}" t-call-context="renderingContext"/>
            </div>
            <div t-if="(props.displayGenericButtons and props.buttons) or templates.footer" class="popover-footer border-top p-3 d-flex flex-wrap gap-1">
                <t t-if="props.displayGenericButtons and props.buttons">
                    <t t-foreach="props.buttons" t-as="button" t-key="button_index">
                        <button t-att-class="button.class" t-on-click="() =&gt; this.onClick(button)" t-esc="button.text"/>
                    </t>
                </t>
                <t t-if="templates.footer">
                    <t t-call="{{ templates.footer }}" t-call-context="renderingContext"/>
                </t>
            </div>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttPopover.default", `/web_gantt/static/src/gantt_popover.xml`, `<t t-name="web_gantt.GanttPopover.default" xml:space="preserve">
        <ul class="p-0 mb-0 list-unstyled">
            <li class="pe-2">
                <strong>Name</strong>: <span t-esc="name"/>
            </li>
            <li class="pe-2">
                <strong>Start</strong>: <span t-esc="start"/>
            </li>
            <li class="pe-2">
                <strong>Stop</strong>: <span t-esc="stop"/>
            </li>
        </ul>
    </t>

`);
registerTemplate("web_gantt.GanttPopoverInDialog", `/web_gantt/static/src/gantt_popover_in_dialog.xml`, `<t t-name="web_gantt.GanttPopoverInDialog" xml:space="preserve">
      <Dialog title="props.dialogTitle" footer="false">
          <t t-component="props.component" t-props="componentProps"/>
      </Dialog>
    </t>
`);
registerTemplate("web_gantt.GanttRenderer", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer" xml:space="preserve">
        <GanttRendererControls t-props="controlsProps"/>
        <div t-ref="grid" class="o_gantt_renderer o_renderer bg-view" t-att-class="{ o_has_row_headers: hasRowHeaders, 'pe-auto': isDragging }" t-att-style="getGridStyle()" t-on-pointermove="throttledComputeHoverParams" t-on-pointerleave="onPointerLeave">
            <t t-call="{{ constructor.headerTemplate }}"/>
            <t t-if="hasRowHeaders">
                <div class="o_gantt_row_headers o_gantt_row_sidebar o_gantt_grid_rows border-end position-sticky start-0 bg-view">
                    <t t-foreach="rowsToRender" t-as="row" t-key="row.id">
                        <t t-call="{{ constructor.rowHeaderTemplate }}"/>
                    </t>
                </div>
            </t>
            <div t-ref="cellContainer" class="o_gantt_cells o_gantt_grid_rows o_gantt_grid_columns position-relative">
                <t t-foreach="rowsToRender" t-as="row" t-key="row.id">
                    <t t-call="{{ constructor.rowContentTemplate }}"/>
                </t>
                <t t-foreach="pillsToRender" t-as="pill" t-key="pill.id">
                    <t t-set="row" t-value="getRowFromPill(pill)"/>
                    <t t-if="row.isGroup">
                        <t t-call="{{ constructor.groupPillTemplate }}"/>
                    </t>
                    <t t-else="">
                        <t t-call="{{ constructor.pillTemplate }}"/>
                    </t>
                </t>
                <t t-if="shouldRenderConnectors()">
                    <t t-foreach="connectorsToRender" t-as="connector" t-key="connector.id">
                        <GanttConnector reactive="connector" onRemoveButtonClick="() =&gt; this.onRemoveButtonClick(connector.id)" onLeftButtonClick="() =&gt; this.onRescheduleButtonClick('backward', connector.id)" onRightButtonClick="() =&gt; this.onRescheduleButtonClick('forward', connector.id)"/>
                    </t>
                </t>
                <GanttResizeBadge reactive="resizeBadgeReactive"/>
            </div>
            <t t-if="totalRow">
                <t t-call="{{ constructor.totalRowTemplate }}"/>
            </t>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.Header", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.Header" xml:space="preserve">
        <t t-if="hasRowHeaders">
            <b class="o_gantt_title d-flex align-items-center justify-content-center bg-100 position-sticky start-0 p-2 border-end" t-esc="model.metaData.string"/>
        </t>
        <div class="o_gantt_header_groups o_gantt_grid_columns bg-100 position-sticky">
            <t t-foreach="columnsGroups" t-as="column" t-key="column.id">
                <div class="o_gantt_header_title position-sticky d-flex align-items-center ps-2 overflow-hidden bg-100" t-att-style="getGridPosition({column: column.grid.column})">
                    <t t-esc="model.metaData.scale.groupHeaderFormatter(column.start, env)"/>
                </div>
            </t>
        </div>
        <div class="o_gantt_header_columns o_gantt_grid_columns bg-view position-sticky">
            <t t-foreach="columns" t-as="column" t-key="column.id">
                <div class="o_gantt_header_cell d-flex align-items-center justify-content-center py-2" t-att-class="{ o_gantt_today: column.isToday, 'bg-100': !column.isToday }" t-att-style="getGridPosition({column: column.grid.column})">
                    <t t-if="'colHeaderFormatter' in model.metaData.scale">
                        <t t-esc="model.metaData.scale.colHeaderFormatter(column.start, env)"/>
                    </t>
                    <small t-else="" class="text-center">
                        <t t-if="is24HourFormat">
                            <b t-esc="column.start.toFormat('H')"/>
                        </t>
                        <t t-else="">
                            <b t-esc="column.start.toFormat('h')"/>
                            <div class="d-xl-inline-block" t-esc="column.start.toFormat('a').toLowerCase()"/>
                        </t>
                    </small>
                </div>
            </t>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.ConnectorCreator", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.ConnectorCreator" xml:space="preserve">
        <div class="o_connector_creator_wrapper position-absolute w-100" t-attf-class="o_connector_creator_wrapper_{{ alignment.vertical }} {{ '_color' in pill ? 'o_gantt_color_' + pill._color : '' }}">
            <div class="o_connector_creator position-absolute" t-attf-class="o_connector_creator_{{ alignment.vertical }} o_connector_creator_{{ alignment.horizontal }}">
                <div class="o_connector_creator_bullet position-absolute z-n1 rounded-circle"/>
            </div>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.RowHeader", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.RowHeader" xml:space="preserve">
        <div class="o_gantt_row_header o_gantt_row_sidebar position-sticky start-0 bg-view align-items-center" t-att-class="{                 o_sample_data_disabled: isDisabled(row),                 o_gantt_row_sidebar_empty: !row.name,                 o_gantt_group: row.isGroup,                 o_gantt_hoverable: isHoverable(row),                 o_mobile_progress_bar: row.progressBar and isTouchDevice,                 o_group_open: !model.isClosed(row.id),             }" t-att-style="getGridPosition({ row: row.grid.row })" t-att-data-row-id="row.id" t-on-click.synthetic="() =&gt; row.isGroup ? this.model.toggleRow(row.id) : this.focusFirstPill(row.id)">
            <div class="o_gantt_row_title d-flex align-items-center h-100 w-100 pe-1" t-att-class="{ 'fw-bold': row.isGroup }" t-att-style="getRowTitleStyle(row)" t-att-title="row.name or ''">
                <i t-if="row.isGroup" t-attf-class="o_group_caret fa fa-fw me-1 fa-caret-{{ model.isClosed(row.id) ? 'right' : 'down' }}"/>
                <span t-if="row.thumbnailUrl and row.resId" class="o_gantt_row_thumbnail_wrapper" t-att-class="{ 'me-1' : row.isGroup }">
                    <img t-att-src="row.thumbnailUrl" class="o_gantt_row_thumbnail o_avatar rounded"/>
                </span>
                <span class="text-truncate w-0 flex-grow-1">
                    <t t-esc="row.name"/>
                </span>
            </div>
            <t t-if="row.progressBar">
                <GanttRowProgressBar t-props="getProgressBarProps(row)"/>
            </t>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.RowContent", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.RowContent" xml:space="preserve">

        <t t-foreach="columns" t-as="column" t-key="column.id">
            <t t-set="col" t-value="column.grid.column[0]"/>
            <div class="o_gantt_cell" t-att-class="ganttCellAttClass(row, column)" t-attf-style="{{ getGridPosition({ column: column.grid.column, row: row.grid.row }) }};{{ row.cellColors[column.id] || '' }}" t-att-data-row-id="row.id" t-att-data-col="col" t-on-click.synthetic="(ev) =&gt; row.isGroup ? this.model.toggleRow(row.id) : this.onCellClicked(row.id, col)"/>
        </t>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.Pill", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.Pill" xml:space="preserve">
        <t t-set="renderConnectors" t-value="shouldRenderRecordConnectors(pill.record)"/>
        <div class="o_gantt_pill_wrapper" t-att-class="{                 o_sample_data_disabled: isDisabled(row),                 o_draggable: !pill.disableDrag,                 o_undraggable: pill.disableDrag,                 o_resizable: !pill.disableStartResize or !pill.disableStopResize,                 'position-relative': renderConnectors             }" t-att-style="getGridPosition(pill.grid)" t-att-data-pill-id="pill.id">
            <t t-if="renderConnectors" t-call="{{ constructor.connectorCreatorTemplate }}">
                <t t-set="alignment" t-value="getConnectorCreatorAlignment('top')"/>
            </t>
            <div class="o_gantt_pill position-relative h-100 d-flex align-items-center" t-att-class="pill.className" t-on-click.synthetic="(ev) =&gt; this.onPillClicked(ev, pill)">
                <span t-if="pill._progress" class="position-absolute h-100 o_gantt_progress" t-attf-style="width:{{ pill._progress }}%;"/>
                <span class="o_gantt_pill_title text-truncate mx-1" t-esc="pill.displayName"/>
                <div t-if="pill.disableDrag" class="o_gantt_lock fa fa-lock ms-auto me-2"/>
            </div>
            <t t-if="renderConnectors" t-call="{{ constructor.connectorCreatorTemplate }}">
                <t t-set="alignment" t-value="getConnectorCreatorAlignment('bottom')"/>
            </t>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.GroupPill", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.GroupPill" xml:space="preserve">
        <div class="o_gantt_pill_wrapper o_gantt_group_pill align-items-center" t-att-class="{                 o_sample_data_disabled: isDisabled(row),                 o_group_open: !model.isClosed(row.id),             }" t-att-style="getGridPosition(pill.grid)">
            <div class="o_gantt_pill o_gantt_consolidated_pill position-relative overflow-visible" t-att-class="pill.className" t-att-title="pill.displayName">
                <span t-if="pill._progress" class="position-absolute h-100 o_gantt_progress" t-attf-style="width:{{ pill._progress }}%;"/>
            </div>
            <span class="o_gantt_pill_title bg-view text-truncate px-1 z-1" t-esc="pill.displayName"/>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRenderer.TotalRow", `/web_gantt/static/src/gantt_renderer.xml`, `<t t-name="web_gantt.GanttRenderer.TotalRow" xml:space="preserve">
        <t t-if="hasRowHeaders">
            <div class="o_gantt_row_total o_gantt_row_sidebar border-end position-sticky start-0 bg-view d-flex justify-content-end">
                <h4 class="o_gantt_row_title d-flex align-items-center pe-3 my-0 fw-bold" t-att-class="{ o_sample_data_disabled: isDisabled() }" t-att-title="totalRow.name" t-esc="totalRow.name"/>
            </div>
        </t>
        <div class="o_gantt_row_total o_gantt_grid_columns bg-view">
            <t t-foreach="columns" t-as="column" t-key="column.id">
                <div class="o_gantt_cell" t-att-class="{ o_gantt_today: column.isToday, o_sample_data_disabled: isDisabled() }" t-att-style="getGridPosition({ column: column.grid.column, row: [1, 2] })"/>
            </t>
            <t t-foreach="totalRow.pills" t-as="pill" t-key="pill.id">
                <div class="o_gantt_pill_wrapper position-relative p-0 h-100 d-flex align-items-end" t-att-class="{ o_sample_data_disabled: isDisabled() }" t-att-style="getGridPosition({ column: pill.grid.column, row: [1, 2] })">
                    <div class="o_gantt_pill o_gantt_consolidated_pill w-100 d-flex align-items-end justify-content-center" t-att-title="pill.displayName" t-attf-style="height: {{ totalRow.factor * pill.aggregateValue }}%;">
                        <span class="o_gantt_consolidated_pill_title bg-view text-truncate px-1 mb-1" t-att-class="{ 'o_gantt_consolidated_pill_small': this.isPillSmall(pill) }" t-esc="pill.displayName"/>
                    </div>
                </div>
            </t>
        </div>
    </t>

`);
registerTemplate("web_gantt.GanttRendererControls", `/web_gantt/static/src/gantt_renderer_controls.xml`, `<t t-name="web_gantt.GanttRendererControls" xml:space="preserve">
        <div class="o_gantt_renderer_controls d-inline-flex d-print-none flex-wrap column-gap-2 align-items-center w-100 bg-view border-bottom sticky-top start-0" t-att-class="{ 'p-1': !env.isSmall, 'gap-1 py-1': env.isSmall }">
            <t t-call="{{ constructor.rangeMenuTemplate }}"/>
            <hr t-if="env.isSmall" class="my-0 w-100"/>
            <button class="o_gantt_button_today btn btn-secondary" t-att-class="{ 'ms-3': env.isSmall }" title="Focus Today" data-hotkey="t" t-on-click="onTodayClicked">
                <i class="fa fa-crosshairs"/>
            </button>
            <button class="btn btn-secondary" t-att-disabled="state.scaleIndex === scalesRange.min" data-hotkey="j" t-on-click="() =&gt; this.incrementScale(-1)">
                <i class="fa fa-search-minus"/>
            </button>
            <input type="range" class="form-range flex-grow-1 w-0" t-att-min="scalesRange.min" t-att-max="scalesRange.max" step="1" t-att-value="state.scaleIndex" t-on-change="(ev) =&gt; this.selectScale(ev.target.value)"/>
            <button class="btn btn-secondary" t-att-disabled="state.scaleIndex === scalesRange.max" data-hotkey="i" t-on-click="() =&gt; this.incrementScale(1)">
                <i class="fa fa-search-plus"/>
            </button>
            <t t-if="env.isSmall">
                <div class="flex-grow-1 w-0"/>
                <Dropdown>
                    <button class="btn btn-secondary me-3" aria-label="Toolbar menu">
                        <i class="fa fa-cog"/>
                    </button>
                    <t t-set-slot="content">
                        <t t-call="{{ constructor.toolbarContentTemplate }}"/>
                    </t>
                </Dropdown>
            </t>
            <t t-else="" t-call="{{ constructor.toolbarContentTemplate }}"/>
        </div>
    </t>

    `);
registerTemplate("web_gantt.GanttRendererControls.ToolbarContent", `/web_gantt/static/src/gantt_renderer_controls.xml`, `<t t-name="web_gantt.GanttRendererControls.ToolbarContent" xml:space="preserve">
        <t t-if="!env.isSmall">
            <div class="btn-toolbar gap-2" role="toolbar" name="ganttToolbar">
                <button class="btn btn-secondary fa" t-att-class="{ 'fa-compress': model.displayParams.displayMode === 'sparse', 'fa-expand': model.displayParams.displayMode === 'dense'  }" t-att-title="model.displayParams.displayMode === 'dense' ? 'Activate sparse mode' : 'Activate dense mode'" t-on-click="model.toggleDisplayMode.bind(model)">
                </button>
                <div class="btn-group" t-att-class="{ invisible: !props.displayExpandCollapseButtons }" name="expandCollapseButtons">
                    <button class="o_gantt_button_expand_rows btn btn-secondary" title="Expand rows" t-on-click="model.expandRows.bind(model)">
                        <i class="fa fa-caret-square-o-right"/>
                    </button>
                    <button class="o_gantt_button_collapse_rows btn btn-secondary" title="Collapse rows" t-on-click="model.collapseRows.bind(model)">
                        <i class="fa fa-caret-square-o-down"/>
                    </button>
                </div>
            </div>
        </t>
        <t t-else="">
            <DropdownItem onSelected="model.toggleDisplayMode.bind(model)">
                <t t-if="model.displayParams.displayMode === 'dense'">
                    <i class="fa fa-fw fa-expand"/>
                    <span class="ms-1">Activate sparse mode</span>
                </t>
                <t t-else="">
                    <i class="fa fa-fw fa-compress"/>
                    <span class="ms-1">Activate dense mode</span>
                </t>
            </DropdownItem>
            <t t-if="props.displayExpandCollapseButtons">
                <div class="dropdown-divider" role="separator"/>
                <DropdownItem onSelected="model.expandRows.bind(model)">
                    <i class="fa fa-fw fa-caret-square-o-right"/>
                    <span class="ms-1">Expand rows</span>
                </DropdownItem>
                <DropdownItem onSelected="model.collapseRows.bind(model)">
                    <i class="fa fa-fw fa-caret-square-o-down"/>
                    <span class="ms-1">Collapse rows</span>
                </DropdownItem>
            </t>
        </t>
    </t>

    `);
registerTemplate("web_gantt.GanttRendererControls.RangeMenu", `/web_gantt/static/src/gantt_renderer_controls.xml`, `<t t-name="web_gantt.GanttRendererControls.RangeMenu" xml:space="preserve">
        <div class="btn-group" t-att-class="{ 'ms-3': env.isSmall }">
            <button class="btn btn-secondary" data-hotkey="p" t-on-click="() =&gt; this.selectRange('previous')">
                <i class="fa fa-arrow-left"/>
            </button>
            <button class="btn btn-secondary" data-hotkey="n" t-on-click="() =&gt; this.selectRange('next')">
                <i class="fa fa-arrow-right"/>
            </button>
        </div>
        <Dropdown state="dropdownState" menuClass="'o_gantt_range_menu'">
            <div class="btn btn-secondary">
                <i class="fa fa-calendar me-1"/>
                <t t-if="state.rangeId === 'custom'">
                    <t t-esc="formattedDateRange"/>
                </t>
                <t t-else="">
                    <t t-esc="dateDescription"/>
                </t>
            </div>
            <t t-set-slot="content">
                <t t-foreach="Object.entries(model.metaData.ranges)" t-as="range" t-key="range[0]">
                    <DropdownItem class="{ 'selected': isSelected(range[0]) }" onSelected="() =&gt; this.selectRangeId(range[0])">
                        <t t-esc="range[1].description"/>
                    </DropdownItem>
                </t>
                <div class="dropdown-divider"/>
                <DropdownItem class="{ 'o_gantt_range_custom_item py-0': true, 'selected': isSelected('custom') }" closingMode="'none'">
                    <div class="d-flex align-items-center gap-1">
                        <label>From </label>
                        <span class="o_gantt_picker o_input cursor-pointer px-1" t-ref="start-picker" t-on-click="() =&gt; startPicker.open()">
                            <t t-esc="getFormattedDate(pickerValues.startDate)"/>
                        </span>
                        <label>to </label>
                        <span class="o_gantt_picker o_input cursor-pointer px-1" t-ref="stop-picker" t-on-click="() =&gt; stopPicker.open()">
                            <t t-esc="getFormattedDate(pickerValues.stopDate)"/>
                        </span>
                        <button class="btn btn-sm btn-primary ms-1" t-on-click="onApply">Apply</button>
                    </div>
                </DropdownItem>
            </t>
        </Dropdown>
    </t>

`);
registerTemplate("web_gantt.GanttResizeBadge", `/web_gantt/static/src/gantt_resize_badge.xml`, `<t t-name="web_gantt.GanttResizeBadge" xml:space="preserve">
        <span t-if="props.reactive.position" class="o_gantt_pill_resize_badge badge rounded-pill bg-view position-fixed" t-att-class="{ 'text-success': diff &gt; 0, 'text-danger': diff &lt; 0 }" t-att-style="positionStyle" t-esc="diffText"/>
    </t>

`);
registerTemplate("web_gantt.GanttRowProgressBar", `/web_gantt/static/src/gantt_row_progress_bar.xml`, `<t t-name="web_gantt.GanttRowProgressBar" xml:space="preserve">
        <span class="o_gantt_progress_bar position-relative h-100 pe-none" t-att-class="\`o_gantt_group_\${status || 'none'}\`">
            <t t-if="props.progressBar.max_value gt 0">
                <span class="bg-opacity-25 position-absolute top-0 end-0 h-100" t-att-class="status and \`bg-\${status}\`" t-attf-style="width:{{ Math.min(props.progressBar.ratio, 100) }}%;"/>
                <span t-if="show" class="position-absolute top-0 end-0 h-100 d-flex align-items-center px-1" t-att-class="status ? \`text-bg-\${status}\` : 'bg-view'">
                    <span class="o_gantt_group_hours" t-esc="\`\${props.progressBar.value_formatted} / \${props.progressBar.max_value_formatted}\`"/>
                </span>
            </t>
            <t t-elif="show and props.progressBar.warning">
                <span class="o_gantt_group_hours position-absolute top-0 end-0 h-100 d-flex align-items-center px-1 pe-auto bg-view" t-attf-title="{{ props.progressBar.warning }}">
                    <t t-esc="props.progressBar.value_formatted"/>
                    <i class="fa fa-exclamation-triangle"/>
                </span>
            </t>
        </span>
    </t>
`);
registerTemplate("web_cohort.CohortView.Buttons", `/web_cohort/static/src/cohort_controller.xml`, `<t t-name="web_cohort.CohortView.Buttons" xml:space="preserve">
    </t>

    `);
registerTemplate("web_cohort.CohortView", `/web_cohort/static/src/cohort_controller.xml`, `<t t-name="web_cohort.CohortView" xml:space="preserve">
        <div t-att-class="props.className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="layout-buttons">
                    <t t-call="{{ props.buttonTemplate }}"/>
                </t>
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar/>
                </t>
                <t t-set="displayNoContent" t-value="                     props.info.noContentHelp !== false and (                         !model.hasData() or model.useSampleModel                     )"/>
                <t t-if="displayNoContent">
                    <t t-if="props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-else="" t-call="web.NoContentHelper"/>
                </t>
                <t t-component="props.Renderer" class="'o_renderer'" model="model" onRowClicked="(row) =&gt; this.onRowClicked(row)"/>
            </Layout>
        </div>
    </t>

`);
registerTemplate("web_cohort.CohortRenderer", `/web_cohort/static/src/cohort_renderer.xml`, `<t t-name="web_cohort.CohortRenderer" xml:space="preserve">
        <div class="o_cohort_renderer" t-att-class="props.class">
            <div class="d-flex gap-1 px-3 py-2">
                <div class="btn-group" role="toolbar" aria-label="Main actions">
                    <ReportViewMeasures measures="model.metaData.measures" activeMeasures="[model.metaData.measure]" onMeasureSelected.bind="this.onMeasureSelected"/>
                </div>
                    <div class="btn-group">
                    <ViewScaleSelector scales="scales" currentScale="model.metaData.interval" setScale.bind="setScale"/>
                </div>
                    <div class="btn-group">
                    <button class="btn btn-secondary fa fa-download o_cohort_download_button" title="Download as Excel file" t-on-click="downloadExcel"/>
                </div>
            </div>
            <t t-foreach="model.data" t-as="data" t-key="data_index">
                <div t-if="data.title" class="table-responsive">
                    <table class="table text-center mb-0">
                        <thead>
                            <tr>
                                <th colspan="16" class="text-center align-middle">
                                    <t t-esc="data.title"/>
                                </th>
                            </tr>
                        </thead>
                    </table>
                </div>
                <div t-if="data.rows.length" class="table-responsive">
                    <table class="o_data_table table table-bordered text-center mb-0">
                        <thead>
                            <tr>
                                <th rowspan="2" class="text-center align-middle">
                                    <t t-esc="model.metaData.dateStartString"/>
                                </th>
                                <th rowspan="2" class="text-center align-middle">
                                    <t t-esc="model.metaData.measures[model.metaData.measure].string"/>
                                </th>
                                <th colspan="16" class="text-center align-middle">
                                    <t t-esc="model.metaData.dateStopString"/> - By <t t-esc="model.intervals[model.metaData.interval]"/>
                                </th>
                            </tr>
                            <tr>
                                <th t-foreach="range(data.rows[0].columns.length)" t-as="intervalNumber" t-key="intervalNumber" class="text-center align-middle">
                                    <t t-if="model.metaData.timeline === 'backward'">
                                        <t t-esc="intervalNumber - (data.rows[0].columns.length - 1)"/>
                                    </t>
                                    <t t-else="">
                                        +<t t-esc="intervalNumber"/>
                                    </t>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr t-foreach="data.rows" t-as="row" t-key="row.date" class="o_cohort_row_clickable" t-on-click.stop="() =&gt; props.onRowClicked(row)">
                                <td class="o_cohort_value text-center align-middle p-0">
                                    <t t-esc="row.date"/>
                                </td>
                                <td class="o_cohort_value text-center align-middle p-0">
                                    <t t-esc="getFormattedValue(row.value)"/>
                                </td>
                                <td t-foreach="row.columns" t-as="col" t-key="col.period" class="text-center align-middle p-0">
                                    <t t-set="count" t-value="mode === 'churn' ? (col.churn_value === '-' ? '' : col.churn_value) : (col.value === '-' ? '' : col.value)"/>
                                    <t t-set="measure" t-value="model.metaData.measures[model.metaData.measure].string"/>
                                    <div class="o_cohort_highlight m-1 rounded p-1" t-att-title="getCellTitle(col.period, measure, count)" t-attf-style="background-color: rgba(0, 160, 157, {{col.percentage/100.0}}); color: {{col.percentage gt 50 and '#FFFFFF' or 'inherit'}}" t-att-class="{o_cohort_value: col.value !== '-'}">
                                        <t t-esc="formatPercentage(col.percentage / 100.0)"/>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                        <tfoot class="fw-bold">
                            <tr>
                                <td class="text-center align-middle">Average</td>
                                <td class="text-center align-middle">
                                    <t t-esc="getFormattedValue(data.avg.avg_value)"/>
                                </td>
                                <td t-foreach="data.avg.columns_avg" t-as="col" t-key="col_index" class="text-center align-middle">
                                    <t t-if="data.avg.columns_avg[col]['count']">
                                        <t t-esc="formatPercentage(data.avg.columns_avg[col]['percentage'] / (data.avg.columns_avg[col]['count'] * 100.0))"/>
                                    </t>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
                <div t-if="model.data.length &gt; 1 &amp;&amp; !data.rows.length" class="o_cohort_no_data text-center p-3 border">
                    No data available.
                </div>
                <br/>
            </t>
        </div>
    </t>

`);
registerTemplate("web_grid.FloatToggleGridCell", `/web_grid/static/src/components/float_toggle_grid_cell.xml`, `<t t-name="web_grid.FloatToggleGridCell" t-inherit="web_grid.Cell" xml:space="preserve">
        <xpath expr="//input" position="replace">
            <button t-if="state.edit" class="o_field_float_toggle" t-on-click="onChange" t-on-keydown="onKeyDown" t-ref="toggleButton">
                <t t-out="formattedValue"/>
            </button>
        </xpath>
    </t>
`);
registerTemplate("web_grid.Cell", `/web_grid/static/src/components/grid_cell.xml`, `<t t-name="web_grid.Cell" xml:space="preserve">
        <div t-if="props.reactive.cell" t-attf-class="{{ props.classNames }} o_grid_cell o_grid_highlightable position-relative d-flex justify-content-center align-items-center w-100 h-100 text-800" t-on-click.synthetic="onCellClick" t-ref="root">
            <button class="o_grid_search_btn btn btn-sm position-absolute start-0 px-1 opacity-50 opacity-100-hover" t-on-click.synthetic="() =&gt; this.magnifierGlassHook.onMagnifierGlassClick()">
                <i class="fa fa-search"/>
            </button>
            <div t-if="state.cell" class="d-flex w-100 h-100 justify-content-center align-items-center">
                <input t-if="state.edit" t-att-inputmode="inputMode" type="text" class="o_input h-100" t-ref="numpadDecimal"/>
                <span t-else="" class="z-1" t-out="formattedValue"/>
            </div>
        </div>
    </t>
`);
registerTemplate("web_grid.GridComponent", `/web_grid/static/src/components/grid_component/grid_component.xml`, `<t t-name="web_grid.GridComponent" xml:space="preserve">
        <t t-component="gridComponent" t-props="gridComponentProps"/>
    </t>

`);
registerTemplate("web_grid.GridRow", `/web_grid/static/src/components/grid_row/grid_row.xml`, `<t t-name="web_grid.GridRow" xml:space="preserve">
        <div t-att-name="props.name" t-att-class="props.classNames" t-att-style="props.style">
            <span t-if="value" t-esc="value"/>
            <span t-else="" class="o_grid_no_data text-300">None</span>
        </div>
    </t>

`);
registerTemplate("web_grid.Many2OneGridRow", `/web_grid/static/src/components/many2one_grid_row/many2one_grid_row.xml`, `<t t-name="web_grid.Many2OneGridRow" xml:space="preserve">
        <div t-att-name="props.name" t-att-class="props.classNames" t-att-style="props.style">
            <t t-if="!props.canOpen and resId">
                <span>
                    <span t-esc="displayName" t-att-class="{'me-2': props.row.isAdditionalRow}"/>
                    <t t-foreach="extraLines" t-as="extraLine" t-key="extraLine_index">
                        <br/>
                        <span t-esc="extraLine"/>
                    </t>
                </span>
            </t>
            <t t-elif="resId">
                <a t-attf-class="o_form_uri" t-att-href="\`/odoo/\${urlRelation}/\${resId}\`" t-on-click.prevent="onClick">
                    <span t-esc="displayName" t-att-class="{'me-2': props.row.isAdditionalRow}"/>
                    <t t-foreach="extraLines" t-as="extraLine" t-key="extraLine_index">
                        <br/>
                        <span t-esc="extraLine"/>
                    </t>
                </a>
            </t>
            <span t-else="" class="o_grid_no_data text-300">None</span>
        </div>
    </t>

`);
registerTemplate("web_grid.Buttons", `/web_grid/static/src/views/grid_controller.xml`, `<t t-name="web_grid.Buttons" xml:space="preserve">
        <div class="d-flex o_grid_buttons">
            <div class="me-2" t-if="displayAddALine">
                <button class="btn btn-primary o_grid_button_add" type="button" t-on-click="() =&gt; this.createRecord()">
                    Add a Line
                </button>
            </div>
            <t t-call="web_grid.CustomButtons" t-if="props.archInfo.buttons.length"/>
        </div>
    </t>
    `);
registerTemplate("web_grid.CustomButtons", `/web_grid/static/src/views/grid_controller.xml`, `<t t-name="web_grid.CustomButtons" xml:space="preserve">
        <div class="o_grid_custom_buttons me-2">
            <t t-foreach="props.archInfo.buttons" t-as="button" t-key="button.id">
                <ViewButton t-if="!button.invisible" className="button.className" clickParams="button.clickParams" defaultRank="button.defaultRank" icon="button.icon" string="button.string" title="button.title" record="model.record"/>
            </t>
        </div>
    </t>
    `);
registerTemplate("web_grid.GridView", `/web_grid/static/src/views/grid_controller.xml`, `<t t-name="web_grid.GridView" xml:space="preserve">
        <div t-attf-class="o_grid_view {{ isMobile ? 'o_action_delegate_scroll' : '' }} {{props.className}}" t-ref="root">
            <Layout className="(model.useSampleModel ? 'o_view_sample_data' : '')" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-buttons">
                    <t t-call="{{ props.buttonTemplate }}"/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-set-slot="default" t-slot-scope="layout">
                    <t t-if="displayNoContent">
                        <t t-call="web.ActionHelper">
                            <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                        </t>
                    </t>
                    <t t-if="hasDisplayableData">
                        <t t-component="props.Renderer" options="options" model="model" sections="model.sectionsArray" columns="columns" rows="model.itemsArray" sectionField="model.sectionField" rowFields="model.rowFields" measureField="props.archInfo.measureField" isEditable="isEditable" createInline="props.archInfo.activeActions.create and props.archInfo.createInline and !displayNoContent" createRecord.bind="createRecord" widgetPerFieldName="props.archInfo.widgetPerFieldName" openAction="props.archInfo.openAction" contentRef="layout.contentRef" ranges="model.ranges" state="state" toggleWeekendVisibility.bind="toggleWeekendVisibility"/>
                    </t>
                </t>
            </Layout>
        </div>
    </t>
`);
registerTemplate("web_grid.Renderer", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.Renderer" xml:space="preserve">
        <div class="o_grid_renderer position-relative z-0" t-ref="renderer">
            <div class="o_grid_grid d-grid gap-0 border-bottom bg-100" t-attf-style="grid-template-rows: {{ gridTemplateRows }}; grid-template-columns: {{ gridTemplateColumns }}" t-on-mouseover.stop="onMouseOver" t-on-mouseout.stop="onMouseOut">
                <t t-call="web_grid.Header"/>
                <t t-foreach="virtualRows" t-as="row" t-key="row.id">
                    <t t-if="row.isSection">
                        <t t-call="web_grid.Section"/>
                    </t>
                    <t t-else="">
                        <t t-call="web_grid.Row"/>
                        <t t-if="displayAddLine">
                            <t t-call="web_grid.AddLine"/>
                        </t>
                    </t>
                </t>
                <t t-if="props.createInline and !props.model.hasData()" t-call="web_grid.AddLine"/>
                <t t-call="web_grid.Footer"/>
                <t t-if="props.options.hasBarChartTotal" t-call="web_grid.barChart"/>
                <GridComponent t-props="hoveredCellProps"/>
                <GridComponent t-props="editCellProps"/>
            </div>
        </div>
    </t>
    `);
registerTemplate("web_grid.Header", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.Header" xml:space="preserve">
        <div class="o_grid_column_title o_grid_navigation_wrap position-md-sticky top-0 start-0 d-flex align-items-center gap-2 px-3 border-bottom bg-100 overflow-visible" t-attf-style="grid-row: {{rowsGap}}; grid-column: {{columnsGap}};">
            <t t-call="web_grid.NavigationButtons"/>
        </div>
        <div t-foreach="props.columns" t-as="column" t-key="column.id" class="o_grid_column_title position-relative position-md-sticky top-0 d-flex align-items-center justify-content-center px-3 py-2 border-bottom text-bg-100" t-att-class="{                 'fw-bolder': column.isToday,                 'fw-bold' : !column.isToday,                 'text-opacity-25' : getUnavailableClass(column) === 'o_grid_unavailable'              }" t-att-data-grid-row="rowsGap" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowsGap}}; grid-column: {{column_index + 1 + columnsGap}};">
            <div class="position-absolute top-0 start-0 w-100 h-100" t-att-class="{                     'o_grid_cell_overlay_today bg-info': column.isToday,                     'o_grid_cell_overlay bg-700' : !column.isToday,                  }" t-attf-class="{{getUnavailableClass(column)}}"/>
            <span class="z-1 text-center" t-out="column.title"/>
        </div>
        <div t-if="!props.options.hideLineTotal" class="o_grid_column_title o_grid_row_total position-md-sticky top-0 end-0 d-flex align-items-center justify-content-center text-bg-200 px-3 py-2 border-bottom fw-bold text-center" t-attf-style="grid-row: {{rowsGap}}; grid-column: {{props.columns.length + 1 + columnsGap}};">
            <span class="z-1" t-out="measureLabel"/>
        </div>
    </t>
    `);
registerTemplate("web_grid.Section", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.Section" xml:space="preserve">
        <t t-set="section" t-value="row"/>
        <t t-set="rowPosition" t-value="getRowPosition(section)"/>
        <t name="section" t-if="!section.isFake and (props.sections.length &gt; 1 or section.value)">
            <div class="o_grid_section o_grid_section_title o_grid_highlightable d-flex align-items-center ps-3 border-top bg-200 fw-bold" t-att-class="{                     'position-md-sticky start-0': !props.model.useSampleModel,                  }" t-att-data-grid-row="rowPosition" t-att-data-grid-column="columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{columnsGap}};">
            <div class="o_grid_cell_overlay position-absolute top-0 start-0 w-100 h-100 bg-700"/>
                <GridComponent classNames="'z-1 text-truncate'" name="props.sectionField.name" model="props.model" row="section" t-props="getFieldAdditionalProps(props.sectionField.name)"/>
            </div>
            <div t-foreach="props.columns" t-as="column" t-key="column.id" t-attf-class="o_grid_section o_grid_highlightable position-relative d-flex align-items-center justify-content-center fw-bold {{ getCellColorClass(column) }}" t-att-class="getSectionColumnsClasses(column, section)" t-att-data-row="section.id" t-att-data-column="column.id" t-att-data-grid-row="rowPosition" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{column_index + 1 + columnsGap}};">
                <div class="position-absolute top-0 start-0 w-100 h-100" t-att-class="{                        'o_grid_cell_overlay_today bg-info bg-opacity-25' : column.isToday,                        'o_grid_cell_overlay bg-700' : !column.isToday,                     }" t-attf-class="{{getUnavailableClass(column)}}"/>
                <div class="o_grid_cell_readonly position-relative d-flex justify-content-center align-items-center w-100 h-100">
                    <span class="z-1" t-att-class="getSectionCellsClasses(column, section)" t-out="formatValue(section.cells[column.id].value)"/>
                </div>
            </div>
            <t t-set="grandTotal" t-value="section.getGrandTotal(props.state.isWeekendVisible)"/>
            <div t-if="!props.options.hideLineTotal" class="o_grid_section o_grid_row_total o_grid_highlightable position-relative position-md-sticky end-0 z-1 d-flex align-items-center justify-content-center px-3 py-1 border-top fw-bold" t-att-class="getSectionTotalRowClass(section, grandTotal)" t-att-data-grid-row="rowPosition" t-att-data-grid-column="props.columns.length + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{props.columns.length + 1 + columnsGap}};">
                <div class="o_grid_cell_overlay_total position-absolute top-0 start-0 w-100 h-100 bg-900"/>
                <div class="position-relative d-flex align-items-center">
                    <span t-out="formatValue(grandTotal)"/>
                </div>
            </div>
        </t>
    </t>
    `);
registerTemplate("web_grid.Row", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.Row" xml:space="preserve">
        <t t-set="rowPosition" t-value="getRowPosition(row)"/>
        <t t-set="isEven" t-value="rowPosition % 2 !== 0"/>
        <div name="row" class="o_grid_row o_grid_row_title o_grid_highlightable position-relative d-flex flex-column flex-md-row justify-content-center justify-content-md-start align-items-md-center px-3 py-1" t-att-class="{                 'position-md-sticky start-0': !props.model.useSampleModel,                 'bg-view': isEven,                 'bg-100': !isEven,                 'fst-italic': row.isAdditionalRow,                 'text-opacity-25' : getUnavailableClass(row) === 'o_grid_unavailable'              }" t-att-data-grid-row="rowPosition" t-att-data-grid-column="columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{columnsGap}};">
            <div class="o_grid_cell_overlay position-absolute top-0 start-0 w-100 h-100 bg-700"/>
            <t t-set="rowFields" t-value="props.model.rowFields.map(field =&gt; field.name)"/>
            <t t-foreach="props.rowFields" t-as="rowField" t-key="rowField_index">
                <t t-set="fieldName" t-value="rowField.name"/>
                <GridComponent t-if="row.initialRecordValues[fieldName] or rowField_index === 0" classNames="\`d-flex z-1 text-truncate o_grid_field_\${fieldName.replace('_id','')}\${isMobile ? '' : ' text-nowrap'}\${row.isAdditionalRow ? ' pe-1' : ''}\`" name="fieldName" value="row.initialRecordValues[fieldName]" model="props.model" row="row" t-props="getFieldAdditionalProps(fieldName)"/>
                <span t-if="!rowField_last and row.initialRecordValues[props.rowFields[rowField_index + 1].name]" class="o_grid_row_data_separator d-none d-md-inline px-2 text-300">
                |
                </span>
            </t>
        </div>
        <div t-foreach="props.columns" t-as="column" t-key="column.id" class="o_grid_row o_grid_highlightable position-relative d-flex align-items-center justify-content-center" t-att-class="getCellsClasses(column, row, section, isEven)" t-att-data-row="row.id" t-att-data-column="column.id" t-att-data-grid-row="rowPosition" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{column_index + 1 + columnsGap}};" t-on-click.prevent.synthetic="onCellClick">
            <div class="position-absolute top-0 start-0 w-100 h-100" t-att-class="{                     'o_grid_cell_overlay_today bg-info bg-opacity-25' : column.isToday,                     'o_grid_cell_overlay bg-700' : !column.isToday,                  }" t-attf-class="{{getUnavailableClass(column)}}"/>
            <div class="o_grid_cell_readonly position-relative d-flex justify-content-center align-items-center w-100 h-100">
                <span t-att-class="{                           'text-900 text-opacity-25': row.cells[column.id].value === 0,                       }" t-esc="formatValue(row.cells[column.id].value)"/>
            </div>
        </div>
        <t t-set="grandTotal" t-value="row.getGrandTotal(props.state.isWeekendVisible)"/>
        <div t-if="!props.options.hideLineTotal" class="o_grid_row o_grid_row_total o_grid_highlightable position-relative position-md-sticky end-0 d-flex align-items-center justify-content-center px-3 py-1" t-att-class="{                 'fst-italic': row.isAdditionalRow,                 'text-bg-200': grandTotal &gt;= 0,                 'bg-danger text-bg-danger': grandTotal lt 0,                 'text-opacity-50': grandTotal === 0              }" t-att-data-grid-row="rowPosition" t-att-data-grid-column="props.columns.length + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{props.columns.length + 1 + columnsGap}};">
            <div class="o_grid_cell_overlay_total position-absolute top-0 start-0 w-100 h-100 bg-900"/>
            <span class="z-1" t-out="formatValue(grandTotal)"/>

        </div>
    </t>
    `);
registerTemplate("web_grid.AddLine", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.AddLine" xml:space="preserve">
        <t t-set="rowPosition" t-value="getRowPosition(row or undefined, true)"/>
        <t t-set="isEven" t-value="rowPosition % 2 !== 0"/>
        <div t-if="props.createInline" class="o_grid_row o_grid_add_line o_grid_add_line_first_cell position-md-sticky start-0 d-flex align-items-center z-1 ps-3" t-att-class="{                 'bg-view': isEven,                 'bg-100': !isEven,              }" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{columnsGap}};">
            <a class="btn btn-link o_text_overflow" t-on-click="() =&gt; this.onCreateInlineClick(row?.section)" data-hotkey="i">
               <i class="fa fa-plus-circle fs-4 me-1"/>Add a line
            </a>
        </div>
        <div t-foreach="props.columns" t-as="column" t-key="column.id" class="o_grid_row o_grid_add_line position-relative" t-att-class="{                    'o_grid_cell_today' : column.isToday,                    'bg-view': isEven,                 }" t-att-data-grid-row="rowPosition" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{column_index + 1 + columnsGap}};">
            <div class="position-absolute top-0 start-0 w-100 h-100" t-att-class="{                     'o_grid_cell_overlay_today bg-info bg-opacity-25' : column.isToday,                     'o_grid_cell_overlay bg-700' : !column.isToday,                  }" t-attf-class="{{getUnavailableClass(column)}}"/>
        </div>
        <div class="o_grid_add_line position-md-sticky end-0 text-bg-200" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{props.columns.length + 1 + columnsGap}};"/>
    </t>
    `);
registerTemplate("web_grid.Footer", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.Footer" xml:space="preserve">
        <t t-if="!props.options.hideColumnTotal">
            <t t-set="rowPosition" t-value="getTotalRowPosition()"/>
            <t t-set="isEven" t-value="rowPosition % 2 !== 0"/>
            <div class="" t-att-class="{                     'bg-view': isEven,                     'bg-100': !isEven,                     'z-1 position-md-sticky start-0': !props.model.useSampleModel,                  }" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{columnsGap}};"/>
            <t t-set="grandTotal" t-value="0"/>
            <div t-foreach="props.columns" t-as="column" t-key="column.id" class="o_grid_row o_grid_column_total o_grid_highlightable position-relative" t-att-class="{                     'bg-view': isEven and column.grandTotal &gt;= 0,                     'text-danger': column.grandTotal lt 0,                  }" t-att-data-grid-row="rowPosition" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{column_index + 1 + columnsGap}};">
                <div class="position-absolute top-0 start-0 w-100 h-100" t-att-class="{                         'o_grid_cell_overlay_today bg-info bg-opacity-25' : column.isToday,                         'o_grid_cell_overlay bg-700' : !column.isToday,                      }" t-attf-class="{{getUnavailableClass(column)}}"/>
                <t t-set="grandTotal" t-value="grandTotal + column.grandTotal"/>
                <div class="h-100 d-flex justify-content-center align-items-center" t-if="column.grandTotal !== 0">
                    <div class="o_grid_bar_chart_total_title">
                        <span class="fs-5 fw-bolder" t-att-class="{                                 'text-danger' : getUnavailableClass(column) === 'o_grid_unavailable' and column.grandTotal gt 0                               }">
                            <t t-esc="formatValue(column.grandTotal)"/>
                        </span>
                    </div>
                </div>
            </div>
            <div t-if="!props.options.hideLineTotal" t-att-data-grid-row="rowPosition" t-att-data-grid-column="props.columns.length + 1 + columnsGap" t-attf-class="o_grid_highlightable position-md-sticky end-0 d-flex align-items-center justify-content-center text-black fw-bold {{ getFooterTotalCellClasses(grandTotal) }}" t-attf-style="grid-row: {{rowPosition}}; grid-column: {{props.columns.length + 1 + columnsGap}};">
                <span>
                    <t t-esc="formatValue(grandTotal)"/>
                </span>
            </div>
        </t>
    </t>
    `);
registerTemplate("web_grid.barChart", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.barChart" xml:space="preserve">
        <t t-if="!props.options.hideColumnTotal">
            <t t-set="rowPosition" t-value="getTotalRowPosition()"/>
            <t t-set="isEven" t-value="(rowPosition + 1) % 2 !== 0"/>
            <div class="o_grid_row_barChart" t-att-class="{                     'bg-view': isEven,                     'bg-100': !isEven,                     'z-1 position-md-sticky start-0': !props.model.useSampleModel,                  }" t-attf-style="grid-row: {{rowPosition + 1}}; grid-column: {{columnsGap}};"/>
            <t t-set="grandTotal" t-value="0"/>
            <div t-foreach="props.columns" t-as="column" t-key="column.id" class="o_grid_row o_grid_column_total o_grid_highlightable o_grid_bar_chart_container" t-att-class="{'bg-view': isEven}" t-att-data-grid-row="rowPosition + 1" t-att-data-grid-column="column_index + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition + 1}}; grid-column: {{column_index + 1 + columnsGap}};">
                <t t-set="grandTotal" t-value="grandTotal + column.grandTotal"/>
                <div class="h-100 position-relative" t-if="column.grandTotal !== 0">
                    <div class="o_grid_bar_chart_total_pill position-absolute w-100 border-top border-primary border-2 bg-primary bg-opacity-50" t-if="props.options.hasBarChartTotal" t-att-style="getColumnBarChartHeightStyle(column)">
                    </div>
                </div>
            </div>
            <div t-if="!props.options.hideLineTotal" class="o_grid_row o_grid_column_total o_grid_row_total o_grid_highlightable position-md-sticky end-0 bg-200" t-att-data-grid-row="rowPosition + 1" t-att-data-grid-column="props.columns.length + 1 + columnsGap" t-attf-style="grid-row: {{rowPosition + 1}}; grid-column: {{props.columns.length + 1 + columnsGap}};">
                <div class="h-100 position-relative" t-if="grandTotal !== 0"/>
            </div>
        </t>
    </t>
    `);
registerTemplate("web_grid.NavigationButtons", `/web_grid/static/src/views/grid_renderer.xml`, `<t t-name="web_grid.NavigationButtons" xml:space="preserve">
        <div class="o_grid_navigation_buttons position-md-sticky d-flex gap-2" t-if="props.model.columnFieldIsDate">
            <button class="btn btn-secondary" data-hotkey="t" type="button" t-on-click="onTodayButtonClick">
                Today
            </button>
            <div class="btn-group">
                <button class="btn btn-secondary" type="button" t-on-click="onPreviousButtonClick" data-hotkey="p">
                    <span aria-label="Previous" class="oi oi-arrow-left" role="img" title="Previous"/>
                </button>
                <ViewScaleSelector t-if="rangesArray.length" scales="props.ranges" currentScale="props.state.activeRangeName" setScale.bind="onRangeClick" isWeekendVisible="props.state.isWeekendVisible" toggleWeekendVisibility="props.toggleWeekendVisibility"/>
                <button type="button" class="btn btn-secondary" t-on-click="onNextButtonClick" data-hotkey="n">
                    <span aria-label="Next" class="oi oi-arrow-right" role="img" title="Next"/>
                </button>
            </div>
        </div>
    </t>
`);
registerTemplate("project_enterprise.ProjectTaskMapRenderer", `/project_enterprise/static/src/views/project_task_map/project_task_map_renderer.xml`, `<t t-name="project_enterprise.ProjectTaskMapRenderer" t-inherit="web_map.MapRenderer" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//t[@t-if='env.isSmall']//t[@t-call='web_map.MapRenderer.PinListContainer']" position="attributes">
            <attribute name="t-call">project_enterprise.ProjectTaskMapRenderer.PinListContainer</attribute>
        </xpath>
        <xpath expr="//t[@t-if='!env.isSmall']//t[@t-call='web_map.MapRenderer.PinListContainer']" position="attributes">
            <attribute name="t-call">project_enterprise.ProjectTaskMapRenderer.PinListContainer</attribute>
        </xpath>
    </t>
    `);
registerTemplate("project_enterprise.ProjectTaskMapRenderer.PinListContainer", `/project_enterprise/static/src/views/project_task_map/project_task_map_renderer.xml`, `<t t-name="project_enterprise.ProjectTaskMapRenderer.PinListContainer" t-inherit="web_map.MapRenderer.PinListContainer" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//t[@t-elif='canDisplayPinList']/t[@t-call='web_map.MapRenderer.PinList']" position="attributes">
            <attribute name="t-call">project_enterprise.ProjectTaskMapRenderer.PinList</attribute>
        </xpath>
        <xpath expr="//t[@t-if='canDisplayPinList and props.model.data.isGrouped']//t[@t-call='web_map.MapRenderer.PinList']" position="attributes">
            <attribute name="t-call">project_enterprise.ProjectTaskMapRenderer.PinList</attribute>
        </xpath>
    </t>
    `);
registerTemplate("project_enterprise.ProjectTaskMapRenderer.PinList", `/project_enterprise/static/src/views/project_task_map/project_task_map_renderer.xml`, `<t t-name="project_enterprise.ProjectTaskMapRenderer.PinList" t-inherit="web_map.MapRenderer.PinList" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//t[@t-call='web_map.MapRenderer.PinListItems']" position="attributes">
            <attribute name="t-call">project_enterprise.ProjectTaskMapRenderer.PinListItems</attribute>
        </xpath>
    </t>
    `);
registerTemplate("project_enterprise.ProjectTaskMapRenderer.PinListItems", `/project_enterprise/static/src/views/project_task_map/project_task_map_renderer.xml`, `<t t-name="project_enterprise.ProjectTaskMapRenderer.PinListItems" t-inherit="web_map.MapRenderer.PinListItems" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//li[@t-if='latitude and longitude']" position="attributes">
            <attribute name="t-attf-class">#{record.planned_date_begin ? '' : 'text-muted'}</attribute>
        </xpath>
        <xpath expr="//t[@t-foreach='records']" position="before">
            <p t-if="!records.length" class="fst-italic text-muted">View customer locations for your tasks</p>
        </xpath>
    </t>
`);
registerTemplate("project_enterprise.MilestonesPopover", `/project_enterprise/static/src/views/task_gantt/milestones_popover.xml`, `<t t-name="project_enterprise.MilestonesPopover" xml:space="preserve">
        <div class="popover-body">
            <ul class="mb-0 list-unstyled">
                <li t-foreach="Object.values(props.projects)" t-as="project" t-key="project.id">
                    <t t-if="props.displayProjectName">
                        <div><u><t t-out="project.name"/></u></div>
                    </t>
                    <em t-if="project.isStartDate">Project start</em>
                    <em t-if="project.isDeadline">Project due</em>
                    <ul class="mb-0 list-unstyled">
                        <li t-foreach="project.milestones" t-as="milestone" t-key="milestone_index">
                            <t t-if="milestone.is_deadline_exceeded">
                                <i t-attf-class="fa fa-square-o fa-fw text-start o_unreached_milestones"/>
                            </t>
                            <t t-else="">
                                <i class="fa fa-fw text-start" t-attf-class="{{milestone.is_reached ? 'fa-check-square-o o_milestones_reached' : 'fa-square-o'}}"/>
                            </t>
                            <strong><t t-out="milestone.name"/></strong>
                            <span t-if="props.displayMilestoneDates"><br/><t t-out="getDeadline(milestone)"/></span>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </t>

`);
registerTemplate("project_enterprise.TaskGanttRenderer.RowHeader", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.RowHeader" t-inherit="web_gantt.GanttRenderer.RowHeader" xml:space="preserve">
        <xpath expr="//t[@t-esc='row.name']" position="replace">
            <Avatar t-if="hasAvatar(row)" t-props="getAvatarProps(row)"/>
            <t t-else="" t-esc="row.name"/>
        </xpath>
    </t>

    `);
registerTemplate("project_enterprise.TaskGanttRenderer.Header", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.Header" t-inherit="web_gantt.GanttRenderer.Header" xml:space="preserve">
        <xpath expr="//t[@t-foreach='columns']/div" position="inside">
            <t t-set="columnInfo" t-value="columnMilestones[column.id]"/>
            <t t-if="columnInfo.edge &amp;&amp; columnInfo.edge.hasStartDate">
                <div class="o_project_edge_startdate_circle" t-on-mouseenter="(ev) =&gt; this.onMilestoneMouseEnter(ev, columnInfo.edge.projects)" t-on-mouseleave="onMilestoneMouseLeave"/>
            </t>
            <t t-if="columnInfo.hasMilestone">
                <div class="o_project_milestone_diamond" t-att-class="{                          'o_unreached_milestones': columnInfo.hasDeadLineExceeded,                          'edge_slot': column_last,                          'o_project_deadline_milestone': columnInfo.hasDeadline,                          'o_project_startdate_milestone': !columnInfo.hasDeadline &amp;&amp; columnInfo.hasStartDate,                      }" t-on-mouseenter="(ev) =&gt; this.onMilestoneMouseEnter(ev, columnInfo.projects)" t-on-mouseleave="onMilestoneMouseLeave">
                    <i class="fa fa-check o_milestones_reached" t-att-class="{ 'edge_slot': column_last }" t-if="columnInfo.allReached"/>
                </div>
            </t>
            <t t-elif="columnInfo.hasDeadline || columnInfo.hasStartDate">
                <div t-att-class="{                          'o_project_deadline_circle': columnInfo.hasDeadline,                          'o_project_startdate_circle': !columnInfo.hasDeadline &amp;&amp; columnInfo.hasStartDate,                      }" t-on-mouseenter="(ev) =&gt; this.onMilestoneMouseEnter(ev, columnInfo.projects)" t-on-mouseleave="onMilestoneMouseLeave"/>
            </t>
        </xpath>
    </t>

    `);
registerTemplate("project_enterprise.TaskGanttRenderer.ColoredCellBorder", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.ColoredCellBorder" xml:space="preserve">
        <t t-set="columnInfo" t-value="columnMilestones[column.id]"/>
        <t t-if="columnInfo.edge &amp;&amp; columnInfo.edge.hasStartDate">
            <div class="o_edge_startdate_pin" t-att-style="coloredCellBorderStyle"/>
        </t>
        <t t-if="columnInfo.hasMilestone">
            <div class="o_project_milestone" t-att-style="coloredCellBorderStyle" t-att-class="{ 'o_unreached_milestones': columnInfo.hasDeadLineExceeded }"/>
        </t>
        <t t-elif="columnInfo.hasDeadline">
            <div class="o_project_milestone o_unreached_milestones" t-att-style="coloredCellBorderStyle"/>
        </t>
        <t t-elif="columnInfo.hasStartDate">
            <div class="o_project_milestone o_startdate_pin" t-att-style="coloredCellBorderStyle"/>
        </t>
    </t>

    `);
registerTemplate("project_enterprise.TaskGanttRenderer.RowContent", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.RowContent" t-inherit="web_gantt.GanttRenderer.RowContent" xml:space="preserve">
        <xpath expr="//div[hasclass('o_gantt_cell')]" position="after">
            <t t-call="project_enterprise.TaskGanttRenderer.ColoredCellBorder">
                <t t-set="coloredCellBorderStyle" t-value="getGridPosition({ column: column.grid.column, row: row.grid.row })"/>
            </t>
        </xpath>
    </t>

     `);
registerTemplate("project_enterprise.TaskGanttRenderer.TotalRow", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.TotalRow" t-inherit="web_gantt.GanttRenderer.TotalRow" xml:space="preserve">
        <xpath expr="//div[hasclass('o_gantt_cell')]" position="after">
            <t t-call="project_enterprise.TaskGanttRenderer.ColoredCellBorder">
                <t t-set="coloredCellBorderStyle" t-value="getGridPosition({ column: column.grid.column })"/>
            </t>
        </xpath>
    </t>

    `);
registerTemplate("project_enterprise.TaskGanttRenderer.Pill", `/project_enterprise/static/src/views/task_gantt/task_gantt_renderer.xml`, `<t t-name="project_enterprise.TaskGanttRenderer.Pill" t-inherit="web_gantt.GanttRenderer.Pill" xml:space="preserve">
        <xpath expr="//div[hasclass('o_gantt_lock')]" position="before">
            <div t-if="!renderConnectors" class="o_gantt_forbidden fa fa-ban ms-auto me-2"/>
        </xpath>
    </t>

`);
registerTemplate("project_enterprise.ProjectGanttRenderer.RowHeader", `/project_enterprise/static/src/views/project_gantt/project_gantt_renderer.xml`, `<t t-name="project_enterprise.ProjectGanttRenderer.RowHeader" t-inherit="web_gantt.GanttRenderer.RowHeader" owl="1" xml:space="preserve">
        <xpath expr="//t[@t-esc='row.name']" position="replace">
            <Avatar t-if="hasAvatar(row)" t-props="getAvatarProps(row)"/>
            <t t-else="" t-esc="row.name"/>
        </xpath>
    </t>

`);
registerTemplateExtension("web.GraphView.Buttons", `/spreadsheet_edition/static/src/assets/graph_view/graph_view.xml`, `<t t-inherit="web.GraphView.Buttons" t-inherit-mode="extension" xml:space="preserve">
        <xpath expr="//div[hasclass('btn-group')][1]" position="after">
            <t t-if="canInsertChart and !env.isSmall">
                <div class="btn-group" role="toolbar" aria-label="Insert in Spreadsheet">
                    <button class="btn btn-secondary o_graph_insert_spreadsheet" t-att-disabled="!model.hasData() or model.useSampleModel" t-on-click="onInsertInSpreadsheet">
                        Insert in Spreadsheet
                    </button>
                </div>
            </t>
        </xpath>
    </t>
`);
registerTemplateExtension("web.PivotView.Buttons", `/spreadsheet_edition/static/src/bundle/pivot/pivot.xml`, `<t t-name="spreadsheet_edition.PivotView.buttons" t-inherit="web.PivotView.Buttons" t-inherit-mode="extension" xml:space="preserve">
        <xpath expr="//button[hasclass('o_pivot_flip_button')]" position="before">
            <div t-att-data-tooltip="getInsertButtonTooltip()" t-if="canInsertPivot and env.isSmall">
                <button class="btn btn-secondary fa fa-file-text-o o_pivot_add_spreadsheet h-100 rounded-end-0" t-att-disabled="isInsertButtonDisabled()" title="Insert in Spreadsheet" aria-label="Insert in Spreadsheet" t-on-click="onInsertInSpreadsheet"/>
            </div>
        </xpath>
        <xpath expr="//div[hasclass('btn-group')][1]" position="after">
            <t t-if="canInsertPivot and !env.isSmall">
                <div class="btn-group" role="toolbar" aria-label="Insert in Spreadsheet" t-att-data-tooltip="getInsertButtonTooltip()">
                    <button class="btn btn-secondary o_pivot_add_spreadsheet" t-att-disabled="isInsertButtonDisabled()" t-on-click="onInsertInSpreadsheet">
                        Insert in Spreadsheet
                    </button>
                </div>
            </t>
        </xpath>
    </t>
`);
                    });


//# sourceMappingURL=/web/assets/1/cb0e845/web_studio.studio_assets.js.map